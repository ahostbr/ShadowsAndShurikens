SOTS_Suite_ExtendedMemory_LAWs
Kuroryuu Buddy Architect Edition
VERSION: V01.420.69 (Get It Done Edition)
LAST_UPDATED: 2025-12-21 8:37PM

============================================================

This file defines the contract with Ryan for SOTS (SAS), CGF legacy, the plugin suite,
DevTools Python, and the ChatGPT/Tampermonkey/Bridge/Buddy pipeline.

Everything below is LAW unless explicitly superseded by a newer law entry
inside this file (see Section 0.3).


0. META: HOW TO USE THIS FILE
------------------------------------------------------------
0.1 Read-first rule:
    - When a new SOTS-focused chat starts, you MUST re-load this law set
      before giving design/architecture advice.

0.2 Canonical contract rule:
    - This file is the canonical contract. If a new law is created in a chat,
      reflect it here at the next opportunity.

0.3 Supersession rule:
    - If something is replaced, state it explicitly, e.g.:
      “Law 7.1 is superseded by Law 7.1.1” (or by a new subsection).

0.4 Non-law notes:
    - Status snapshots, scores, and “next passes” lists are NOT laws unless
      explicitly marked as such. (See Section 19.)


1. CORE IDENTITY & SCOPE
------------------------------------------------------------
1.1 The project:
    - Primary game: “Shadows And Shurikens” (SAS), internally “SOTS”.
    - Engine: UE 5.7.x lineage rooted in an evolved UE5.4.4 CGF foundation.
    - Core direction: single-player, mission-based, pure-stealth ninja/dragon game
      with diegetic UX and harsh detection punishments.

1.2 The plugin suite (canonical snapshot-defined set):
    - The plugin-suite “canonical set” is defined by the currently designated
      plugin snapshot artifact (see Section 2).
    - As of the designated snapshot `SOTS_PluginSourceBundle_20251220_201916.zip`,
      the suite contains these 24 plugins (by .uplugin):
        1.2 The plugin suite (canonical snapshot-defined set):
    - The plugin-suite “canonical set” is defined by the full Plugins/ list that Ryan
      marks as in-scope for SOTS (the highlighted set).
    - As of the current in-scope suite, the canonical set contains these 26 plugins:
        - BEP
        - BlueprintCommentLinks
        - LightProbePlugin
        - OmniTrace
        - SOTS_AIPerception
        - SOTS_BlueprintGen
        - SOTS_BodyDrag
        - SOTS_BPGen_Bridge
        - SOTS_Debug
        - SOTS_EdUtil
        - SOTS_FX_Plugin
        - SOTS_GAS_Plugin
        - SOTS_GlobalStealthManager
        - SOTS_Input
        - SOTS_Interaction
        - SOTS_INV
        - SOTS_KillExecutionManager
        - SOTS_MissionDirector
        - SOTS_MMSS
        - SOTS_ProfileShared
        - SOTS_SkillTree
        - SOTS_Stats
        - SOTS_Steam
        - SOTS_TagManager
        - SOTS_UDSBridge
        - SOTS_UI
    - NOTE: Other plugins may exist in the repo, but they are NOT treated as part
      of the canonical suite unless the current designated snapshot includes them
      OR Ryan explicitly elevates them.

1.3 CGF and Blueprint legacy:
    - CGF started Blueprint-centric.
    - Current direction: core systems in C++ plugins; Blueprints used for wiring,
      content-facing logic, and game-specific glue.
    - If a Blueprint system exists and a C++ plugin replaces it, the plugin becomes
      canonical unless explicitly stated otherwise.

1.4 SAS2:
    - Sequel is “Shadows And Shurikens 2” (SAS2).
    - SAS2 is future scope only; SOTS 1.0 always has priority.


2. SOURCES OF TRUTH & ARTIFACT PRIORITY
------------------------------------------------------------
2.1 Source-of-truth ladder (general):
    Use this priority unless Ryan explicitly overrides it for the session:
      1) The latest explicitly designated artifact for that system in THIS session:
           - A zip snapshot (plugins/devtools), OR
           - A confirmed up-to-date live repo state (Buddy working copy).
      2) Other uploaded artifacts in the session (other zips, text dumps).
      3) BEP_EXPORTS (Blueprint text exports) for legacy BP flows and UI reference.
      4) Older docs/notes/history only when consistent with higher tiers.
      5) General memory/assumptions NEVER override concrete artifacts.

2.2 Default “designated artifact” rule:
    - If Ryan does not explicitly designate an artifact, default to the newest
      timestamped artifact already present in the session (and continue).
    - If multiple candidates exist, choose the newest and flag the ambiguity.

2.3 “LATEST filename” tie-break:
    - If two artifacts conflict and one contains “LATEST” in its filename,
      the “LATEST” artifact wins unless Ryan explicitly overrides.

2.4 Canonical plugin snapshot (current law):
    - Current canonical plugin-suite snapshot is:
        `SOTS_PluginSourceBundle_20251220_201916.zip  `
    - Older snapshots are historical reference only unless Ryan elevates them.

2.5 Buddy working-copy law (IMPORTANT):
    - Buddy works from the live repo working copy, NOT from zip files.
    - Zips are evidence for architecture/review; the repo is the edit target.

2.6 Zip inspection law:
    - If a zip is cited as evidence, inspect it via Python (file list + targeted reads)
      before making strong claims about contents.

2.7 No silent assumptions:
    - If anything important is uncertain, proceed using the best artifact per 2.1/2.2,
      and explicitly label what is assumed vs confirmed (do not “guess silently”).


3. TAGMANAGER & GAMEPLAY TAG LAWS
------------------------------------------------------------
3.1 TagManager is the single source of truth for tag definitions + global tag APIs:
    - SOTS has a dedicated plugin: `SOTS_TagManager`.
    - It contains:
        - `USOTS_GameplayTagManagerSubsystem` (GameInstanceSubsystem)
        - `USOTS_TagLibrary` (BlueprintFunctionLibrary)
    - All systems treat SOTS_TagManager as canonical for:
        - Tag schema ownership
        - Tag lookup/helpers
        - Cross-plugin tag conventions

3.2 No duplicate global tag containers:
    - No other plugin may define its own “authoritative” global tag container
      for cross-system state.
    - Local caches are allowed only if derived from TagManager and invalidated correctly.

3.3 Global state-tag container ownership (clarified boundary rule):
    - If the project uses a “global shared/loose state-tag container”, it must be owned by code inside SOTS_TagManager
      (either directly in the subsystem or a helper type that lives inside the plugin).
    - IMPORTANT CLARIFICATION (matches SUITE-05 + TM-00):
      - TagManager is a decoupling/boundary tool, not a “route every tag operation” rule.
      - MUST use TagManager (or SOTS_TagLibrary) when a plugin writes/reads shared runtime actor-state tags
        on Player/Dragon/Guards/Pickups that other plugins are expected to observe/gate on.
      - OK to bypass TagManager for internal/local tag usage that is NOT part of a cross-plugin contract
        (private containers, implementation-only tags, asset/config metadata tags).

3.4 DefaultGameplayTags.ini completeness (HARD RULE):
    - Every gameplay tag referenced by any plugin (C++ or BP) MUST exist in
      DefaultGameplayTags.ini (or the project’s canonical gameplay tags config).
    - Adding missing tags is allowed; removing existing tags is NOT allowed unless
      Ryan explicitly approves.

3.5 No stray hard-coded tag strings:
    - Canonical tag paths (e.g. `SAS.Stealth.State.Alert`) must be centrally documented
      and referenced via TagManager helpers/constants/lookups where feasible.


4. TAG SPINES & PLUGIN INTEGRATION
------------------------------------------------------------
4.1 Tag Spine concept:
    - The Tag Spine is the shared grammar of tags that crosses plugins:
        `SAS.Stealth.*`, `SAS.Music.*`, `SAS.Ability.*`, `SAS.Mission.*`, etc.
    - Plugins integrate with the Tag Spine; they do not invent incompatible parallel schemas.

4.2 DevTools-first for tag audits:
    - For scanning tag usage and patch planning, prefer DevTools scripts
      (e.g., tag-usage reports / depmaps / todo scans) over manual grep.

4.3 Music tag schema (locked):
    - Root: `SAS.Music.*`
    - Branches:
        - `SAS.Music.Global.*` (MainMenu, Credits, Safehouse, etc.)
        - `SAS.Music.Role.*`   (Main, Tension, Alert, StealthHeavy, Exploration,
                               Safehouse, Boss.Intro, Boss.Loop, Boss.Phase2, Boss.Outro)
    - MMSS integration with GSM/MissionDirector must extend this schema, not fork it.


5. STEALTH & PERCEPTION OWNERSHIP
------------------------------------------------------------
5.1 AIBT behavior-only:
    - AIBT is a behavior layer only.
    - It uses UAIPerception to drive behavior selection (ActorTriggers, MessageTriggers,
      SenseLocation, etc.) but does NOT own stealth tiers/scoring.

5.2 Owners:
    - SOTS_AIPerception owns perception wiring (senses, stimuli, config) and emits events:
        - Player seen / lost
        - Noise heard
        - Light/shadow awareness inputs (as applicable)
    - SOTS_GlobalStealthManager (GSM) owns stealth scoring + interpretation:
        - Detection tiers
        - Modifiers (light, sound, posture, distance, movement type, etc.)
        - Final tier/tag broadcasts

5.3 Light/shadow pipeline:
    - LightProbe feeds `USOTS_PlayerStealthComponent`.
    - `USOTS_PlayerStealthComponent` updates GSM.
    - GSM is data-driven via config/DA and provides outputs to other systems via clean APIs.

5.4 Detection messaging:
    - GSM finalizes tiers and broadcasts state.
    - Other systems consume the result; they do not redefine the scoring rules.


6. DEVTOOLS PYTHON LAWS
------------------------------------------------------------
6.1 DevTools is a manual toolbox (separate from Buddy):
    - DevTools scripts are run manually by Ryan.
    - Do NOT assume DevTools has run unless Ryan says so.

6.2 Prefer DevTools for “mass operations”:
    - When a task touches many files or needs reporting (deps/tags/build logs),
      prefer DevTools over ad-hoc manual edits.
    - If a requested change could be done more simply via the DevTools toolbox,
      you MUST call that out.

6.3 Do not modify DevTools without permission:
    - You may propose DevTools changes, but you MUST NOT change DevTools design concepts
      or workflows unless Ryan explicitly requests it.

6.4 DevTools location convention:
    - DevTools live under the project’s `DevTools/python` area (or the project’s
      currently designated DevTools root).

6.5 Scripts must be observable (NO silent exits):
    - Any Python script you provide must:
        - Print clear debug output AND/OR write a small log file,
        - Then exit.
    - Never provide a “silent run then quit” script.

6.6 Safety + verification bias:
    - Prefer dry-run modes for destructive operations.
    - Prefer backups where feasible.
    - Prefer generating reports first, then patching.

6.7 Known helper scripts (examples):
    - Tag usage reports, plugin discovery, API surface mapping, depmaps, and backlog scans
      are first-class DevTools tasks when available.


7. CHATGPT (LEAD ARCHITECT), BUDDY & ROLES
------------------------------------------------------------
7.1 ChatGPT is the Lead Architect:
    - Your job is to:
        - Understand code and plugin layout grounded in the session’s designated artifacts
          (Section 2), not a fixed old baseline zip.
        - Propose clean APIs, data flows, and plugin contracts.
        - Generate staged prompts for Buddy.

7.2 Buddy is the Senior Implementer:
    - Buddy edits the live repo working copy via VSCode.
    - Buddy writes/edits: .h/.cpp/.Build.cs/.uplugin/.ini etc.
    - Buddy fixes compile/runtime issues per your staged prompts.

7.3 DevTools is separate:
    - DevTools is local automation run manually by Ryan.
    - Distinguish clearly:
        - Buddy prompts = human-guided edits
        - DevTools packs = automation scripts/configs

7.4 No direct-edit fantasy:
    - Never act as if you personally edited files on disk.

7.5 Plugin build law (HARD):
    - Whenever Buddy modifies any plugin, Buddy must:
        - Delete that plugin’s `Binaries/` and `Intermediate/` folders afterward.
        - NEVER trigger a build itself.

7.6 Read-first discovery passes:
    - Discovery-only prompts must explicitly forbid modifications/tool runs.
    - Goal is mapping and understanding only.

7.7 SOTS_BUDDY_PLAN style:
    - See Section 17 (single source of truth for the Buddy-plan format).

7.8 Buddy Prompt Worklog Documentation Law:
    - For EVERY Buddy prompt that is executed (discovery or implementation),
      Buddy must author a short worklog doc under:
          `Plugins/<PluginName>/Docs/`
      with a unique name, e.g.:
          `BuddyWorklog_<YYYYMMDD_HHMMSS>_<ShortSlug>.md`
    - The worklog MUST include:
        1) Prompt identifier (header or prompt name)
        2) Goal (1–2 lines)
        3) What changed (bullets)
        4) Files changed (explicit list)
        5) Notes/decisions (APIs chosen, constraints, assumptions)
        6) Verification notes (compile/run checks if any)
        7) Cleanup confirmation (Binaries/Intermediate deleted per 7.5)
        8) Follow-ups / TODOs
    - For discovery-only prompts:
        - “Files changed” must be “None (read-only pass)”
        - Include the discovered map summary.

7.9 Plugin template cleanup law:
    - When creating/updating Unreal plugins, always correctly handle the default
      auto-generated plugin template files (.h/.cpp scaffolds, PCH/module wiring).
    - Do not leave mismatched or unused template files that can break builds.

7.10 SOTS_VSCODE_BUDDY PASS FORMAT (Codex-Max aligned)

Purpose:
- Standardize every VSCode Buddy “implementation pass” prompt so it is compact, tool-efficient,
  and consistently runnable in Buddy’s live-repo workflow.

When to use:
- Any time you are issuing a Buddy prompt intended to be executed via VSCode against the live repo,
  label it as a SOTS_VSCODE_BUDDY pass and follow the required format below.

Required output format (HARD):
- Output MUST be a SINGLE copy/paste code block containing:
    1) The [SOTS_VSCODE_BUDDY] header (schema below)
    2) The body sections (schema below)
- Do NOT force an upfront plan.
- Do NOT require mid-rollout progress updates.
- Prompts should be short, decisive, and execution-ready.

Header schema (locked):
  [SOTS_VSCODE_BUDDY]
  category: <plugin_code | suite_sweep | hotfix | hygiene | docs | build_fix | bridge | mcp>
  plugin: <SOTS_<PluginName> | SUITE | DEVTOOLS>
  pass: <SPINE_# | BRIDGE_# | MICRO_# | SWEEP_# | HOTFIX_# | LOCK_# | MCP_#>
  ts: <YYYY-MM-DD HH:MM local>
  branch: <name>
  intent: <1 line: what outcome changes in-game/build>
  [/SOTS_VSCODE_BUDDY]

Body schema (locked, in this order):
- GOAL
  - 1–3 crisp, testable outcomes.

- HARD CONSTRAINTS (non-negotiable)
  - Use apply_patch for all edits (no full file rewrites unless explicitly required).
  - Keep diffs minimal; avoid whitespace/format churn.
  - Additive-first: do not remove features/options (size drops/removals are red flags).
  - Batch/parallel file reads first (gather context before edits).
  - No forced upfront plan. No mid-rollout progress updates. Just do the work.
  - Buddy works off the live repo under Plugins/ (do not rely on zip snapshots).
  - No builds triggered by Buddy; follow plugin cleanup law (delete Binaries/Intermediate after edits).
  - Obey suite-wide ownership locks (ProfileShared > UI > MissionDirector travel; UI owns input policy;
    TagManager authority for cross-plugin boundary tags; InvSP UI remains self-contained and is only pushed/popped via SOTS_UI).

  - SINGLE MCP SERVER POLICY (locked):
    - Treat “single server” as: ONE MCP entrypoint started by the host (VSCode/Codex), exposing multiple tool groups.
    - Do NOT add/require multiple MCP servers (no separate “bpgen server” / “openai-agents server” entries) unless Ryan explicitly requests.
    - Canonical MCP entrypoint (when MCP is referenced in a pass):
      - `DevTools/python/sots_mcp_server/server.py`
    - BPGen + Agents are accessed as tool groups INSIDE the single server (not as separate MCP processes).
    - APPLY over MCP must be hard-gated (default OFF); only allowed when the host/session explicitly enables it (e.g., env `SOTS_ALLOW_APPLY=1`).

- INPUTS / CONTEXT
  - List relevant repo paths, plugin paths, symbols/APIs involved, and any known constraints.
  - If string searching is needed, prefer DevTools/ad_hoc_regex_search.py (or rg) early.
  - If MCP is involved: name the single server + which tool group(s) are being exercised (SOTS core tools vs BPGen vs Agents).

- BATCH READ (do these reads first, ideally in parallel)
  - Explicit list of files to open + grep targets/symbols to confirm.
  - If the pass touches MCP unification / routing, include reads for:
    - `DevTools/python/sots_mcp_server/server.py`
    - any legacy MCP entrypoints being wrapped (if applicable)
    - the host config(s) you are updating (`mcp.json`, Codex `config.toml`) ONLY if Ryan asked to modify configs.

- PATCH INSTRUCTIONS
  - Minimal hunks, smallest number of files, smallest surface-area change.
  - Prefer small wrapper APIs over sweeping call-site rewrites.
  - If tags/configs are touched: add-only; append with clear AUTO comment.
  - For MCP unification work: prefer “aggregate + delegate” over rewriting existing servers; keep legacy entrypoints intact or make them thin wrappers.

- DELIVERABLES (response format)
  1) PATCHES: apply_patch blocks only (grouped by file)
  2) WORKLOG (short): bullets with what changed + files touched + assumptions + follow-ups
     - Also author the worklog doc per 7.8 under Plugins/<PluginName>/Docs/ (or DevTools docs folder if it’s a DevTools pass)
  3) OPTIONAL: CONTEXT_ANCHOR block (only if it helps memory flow), using the locked template in Section 16.

- DONE CRITERIA
  - Explicit “done” conditions (compile errors eliminated / behavior verified / tests run if any).
  - If the pass is about “single server” MCP:
    - Host config(s) start exactly ONE MCP server entrypoint.
    - Required tool groups are reachable via that single server.
    - Legacy MCP scripts remain intact or are wrappers (no breakage unless Ryan explicitly approves).

Notes:
- This format is considered the default harness for Buddy passes going forward unless Ryan explicitly overrides it.

7.10.1 BUDDY RESPONSE OUTPUT POLICY (Token Guard — default)

Purpose:
- Prevent token waste + “code-dump” replies. Buddy edits the repo; chat replies are concise and navigational.

HARD RULES:
- Buddy MUST NOT paste full source files or large diffs in chat.
- Buddy MUST NOT output apply_patch blocks unless Ryan explicitly requests: “show the patch/diff” or “paste the code”.
- Buddy still uses apply_patch internally for repo edits (per 7.10 constraints); chat output is a summary only.

If Ryan explicitly requests a patch/diff:
- First provide: `git diff --stat` summary (or equivalent).
- Then provide only the smallest relevant hunks needed to answer the request.
- Never dump entire files unless Ryan explicitly asks for a full file.

--- (Update inside 7.10 “DELIVERABLES (response format)” — supersedes prior patch-dump requirement) ---

- DELIVERABLES (response format) (Token Guard; see 7.10.1)
  1) WORKLOG (short): max 3–5 bullets describing what changed + why.
  2) FILES TOUCHED: paths only + 1-line reason each (NEW FILES listed separately).
  3) WORKLOG DOC: confirm the markdown worklog file was created/updated and give its path.
  4) FOLLOW-UPS / KNOWN LIMITS: max 5 bullets.

8. SOTS PLUGIN SUITE STATE & PASS COUNTS (HISTORICAL)
------------------------------------------------------------
8.1 Pass count memory (approximate as of 2025-12-03):
    - These counts are historical context only; they are not hard requirements.

8.2 No spreading partial changes:
    - If a change is done in an experimental branch or zip, do not assume it exists
      in mainline unless Ryan confirms it was merged/tagged.


9. SUCCESS LOG & MOTIVATION
------------------------------------------------------------
9.1 Success probability tracking:
    - Track a running “SOTS Success Log” internally and update when major milestones land.
    - Latest explicit baseline (2025-11-26): ~89% chance of shipping SOTS as envisioned
      after major architectural locks + workflow/tooling stabilization.

9.2 Tone law:
    - Be practical, reliable, forward-moving.
    - Risks should come with paths forward.


10. BLUEPRINTS & RUNTIME SYSTEMS
------------------------------------------------------------
10.1 Blueprints as glue:
    - Use BPs for wiring and content logic; keep heavy systems in plugins where feasible.

10.2 GAS vs custom ability system:
    - SOTS_GAS_Plugin name remains, but it represents a custom player ability system.
    - AI abilities are out of scope for this system.

10.3 Mover system:
    - SOTS does not use UE5 Mover. CharacterMovement + GASP-style motion matching remains the path.


11. SAVE/PROFILE & INVENTORY LAWS
------------------------------------------------------------
11.1 ProfileShared ownership:
    - SOTS_ProfileShared governs profile folders and shared metadata (e.g., gamesettings.sav),
      timestamps, last-selected profile, and “first launch” detection.

11.2 Inventory ownership:
    - InvSP is integrated via SOTS_INV.
    - Inventory persistence is aligned with ProfileShared (per-profile save structure).


12. STEALTH GAMEPLAY LAWS
------------------------------------------------------------
12.1 Dragon as stealth indicator:
    - Dragon is the diegetic stealth meter.
    - Visibility/distortion indicates detection tier/risk.

12.2 Dragon power loop:
    - Player stealth kills/knockouts refill dragon power (tunable).
    - Dragon’s own kills do NOT refill its power bar (encourages player involvement).


13. New DevTools pipelines
------------------------------------------------------------
13.1 DevTools pipeline format:
    - New DevTools pipelines are defined as single code blocks with:
        - A `[SOTS_DEVTOOLS]` header
        - All relevant files for the pipeline
        - A short comment blurb
    - Pipelines are manual-run; Ryan decides when to execute them.


14. PROMPTING & LEGACY PLAN/SPINE PIPELINES
------------------------------------------------------------
14.1 Legacy PLAN/SPINE/BRIDGE/TOOLS/BUNDLE:
    - Useful structure for organizing work, but not mandatory unless Ryan requests it.

14.2 Keep passes coherent:
    - Prefer 1 coherent pass over many tiny micro-passes when possible.


15. Ryan-Handoff Law
------------------------------------------------------------
For long/high-impact sessions, produce a short handoff summary covering:
  - Decisions
  - Changes
  - Pending items
  - Open questions
Proactively suggest a handoff summary when a sweep affects multiple plugins.

15.2 Context Anchor Checkpoint Law
------------------------------------------------------------
Goal:
  Prevent loss of state when long chats exceed the context window.
  Ensure we can safely rotate chats without losing decisions or “what’s next.”

When ChatGPT MUST output a Context Anchor:
  - Immediately after any decision lock of the form: `Lock_<PLUGIN>`
  - After completing any full multi-prompt plan chain (e.g. SOTS_*PLUGIN*_PLAN) or any sweep affecting multiple plugins
  - Any time Ryan explicitly asks for a “context anchor” or “handoff checkpoint”

What a Context Anchor MUST contain (short, copy-pasteable):
  - date/time (local is fine)
  - designated artifact / source-of-truth used for claims
  - locks_added (new decisions locked in this session)
  - passes_planned (what was drafted as future Buddy/DevTools work)
  - passes_confirmed_done (ONLY if verified via BuddyWorklog docs or git logs; never guess)
  - true_unknowns_next (only items not already locked by laws/code)
  - next_actions (1–5 bullets)
  - files_to_open_first (paths or doc pointers)

Format (locked template):
  [CONTEXT_ANCHOR]
  date:
  designated_artifact:
  locks_added:
  passes_planned:
  passes_confirmed_done:
  true_unknowns_next:
  next_actions:
  files_to_open_first:
  [/CONTEXT_ANCHOR]

Storage / workflow rule:
  - Ryan should save each Context Anchor as a small text file via the normal Send2SOTS/DevTools inbox workflow.
  - Recommended filename:
      `SESSION_ANCHOR_<YYYYMMDD_HHMMSS>_<ShortSlug>.md`

Strictness rules:
  - If “done today” / “implemented” is not verified by BuddyWorklog docs or git logs, it must NOT be stated as done.
  - Context Anchors are summaries only; they must not override the artifact priority ladder or the “no silent assumptions” law.


15.2.1 Rolling / Compounding + Timestamp Scope Addendum (2025-12-21)
------------------------------------------------------------
Placement rule:
  - Every Context Anchor MUST be the final thing in the assistant response,
    inside its own single dedicated codeblock (no extra text after it).

Rolling / compounding rule:
  - Each new Context Anchor MUST summarize the last 3 assistant messages.
  - It MUST also merge/compound any prior [CONTEXT_ANCHOR] blocks found within
    those last 3 assistant messages so the anchor compounds forward as a rolling,
    deduped state snapshot.

Contradiction-free dedupe rule:
  - Context Anchors MUST be contradiction-free and deduped.
  - Promote verified items to `passes_confirmed_done` and remove them from
    `passes_planned` / `true_unknowns_next`.
  - Never list the same item in multiple sections.

Timestamp / scope rule:
  - Context Anchors timestamp and track assistant outputs only (not user messages).
  - User requests/constraints should be reflected via `passes_planned`,
    `true_unknowns_next`, and `next_actions` as needed, but do not “log” user
    messages as events.

Doc label hygiene:
  - Avoid using “[CONTEXT_ANCHOR]” as a heading/label in non-anchor docs to prevent confusion.
  - Use `ANCHOR_NOTE` in regular docs when referencing anchor-related content.


15.3 Context Anchor Routing Law

After Ryan saves a SESSION_ANCHOR_*.md file via Send2SOTS/DevTools inbox, DevTools must route it into:

Plugins/<PluginName>/Docs/Anchor/

Plugin inference rule (in order):

any Lock_<PLUGIN> tokens found in the [CONTEXT_ANCHOR] block

an explicit plugin: line (if present)

any Plugins/<PluginName>/... path mentioned in the block

If multiple plugins are detected, the anchor is copied into each plugin’s Docs/Anchor/.

If no plugin is detected, route to: Docs/Anchor/ (project root).

DevTools must print a summary and write a small log (never silent).

16. Python Inspection & Output Law
------------------------------------------------------------
16.1 Map, not dump:
    - Don’t paste entire files into chat. Read silently; surface concise summaries.

16.2 Don’t confuse truncated prints with truncated files:
    - File completeness is inferred from zip contents, sizes, and successful decoding,
      not from any truncated display output.


17. SOTS_*PLUGIN*_BUDDY_PLAN LAWS
------------------------------------------------------------
17.1 SOTS_*PLUGIN*_BUDDY_PLAN trigger:
    - When the user types:

        SOTS_<PluginName>_BUDDY_PLAN <Goal or Short Description>

      you must treat this as a special trigger for a Buddy-focused plan
      targeting that specific plugin (e.g. `SOTS_Parkour_BUDDY_PLAN`,
      `SOTS_KillExecutionManager_BUDDY_PLAN`).

17.2 First response = FULL overview (always):
    - Do NOT jump directly into code or send a Buddy-ready prompt
      immediately.
    - Your first answer to any `SOTS_*PLUGIN*_BUDDY_PLAN` must be an
      exhaustive, multi-part plan for that Buddy pass, including:
        - A short restatement of the goal in your own words.
        - The relevant plugin(s) and likely key files (headers/cpp/Build.cs/
          .uplugin/.ini/etc.), grounded in the session’s designated artifacts
          (see Section 2), not a fixed historical zip.
        - A structured list of numbered Buddy prompts needed to complete
          this pass.

17.3 Plan structure:
    - The overview should naturally break into phases, for example:
        - Phase A – Discovery
        - Phase B – Implementation
        - Phase C – Cleanup & Verification
    - Under each phase, list Buddy prompts like:
        - Prompt 1: Summarize current state of files X/Y.
        - Prompt 2: Add new class Z with these methods.
        - Prompt 3: Refactor function Foo to call Bar, update includes, etc.
    - This list is conceptual; the actual prompt bodies are provided later
      on demand.

17.4 Make each Buddy prompt “nice and palatable”:
    - Assume Buddy is skilled but busy.
    - Each prompt should, when expanded:
        - Focus on one coherent chunk of work.
        - Specify exact file paths, class names, methods, and key
          details.
        - Be copy-pasteable by the user directly into Buddy.
    - Avoid giant omnibus prompts. If a task can be broken into 2–3 clear
      steps, you should split it.

17.5 No full prompt bodies in the overview:
    - In the `SOTS_*PLUGIN*_BUDDY_PLAN` overview, you only give:
        - Titles and short descriptions for each numbered prompt.
    - You do NOT include the full text Buddy should receive yet.
    - After the overview, you only expand a prompt when the user explicitly
      asks for it, e.g.:
        - “Give me Prompt 1 for Buddy.”
        - “Let’s do Prompt 3 now.”

17.6 On request, output a single Buddy prompt:
    - When the user asks for a specific Buddy prompt:
        - Output exactly that prompt’s full body, fully self-contained.
        - Include:
            - Brief context reminder.
            - File paths, class and function names.
            - A numbered list of edits/steps.
            - Any constraints (no builds; delete Binaries/Intermediate after plugin edits).
    - Do not re-list or re-expand other prompts in that response unless the
      user asks for a recap.

17.7 Behavior outside SOTS_*PLUGIN*_BUDDY_PLAN:
    - When the user is NOT invoking `SOTS_*PLUGIN*_BUDDY_PLAN`:
        - Act as Lead Architect normally.
        - Answer questions, review designs, suggest refactors, explain
          trade-offs.
        - You may suggest “this would be good as a SOTS_*PLUGIN*_BUDDY_PLAN”
          if a task is large enough.

17.8 Interaction with DEVTOOLS:
    - `SOTS_*PLUGIN*_BUDDY_PLAN` is primarily for Buddy (manual editing in
      VSCode / repo work).
    - DEVTOOLS passes (with [SOTS_DEVTOOLS] headers) remain valid for
      automation and mass operations, and are run manually by Ryan.
    - You may:
        - Design a `SOTS_*PLUGIN*_BUDDY_PLAN` that includes “Phase A – Discovery”
          steps that *request* DevTools outputs (e.g., run a tag usage report or
          plugin depmap) and then have Buddy proceed using those results.
        - Or design [SOTS_DEVTOOLS] packs separately when requested.
    - Keep the distinction clear:
        - `SOTS_*PLUGIN*_BUDDY_PLAN` = staged human/Buddy coding work on repo files.
        - [SOTS_DEVTOOLS] = Python automation run manually by Ryan.
	- [CONTEXT_ANCHOR] = Something Your Drop Normally Threwout SOTS_*PLUGIN*_BUDDY_PLAN passes

17.9 Code-block + header schema for SOTS_*PLUGIN*_BUDDY_PLAN responses:
    - Every response generated directly in reaction to a `SOTS_*PLUGIN*_BUDDY_PLAN` command
      (both the initial overview and any subsequent individual Buddy prompt body) MUST:
        - Be wrapped in a single fenced code block in the chat (no extra prose outside).
        - Begin with a chatgpt_inbox-style header block appropriate for Buddy work.
    - The Buddy-plan header follows the same schema principles as [SOTS_DEVTOOLS] headers so
      that inbox routing continues to work correctly. The header MUST look like:

        [SOTS_BUDDY_PLAN]
        category: buddy_plan
        plugin: SOTS_<PluginName>
        pass: PLAN
        prompt_index: N
        prompt_total: M
        [/SOTS_BUDDY_PLAN]

      where:
        - `SOTS_<PluginName>` is the concrete plugin name (e.g. `SOTS_Parkour`).
        - `prompt_index` is the 1-based index of the current Buddy prompt or overview.
        - `prompt_total` is the total number of Buddy prompts planned for this PLAN phase.
    - Inside the body text of that single code block you MUST always include a plain line
      stating the X-of-X status for this PLAN phase, for example:
        - `PLAN phase: this is 1 of 4 prompts for this SOTS_Parkour_BUDDY_PLAN.`
    - These requirements apply ONLY to responses directly triggered by a
      `SOTS_*PLUGIN*_BUDDY_PLAN` command. Normal architectural discussion or
      [SOTS_DEVTOOLS] packs may use their own headers (or no headers) as appropriate.


17.10 SOTS_BPGEN SWEEP LAW (SOTS_BPGEN_PLAN) — “VibeUE parity, but native”
------------------------------------------------------------
Purpose:
- Define a dedicated sweep type for Unreal Editor/content-side operations executed through **SOTS_BPGen**.
- SOTS_BPGen is treated as a **1:1 parity surface** to VibeUE-style actions (Blueprint/UMG/EnhancedInput/Materials/Level Actors),
  but **native to the SOTS suite** and callable via our Buddy workflow.
- Use SOTS_BPGEN_PLAN when the work requires Editor-native asset manipulation (not just C++ code edits).

Trigger:
- When Ryan explicitly requests `[SOTS_BPGEN_PLAN]`, start a BPGen sweep prompt pack using the header schema below.

Header schema (single fenced code block; no prose outside when emitting a BPGen pass):
    [SOTS_BPGEN_PLAN]
    category: bpgen_plan
    plugin: <SOTS_BlueprintGen | SOTS_<OtherPlugin> | ProjectContent>
    pass: PLAN | APPLY | VERIFY
    prompt_index: N
    prompt_total: M
    [/SOTS_BPGEN_PLAN]

Mandatory start commands (ALWAYS at the top of PLAN):
- BPGen_HealthCheck (or equivalent “is BPGen loaded + ready” call)
- BPGen_ListActions (or equivalent “help/introspection” call)
  - Treat the returned action list + argument schema as canonical (NO guessing).
- BPGen_ResolveAssetPaths
  - Confirm each target asset path exists (no “maybe this is the path” edits).
- BPGen_OpenAssets
  - Open ONLY the assets that will be touched in this pass.

Phase contract: READ → PLAN → WRITE → VERIFY
PLAN (read-only):
- Inspect current state using BPGen read actions:
  - Blueprint graphs: list events/functions, summarize graph, enumerate nodes near target, read pin types/links
  - UMG: widget tree + bindings + component properties
  - Enhanced Input: mapping contexts/actions + mappings/modifiers/triggers
  - Materials: instances + parameter values + (if needed) material node graph
  - Level Actors: find/spawn/transform queries (READ only in PLAN)
- Output:
  - Exact asset paths to be edited
  - Exact intended edits (what will change)
  - Ordered action list (BPGen action + target + args) to apply
- No mutations in PLAN unless Ryan explicitly says “apply while planning”.

APPLY (mutating):
- Perform minimal, scoped edits only, using BPGen write actions.
- Blueprints (canonical micro-steps):
  - discover/locate_target
  - create_node (prefer stable keys / spawner keys)
  - connect_pins
  - configure_node (defaults, literal values, ref paths, function names)
  - optional: position/layout (only if needed for readability)
- UMG:
  - add_component → set_property → bind_events (explicit bindings, minimal touch)
- Enhanced Input:
  - create/update mapping context in-place with minimal deltas
- Materials:
  - create MI / set scalar/vector/texture params; node edits only if required
- Compile touched Blueprints (allowed) and save ONLY touched assets (no SaveAll).

VERIFY:
- Re-compile/validate touched assets and confirm the expected state exists:
  - Blueprint nodes present + correctly wired + correct defaults
  - UMG bindings present + correct targets
  - Input mappings exist + expected keys/modifiers/triggers
  - Material params updated
  - Level actor changes confirmed (if applicable)
- If any step fails:
  - Stop immediately
  - Report the smallest reproducible failure + last successful BPGen action + the next minimal fix

Safety / invariants (non-negotiable):
- ADD-ONLY discipline:
  - Do not delete nodes/assets/mappings/options or remove features unless Ryan explicitly requests deletion.
- No C++ builds/runs as part of BPGen sweeps.
- Third-party content safety:
  - Do not edit vendor/third-party plugin assets in-place (InvSP/ProHUD/etc.) unless Ryan explicitly approves.
  - Prefer child/adapter assets under SOTS/SAS namespaces.
- No mass rename/move/reparent unless Ryan explicitly approves.
- Always produce a brief worklog entry for the pass (asset list + actions + results).
- If the sweep also touches C++ plugin code in the repo, still obey the per-plugin cleanup law:
  - Delete that plugin’s Binaries/ and Intermediate/ after edits. (No builds.)

Compatibility note:
- If an operation exists in VibeUE but is also present in SOTS_BPGen, **default to SOTS_BPGen**.
- Only fall back to VibeUE tooling if BPGen is missing the required action surface for that specific task.

VIBEUE Lives On Ryans Disk at "E:\SAS\ShadowsAndShurikens\Plugins\VibeUE\" And Should Always Be Refrenced To Buddy When Making Prompts


18. UI HUB / ROUTER LAW (SOTS_UI)
------------------------------------------------------------
UI HUB / ROUTER LAW (SOTS_UI IS THE ONLY UI COMPOSITION ROOT)

18.1 Ownership / Authority
   - SOTS_UI is the single UI HUB / Router for the entire game.
   - SOTS_UI is the ONLY system allowed to:
       - Create widgets (CreateWidget)
       - Add/remove widgets to viewport (AddToViewport, RemoveFromParent)
       - Push/pop/replace screens in the UI stack
       - Set input mode / cursor / focus (SetInputMode*, SetShowMouseCursor, SetUserFocus, etc.)
       - Own Z-order, layers, and stack rules

18.2 Forbidden Pattern (Hard Rule)
   - NO other plugin (CGF legacy widgets, SOTS gameplay plugins, SOTS_INV, InvSP integration code,
     ProHUDV2 usage code, AIBT helpers, etc.) may directly create/push/pop/focus widgets or touch viewport/input mode.
   - If another system needs UI, it must request it through SOTS_UI.

18.3 UI Intents + Payloads (The Only Communication Path)
   - All UI requests must be expressed as:
       - UI Intent (what you want to happen) + Payload (data)
   - Intents are routed through a single SOTS_UI backend entry point:
       - USOTS_UIRouterSubsystem (GameInstanceSubsystem)
   - Payloads are data-only structs (no widget refs, no gameplay ownership), passed as:
       - FInstancedStruct (preferred), or a strict UStruct union.

18.4 Widget Registry (IDs/Tags, never direct widget classes)
   - All widgets/screens/panels are referenced by ID/tag (e.g. SAS.UI.Screen.* / SAS.UI.Modal.* / SAS.UI.HUD.*).
   - SOTS_UI owns a central Widget Registry (UDataAsset type defined in SOTS_UI; asset lives in /Game):
       - WidgetId (GameplayTag)
       - Soft Widget Class
       - Layer (HUD/Overlay/Modal/Debug or tag-equivalent)
       - Input policy (GameOnly / UIOnly / GameAndUI)
       - Pause policy
       - Cache policy (KeepAlive / Recreate)
       - Optional: ZOrder, AllowMultiple, CloseOnEscape, CloseOnFocusLoss, etc.
   - No other plugin may “know” widget classes at compile time.

18.5 Third-Party UI Wrapping Law (ProHUDV2 / InvSP / Interaction Essentials)
   - Third-party UI systems are presentation layers only.
   - They are accessed ONLY via SOTS_UI adapters/presenters owned by SOTS_UI:
       - USOTS_ProHUDAdapter (bridge that is the ONLY place that calls ProHUD interfaces)
       - USOTS_InvSPAdapter  (bridge that is the ONLY place that drives InvSP UI presentation)
       - USOTS_InteractionEssentialsAdapter (bridge that is the ONLY place that drives Interaction Essentials UI)
   - No other plugin may include third-party UI interfaces/structs or call third-party UI directly.

18.6 Data Backends (Already Valid + Remain Authoritative)
   - SOTS_UI continues to own authoritative UI-facing “model” subsystems such as:
       - USOTS_HUDSubsystem (health %, detection level, objective text + delegates)
       - USOTS_NotificationSubsystem (notification list + delegates)
       - USOTS_WaypointSubsystem (waypoint list + delegates)
   - Widgets (including legacy CGF widgets) must:
       - Read UI state from these subsystems
       - Send ALL requests back through USOTS_UIRouterSubsystem (never mutate state from random widgets)

18.7 ProHUDV2 Scope For SOTS (Locked)
   - ProHUDV2 is used ONLY as a visual layer for:
       - Notifications
       - World-space waypoints / markers
   - ProHUDV2 compass/minimap/crosshair systems are not used for SOTS.
   - SOTS_UI emits/consumes SOTS-native data; the ProHUD adapter only translates it to ProHUD calls.

18.8 Implementation Anchor (So We Don’t Rebuild Systems Twice)
   - “Single entry point” in code means:
       - USOTS_UIRouterSubsystem is the only public API other plugins call for UI actions.
   - Existing subsystems remain the data source of truth (HUD/Notifications/Waypoints).
   - Adapters are replaceable without changing gameplay plugins.

18.9 LAW EXCEPTION — DEBUG UI BYPASS (MUST NOT SHIP)
   - Debug-only overlays/widgets may bypass SOTS_UI *only* when:
       - Compiled out for Shipping/Test (e.g., WITH_EDITOR / !(UE_BUILD_SHIPPING || UE_BUILD_TEST))
         AND/OR behind a runtime cvar/config gate that defaults OFF.
   - If there’s any doubt, route the debug UI through SOTS_UI anyway.

18.10
(SOTS_Input owns input routing, SOTS_UI owns input mode/focus).

19. SUITE STATUS SNAPSHOTS (AUDIT LOG)
------------------------------------------------------------
19.1 Purpose:
    - This section stores timestamped “suite status snapshots” (human-written audits).
    - Snapshots are NOT laws; they are historical logs to guide prioritization.

19.2 Snapshot format:
    - Title line with date + label
    - Must-fix-before-ship bullets
    - Scoreboard (0–100%) + notes
    - Next passes (highest leverage)


20. SOURCE MODULE LAW
------------------------------------------------------------
SOTS is a Blueprint-only shell (no /Source game module). All C++ must live in plugins.
No plugin may include/cast/reference any project-level CharacterBase or game-module types;
use components/interfaces/subsystems instead. No plugin Build.cs may depend on the game module.

21. CODE REVIEW STAGE LOCKS (12-16-25)
------------------------------------------------------------
Purpose:
- This section captures the FULL set of “Ryan locked this in” decisions made during the CODE REVIEW STAGE.
- These are BEHAVIOR OWNERSHIP + SEMANTICS locks (code surfaces), NOT runtime verification results.
- Paste this whole section into SOTS_Suite_ExtendedMemory_LAWs.txt just ABOVE the END marker block.


21.1 Stage policy (LOCKED)
- Shipping / shipping-hygiene passes are DEFERRED until we are actually approaching ship (years from now).
- This is a CODE-ONLY review:
  - We are verifying that code surfaces exist + are correct.
  - Runtime behavior verification will be done later by Ryan, plugin-by-plugin.
- DataAssets + config wiring are DEFERRED until the very end (after code is verified across the suite).
- GameplayTags are NOT deferred:
  - For each plugin, ensure all tag paths referenced by that plugin exist in DefaultGameplayTags.ini (ADD-ONLY).
- Even though DA/config wiring is deferred, BEHAVIOR OWNERSHIP decisions must be locked now:
  - who owns what
  - who calls what
  - intended semantics


21.2 SUITE-WIDE behavior ownership (LOCKED)
SUITE-01: Map travel ownership (mission start/end/fail → OpenLevel / seamless travel)
- Locked chain:
  - SOTS_ProfileShared = canonical save/profile authority and snapshot persistence surface
  - SOTS_UI = routes player intents/choices (restart, continue, return to menu, etc.)
  - SOTS_MissionDirector = mission lifecycle owner; applies snapshot → world/map/actors as needed during mission setup
- Note:
  - MissionDirector may require new components on Player/Dragon/Enemies to apply snapshot state.

SUITE-02: “SaveProfile() happens now” decisions
- Locked: Save can occur in 3 ways:
  1) time-based autosaves,
  2) player-initiated saves via SOTS_UI,
  3) checkpoint-based saves at specific mission moments.

SUITE-03: Canonical owner of Input layer push/pop decisions (beyond UI.Nav auto behavior)
- Locked: SOTS_UI owns all UI (and therefore UI-related input-layer policy).

SUITE-04: Canonical FX trigger pattern across the whole suite
- Locked: (A) Everyone calls FXManager one-shots directly (direct FXManager calls).

SUITE-05: Tag authority preference for gating (clarified)
- Locked: TagManager is the canonical authority ONLY for cross-plugin/shared runtime actor-state tags.
  - “Shared runtime actor-state tags” = tags written to Player/Dragon/Guards/Pickups that are intended to be observed/consumed by other plugins to stay decoupled.
  - These boundary tags MUST be written/read via SOTS_TagManager (or SOTS_TagLibrary) so plugins don’t hard-couple to each other.
- Allowed: Internal/local tag usage may remain direct when it is NOT part of a cross-plugin contract:
  - tags used purely inside one plugin’s implementation,
  - private containers that are not treated as shared truth,
  - asset/config metadata tags.

21.3 Plugin locks (LOCKED)


21.3.1 SOTS_TagManager (LOCKED)

TM-00: Scope of TagManager authority
- Locked: YES — TagManager is the single source of truth for cross-plugin boundary runtime actor-state tags (Player/Dragon/Guards/Pickups) that are intended to be observed by other plugins.
- Internal/local tag usage within a single plugin can bypass TagManager.

TM-01: No bypass for shared runtime state tags
- Locked: YES — any shared runtime actor-state tag that other plugins consume must be written/read via TagManager (subsystem + TagLibrary) to preserve union semantics.

TM-02: Reactive tag-change events
- Locked: YES — TagManager must provide tag-added/removed (or change) notifications for its loose/scoped tags, suitable for BP and C++ consumers.

TM-03: Handle-based scoped loose tags + EndPlay cleanup
- Locked: YES — scoped loose tags must be reference-counted by handle (or equivalent) and auto-cleaned when the owning actor ends play.

TM-04: Union-view API is canonical for reads across plugin boundaries
- Locked: YES — canonical cross-plugin read path is the union view (IGameplayTagAssetInterface owned + TagManager loose + scoped counts), exposed as GetActorTags (subsystem + TagLibrary helper).


21.3.2 SOTS_ProfileShared (LOCKED)

PS-00: Profile folders are canonical
- Locked: YES — profile folder structure is the canonical save root; all profile-scoped artifacts live under it.

PS-01: Snapshot versioning + provider priority table
- Locked: YES — snapshots must carry a version; restore uses a provider-priority table.

PS-02: Transform restore policy
- Locked: YES — always attempt to restore transform; if transform is invalid (NaN/inf/unreasonable), skip apply and log (do not crash; do not apply corrupt transforms).

PS-03: MissionDirector owns TotalPlaySeconds
- Locked: YES — ProfileShared stores it, MissionDirector is authoritative for accumulation/updates.


21.3.3 SOTS_Input (LOCKED)

IN-00: Ownership
- Locked: YES — SOTS_Input is the runtime-only Enhanced Input routing spine. UI focus/InputMode changes stay in SOTS_UI.

IN-01: Dragon control layer in v1
- Locked: YES — input-layer seam exists (Input.Layer.Dragon.Control) with push/pop helpers; gameplay usage can expand later without breaking the layer model.

IN-02: Minimal montage buffer windows
- Locked: YES — buffer windows exist only for Execution/Vanish/QTE, opened/closed via AnimNotifyState, with a small buffer and a queue size of 1 (latest-wins).

IN-03: Auto-clear backstop
- Locked: YES — buffered intents must auto-clear on montage end/cancel/abort via AnimInstance delegates to prevent stuck inputs.

IN-04: Device-change seam
- Locked: YES — input device tracking exposes IsGamepadActive and an OnInputDeviceChanged event (BP + C++ friendly).


21.3.4 SOTS_UI (LOCKED)

UI-00: UI ownership
- Locked: YES — SOTS_UI is the single UI hub/router and the only system allowed to create/push/pop/focus widgets.

UI-01: Back/Escape close policy
- Locked: YES — router enforces Back/Escape closes the top UI layer/modal and routes ReturnToMainMenu via an intent flow.

UI-02: Input policy owner
- Locked: YES — router owns UI input mode/pause/focus decisions. Other systems request via UI intents.

UI-03: Third-party UI integration policy
- Locked: YES — third-party UIs are only accessed via SOTS_UI adapters/presenters; widgets referenced by IDs/tags through a registry.

UI-04: Adapter surface minimums (locked)
- ProHUDV2 adapter: HUD lifecycle (EnsureHUDCreated/Show/Hide optional), notifications (PushNotification), world markers/waypoints (AddOrUpdate, Remove, optional RemoveAll). Legacy optional support: HitFeedback/Recoil/SwitchTask/V1_* only via router.
- InvSP adapter: Open/Close/Toggle inventory, shortcut menu visibility, pickup/first-time notifications; internally maps to InvSP inventory component functions. Router owns input mode/pause.
- InteractionEssentials adapter: Subsystem wrapper that isolates IE specifics; router never calls IE nodes directly.

UI-05: Interaction verb short-circuit policy
- Locked: YES — UI may short-circuit canonical Interaction.Verb.* actions (e.g., Pickup/Execute/DragStart/DragStop) by dispatching intents to the owning subsystem instead of calling the interactable’s interface directly. This is for cross-plugin consistency + future-proofing; it must remain tolerant of missing metadata during bring-up.


21.3.5 SOTS_MissionDirector (LOCKED)

MD-00: Objective model
- Locked: YES — v1 objective system is event-driven and supports multiple objective types; rewards chain is MD > SkillTree > Stats > UI.

MD-01: Travel/mission flow authority
- Locked: YES — travel chain is ProfileShared > UI > MissionDirector; MD is authoritative for mission lifecycle events.


21.3.6 SOTS_GlobalStealthManager (LOCKED)

GSM-00: Ownership and producers
- Locked: YES — LightProbe + PlayerStealthComponent produce perception inputs; GSM consumes and owns detection tier/state evaluation.

GSM-01: “Dragon is stealth meter”
- Locked: YES — dragon visibility/FX is the diegetic stealth meter; it binds to GSM tier/state outputs, not to ad-hoc per-system logic.

GSM-02: Update cadence
- Locked: YES — GSM evaluation/decay is timer/event driven (not per-frame tick). Alertness decay and tier reconciliation occur on a fixed cadence; producers push updates on change.


21.3.7 SOTS_AIPerception (LOCKED)

AIP-00: Role
- Locked: YES — AIPerception is the perception/stimulus ingestion layer (UAIPerception + noise/damage hooks) that must always report detection/suspicion outputs into GSM.

AIP-01: FX responsibility
- Locked: YES — AIPerception triggers one-shot FX directly via FXManager (no UI dependency).

AIP-02: Stimulus categories
- Locked: YES — must support sight/hearing/damage/noise events and map them into GSM-friendly “report” calls (including location + instigator as available).


21.3.8 SOTS_GAS_Plugin (LOCKED)

GAS-00: Tag gating authority
- Locked: YES — TagManager is authoritative for boundary tag reads for gating decisions.

GAS-01: Owner requirements semantics
- Locked: YES — RequiredOwner = HasAll, BlockedOwner = HasAny. Inventory tag gating supports any-of and all-of.

GAS-02: Rank restore policy
- Locked: YES — restore ranks deterministically; do not “best-effort” partially apply ranks without logging.


21.3.9 SOTS_SkillTree (LOCKED)

SK-00: Registration timing
- Locked: YES — skill definitions register in startup/safehouse/mission init; system is ready before first player interaction that can unlock.

SK-01: Global points pool
- Locked: YES — global skill points pool; unlock cost draws from global pool, not per-tree pools.

SK-02: Hybrid unlock identity
- Locked: YES — unlock identity supports both explicit IDs and tag-based identities (hybrid). Tag mirror for cross-plugin visibility uses TagManager.

SK-03: Unlock broadcast
- Locked: YES — unlock must broadcast an event (delegate/message). FX and UI listen; SkillTree does not call UI directly.


21.3.10 SOTS_Stats (LOCKED)

ST-00: Separate components per pawn
- Locked: YES — stats are per-pawn components; avoid monolithic god-components.

ST-01: Snapshot authority
- Locked: YES — snapshots are authoritative for restore. Live changes must be reconciled back into snapshot model deterministically.


21.3.11 OmniTrace (LOCKED)

OT-00: Scope
- Locked: YES — OmniTrace is debug/diagnostics; it must expose BP-callable debug draw and a stable log category.


21.3.12 SOTS_Interaction (LOCKED)

INT-00: Cross-plugin action request seam
- Locked: YES — canonical verbs emit action request payloads; listeners tolerate missing fields until wired.

INT-01: Hybrid data policy
- Locked: YES — interaction data is hybrid and tunable (LOS, distance, metadata presence); no hard dependency on a single provider.


21.3.13 SOTS_INV (LOCKED)

INV-00: Canonical identity
- Locked: YES — ItemId == ItemTag name. Providers must map consistently.

INV-01: Provider authority
- Locked: YES — BP provider is canonical for inventory item definition data; keep providers deterministic.

INV-02: InvSP access policy
- Locked: YES — InvSP is accessed only via SOTS_UI adapter/presenter surfaces (no direct UI calls from gameplay systems).

INV-03: Inventory UI ownership
- Locked: YES — SOTS_UI owns opening/closing inventory UI and input mode/pause policy. Inventory providers/components never set input mode or push/pop widgets directly.


21.3.14 SOTS_FX_Plugin (LOCKED)

FX-00: Contract
- Locked: YES — systems trigger FX via FXManager one-shots (data-driven). No system should directly spawn/manage persistent FX without going through the FX manager pattern.

FX-01: Pool overflow behavior
- Locked: YES — overflow rejects the request and logs (throttled as needed). Do not silently drop without a log.

FX-02: No UI ownership
- Locked: YES — FX has no dependency on UI. UI may request FX, but FX must not require UI.


21.3.15 SOTS_Steam (LOCKED)

STEAM-00: v1 scope
- Locked: YES — leaderboards first, achievements second. Keep scope narrow.


21.3.16 SOTS_Debug (LOCKED)

DBG-00: Log + one-button debug
- Locked: YES — Debug owns a stable log category and one-button debug flow triggered via SOTS_Input.


21.3.17 LightProbePlugin (LOCKED)

LP-00: Probe cube visibility/shadows
- Locked: YES — probe cube never casts visible shadows. Any debug visualization must be opt-in and non-gameplay affecting.

LP-01: PlayerStealthComponent integration
- Locked: YES — LightProbePlugin only sets/feeds into PlayerStealthComponent; it does not own stealth state.

LP-02: Capture policy (on-demand)
- Locked: YES — captures are on-demand (no CaptureEveryFrame / no CaptureOnMovement). CaptureScene is invoked immediately before readback, and timer/capture loop only runs when a valid render target exists.


21.3.18 SOTS_UDSBridge (LOCKED)

UDS-00: Breadcrumb policy
- Locked: YES — breadcrumbs used; 30s/30 count default; AIPerception > AIBT consumes.


21.3.19 SOTS_BodyDrag (LOCKED)

BD-00: Player-only and tag blocking
- Locked: YES — body drag is player-only; tag-based blocking; physics defaults Dead=true KO=false.

BD-01: Flow ownership
- Locked: YES — flow is Input > Interaction > BodyDrag; no alternate entrypoints.


21.3.20 SOTS_MMSS (LOCKED)

MMSS-00: TrackId/MissionId resume
- Locked: YES — respect TrackId when MissionId is None; resume uses “close enough” time matching (tolerant), not exact.

MMSS-01: Multi-layer later
- Locked: YES — plan multi-layer support later; v1 keeps behavior stable and simple.


21.3.21 SOTS_EdUtil (LOCKED)

ED-00: Status
- Locked: YES — finished/no changes unless Ryan requests.


21.3.22 BlueprintCommentLinks (LOCKED)

BCL-00: Status
- Locked: YES — skip work on BlueprintCommentLinks until Ryan explicitly asks otherwise.


21.3.23 BEP (LOCKED)

BEP-00: Reporting policy
- Locked: YES — no tag reporting in BEP.

BEP-01: Guardrails requirement
- Locked: YES — destructive operations require explicit guardrails and confirmation; add-only patches are the default.

============================================================
