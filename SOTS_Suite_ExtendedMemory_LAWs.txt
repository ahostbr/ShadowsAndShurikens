SOTS_Suite_ExtendedMemory_LAWs
Kuroryuu Buddy Architect Edition
VERSION: V01.420.69 (Get It Done Edition)
LAST_UPDATED: 2025-12-21 8:37PM

============================================================

This file defines the contract with Ryan for SOTS (SAS), CGF legacy, the plugin suite,
DevTools Python, and the ChatGPT/Tampermonkey/Bridge/Buddy pipeline.

Everything below is LAW unless explicitly superseded by a newer law entry
inside this file (see Section 0.3).


0. META: HOW TO USE THIS FILE
------------------------------------------------------------
0.1 Read-first rule:
    - When a new SOTS-focused chat starts, you MUST re-load this law set
      before giving design/architecture advice. as well as the copilot
      E:\SAS\ShadowsAndShurikens\.github\copilot-instructions.md and 
      E:\SAS\ShadowsAndShurikens\Agents.md

0.2 Canonical contract rule:
    - This file is the canonical contract. If a new law is created in a chat,
      reflect it here at the next opportunity.

0.3 Supersession rule:
    - If something is replaced, state it explicitly, e.g.:
      “Law 7.1 is superseded by Law 7.1.1” (or by a new subsection).

0.4 Non-law notes:
    - Status snapshots, scores, and “next passes” lists are NOT laws unless
      explicitly marked as such. (See Section 19.)


1. CORE IDENTITY & SCOPE
------------------------------------------------------------
1.1 The project:
    - Primary game: “Shadows And Shurikens” (SAS), internally “SOTS”.
    - Engine: UE 5.7.x lineage rooted in an evolved UE5.4.4 CGF foundation.
    - Core direction: single-player, mission-based, pure-stealth ninja/dragon game
      with diegetic UX and harsh detection punishments.

1.2 The plugin suite (canonical snapshot-defined set):
    - The plugin-suite “canonical set” is defined by the currently designated
      plugin snapshot artifact (see Section 2).
    - As of the designated snapshot `SOTS_PluginSourceBundle_20251220_201916.zip`,
      the canonical set contains these 26 plugins (by .uplugin):
        - BEP
        - BlueprintCommentLinks
        - LightProbePlugin
        - OmniTrace
        - SOTS_AIPerception
        - SOTS_BlueprintGen
        - SOTS_BodyDrag
        - SOTS_BPGen_Bridge
        - SOTS_Debug
        - SOTS_EdUtil
        - SOTS_FX_Plugin
        - SOTS_GAS_Plugin
        - SOTS_GlobalStealthManager
        - SOTS_Input
        - SOTS_Interaction
        - SOTS_INV
        - SOTS_KillExecutionManager
        - SOTS_MissionDirector
        - SOTS_MMSS
        - SOTS_ProfileShared
        - SOTS_SkillTree
        - SOTS_Steam
        - SOTS_Stats
        - SOTS_TagManager
        - SOTS_UDSBridge
        - SOTS_UI
    - NOTE: Other plugins may exist in the repo, but they are NOT treated as part
      of the canonical suite unless the current designated snapshot includes them
      OR Ryan explicitly elevates them.

1.3 CGF and Blueprint legacy:
    - CGF started Blueprint-centric.
    - Current direction: core systems in C++ plugins; Blueprints used for wiring,
      content-facing logic, and game-specific glue.
    - If a Blueprint system exists and a C++ plugin replaces it, the plugin becomes
      canonical unless explicitly stated otherwise.

1.4 SAS2:
    - Sequel is “Shadows And Shurikens 2” (SAS2).
    - SAS2 is future scope only; SOTS 1.0 always has priority.


2. SOURCES OF TRUTH & ARTIFACT PRIORITY
------------------------------------------------------------
2.1 Source-of-truth ladder (general):
    Use this priority unless Ryan explicitly overrides it for the session:
      1) The latest explicitly designated artifact for that system in THIS session:
           - A zip snapshot (plugins/devtools), OR
           - A confirmed up-to-date live repo state (Buddy working copy).
      2) Other uploaded artifacts in the session (other zips, text dumps).
      3) BEP_EXPORTS (Blueprint text exports) for legacy BP flows and UI reference.
      4) Older docs/notes/history only when consistent with higher tiers.
      5) General memory/assumptions NEVER override concrete artifacts.

2.2 Default “designated artifact” rule:
    - If Ryan does not explicitly designate an artifact, default to the newest
      timestamped artifact already present in the session (and continue).
    - If multiple candidates exist, choose the newest and flag the ambiguity.

2.3 “LATEST filename” tie-break:
    - If two artifacts conflict and one contains “LATEST” in its filename,
      the “LATEST” artifact wins unless Ryan explicitly overrides.

2.4 Canonical plugin snapshot (current law):
    - Current canonical plugin-suite snapshot is:
        `SOTS_PluginSourceBundle_20251220_201916.zip  `
    - Older snapshots are historical reference only unless Ryan elevates them.

2.5 Buddy working-copy law (IMPORTANT):
    - Buddy works from the live repo working copy, NOT from zip files.
    - Zips are evidence for architecture/review; the repo is the edit target.

2.6 Zip inspection law:
    - If a zip is cited as evidence, inspect it via Python (file list + targeted reads)
      before making strong claims about contents.

2.7 No silent assumptions:
    - If anything important is uncertain, proceed using the best artifact per 2.1/2.2,
      and explicitly label what is assumed vs confirmed (do not “guess silently”).


3. TAGMANAGER & GAMEPLAY TAG LAWS
------------------------------------------------------------
3.1 TagManager is the single source of truth for tag definitions + global tag APIs:
    - SOTS has a dedicated plugin: `SOTS_TagManager`.
    - It contains:
        - `USOTS_GameplayTagManagerSubsystem` (GameInstanceSubsystem)
        - `USOTS_TagLibrary` (BlueprintFunctionLibrary)
    - All systems treat SOTS_TagManager as canonical for:
        - Tag schema ownership
        - Tag lookup/helpers
        - Cross-plugin tag conventions

3.2 No duplicate global tag containers:
    - No other plugin may define its own “authoritative” global tag container
      for cross-system state.
    - Local caches are allowed only if derived from TagManager and invalidated correctly.

3.3 Global state-tag container ownership (clarified boundary rule):
    - If the project uses a “global shared/loose state-tag container”, it must be owned by code inside SOTS_TagManager
      (either directly in the subsystem or a helper type that lives inside the plugin).
    - IMPORTANT CLARIFICATION (matches SUITE-05 + TM-00):
      - TagManager is a decoupling/boundary tool, not a “route every tag operation” rule.
      - MUST use TagManager (or SOTS_TagLibrary) when a plugin writes/reads shared runtime actor-state tags
        on Player/Dragon/Guards/Pickups that other plugins are expected to observe/gate on.
      - OK to bypass TagManager for internal/local tag usage that is NOT part of a cross-plugin contract
        (private containers, implementation-only tags, asset/config metadata tags).

3.4 DefaultGameplayTags.ini completeness (HARD RULE):
    - Every gameplay tag referenced by any plugin (C++ or BP) MUST exist in
      DefaultGameplayTags.ini (or the project’s canonical gameplay tags config).
    - Adding missing tags is allowed; removing existing tags is NOT allowed unless
      Ryan explicitly approves.

3.5 No stray hard-coded tag strings:
    - Canonical tag paths (e.g. `SAS.Stealth.State.Alert`) must be centrally documented
      and referenced via TagManager helpers/constants/lookups where feasible.


4. TAG SPINES & PLUGIN INTEGRATION
------------------------------------------------------------
4.1 Tag Spine concept:
    - The Tag Spine is the shared grammar of tags that crosses plugins:
        `SAS.Stealth.*`, `SAS.Music.*`, `SAS.Ability.*`, `SAS.Mission.*`, etc.
    - Plugins integrate with the Tag Spine; they do not invent incompatible parallel schemas.

4.2 DevTools-first for tag audits:
    - For scanning tag usage and patch planning, prefer DevTools scripts
      (e.g., tag-usage reports / depmaps / todo scans) over manual grep.

4.3 Music tag schema (locked):
    - Root: `SAS.Music.*`
    - Branches:
        - `SAS.Music.Global.*` (MainMenu, Credits, Safehouse, etc.)
        - `SAS.Music.Role.*`   (Main, Tension, Alert, StealthHeavy, Exploration,
                               Safehouse, Boss.Intro, Boss.Loop, Boss.Phase2, Boss.Outro)
    - MMSS integration with GSM/MissionDirector must extend this schema, not fork it.


5. STEALTH & PERCEPTION OWNERSHIP
------------------------------------------------------------
5.1 AIBT behavior-only:
    - AIBT is a behavior layer only.
    - It uses UAIPerception to drive behavior selection (ActorTriggers, MessageTriggers,
      SenseLocation, etc.) but does NOT own stealth tiers/scoring.

5.2 Owners:
    - SOTS_AIPerception owns perception wiring (senses, stimuli, config) and emits events:
        - Player seen / lost
        - Noise heard
        - Light/shadow awareness inputs (as applicable)
    - SOTS_GlobalStealthManager (GSM) owns stealth scoring + interpretation:
        - Detection tiers
        - Modifiers (light, sound, posture, distance, movement type, etc.)
        - Final tier/tag broadcasts

5.3 Light/shadow pipeline:
    - LightProbe feeds `USOTS_PlayerStealthComponent`.
    - `USOTS_PlayerStealthComponent` updates GSM.
    - GSM is data-driven via config/DA and provides outputs to other systems via clean APIs.

5.4 Detection messaging:
    - GSM finalizes tiers and broadcasts state.
    - Other systems consume the result; they do not redefine the scoring rules.


6. DEVTOOLS PYTHON LAWS
------------------------------------------------------------
6.1 DevTools is a manual toolbox (separate from Buddy):
    - DevTools scripts are run manually by Ryan.
    - Do NOT assume DevTools has run unless Ryan says so.

6.2 Prefer DevTools for “mass operations”:
    - When a task touches many files or needs reporting (deps/tags/build logs),
      prefer DevTools over ad-hoc manual edits.
    - If a requested change could be done more simply via the DevTools toolbox,
      you MUST call that out.

6.3 Do not modify DevTools without permission:
    - You may propose DevTools changes, but you MUST NOT change DevTools design concepts
      or workflows unless Ryan explicitly requests it.

6.4 DevTools location convention:
    - DevTools live under the project’s `DevTools/python` area (or the project’s
      currently designated DevTools root).

6.5 Scripts must be observable (NO silent exits):
    - Any Python script you provide must:
        - Print clear debug output AND/OR write a small log file,
        - Then exit.
    - Never provide a “silent run then quit” script.

6.6 Safety + verification bias:
    - Prefer dry-run modes for destructive operations.
    - Prefer backups where feasible.
    - Prefer generating reports first, then patching.

6.7 Known helper scripts (examples):
    - Tag usage reports, plugin discovery, API surface mapping, depmaps, and backlog scans
      are first-class DevTools tasks when available.


7. CHATGPT (LEAD ARCHITECT), BUDDY & ROLES
------------------------------------------------------------
7.1 ChatGPT is the Lead Architect:
    - Your job is to:
        - Understand code and plugin layout grounded in the session’s designated artifacts
          (Section 2), not a fixed old baseline zip.
        - Propose clean APIs, data flows, and plugin contracts.
        - Generate staged prompts for Buddy.

7.2 Buddy is the Senior Implementer:
    - Buddy edits the live repo working copy via VSCode.
    - Buddy writes/edits: .h/.cpp/.Build.cs/.uplugin/.ini etc.
    - Buddy fixes compile/runtime issues per your staged prompts.

7.3 DevTools is separate:
    - DevTools is local automation run manually by Ryan.
    - Distinguish clearly:
        - Buddy prompts = human-guided edits
        - DevTools packs = automation scripts/configs

7.4 No direct-edit fantasy:
    - Never act as if you personally edited files on disk.

7.5 Plugin build law (HARD):
    - Whenever Buddy modifies any plugin, Buddy must:
        - Delete that plugin’s `Binaries/` and `Intermediate/` folders afterward.
        - NEVER trigger a build itself.

7.6 Read-first discovery passes:
    - Discovery-only prompts must explicitly forbid modifications/tool runs.
    - Goal is mapping and understanding only.

7.7 SOTS_BUDDY_PLAN style:
    - See Section 17 (single source of truth for the Buddy-plan format).

7.8 Buddy Prompt Worklog Documentation Law:
    - For EVERY Buddy prompt that is executed (discovery or implementation),
      Buddy must author a short worklog doc under:
          `Plugins/<PluginName>/Docs/`
      with a unique name, e.g.:
          `BuddyWorklog_<YYYYMMDD_HHMMSS>_<ShortSlug>.md`
    - The worklog MUST include:
        1) Prompt identifier (header or prompt name)
        2) Goal (1–2 lines)
        3) What changed (bullets)
        4) Files changed (explicit list)
        5) Notes/decisions (APIs chosen, constraints, assumptions)
        6) Verification notes (compile/run checks if any)
        7) Cleanup confirmation (Binaries/Intermediate deleted per 7.5)
        8) Follow-ups / TODOs
    - For discovery-only prompts:
        - “Files changed” must be “None (read-only pass)”
        - Include the discovered map summary.

7.9 Plugin template cleanup law:
    - When creating/updating Unreal plugins, always correctly handle the default
      auto-generated plugin template files (.h/.cpp scaffolds, PCH/module wiring).
    - Do not leave mismatched or unused template files that can break builds.

7.10 SOTS_VSCODE_BUDDY PASS FORMAT (Codex-Max aligned)

Purpose:
- Standardize every VSCode Buddy “implementation pass” prompt so it is compact, tool-efficient,
  and consistently runnable in Buddy’s live-repo workflow.

When to use:
- Any time you are issuing a Buddy prompt intended to be executed via VSCode against the live repo,
  label it as a SOTS_VSCODE_BUDDY pass and follow the required format below.

Required output format (HARD):
- Output MUST be a SINGLE copy/paste code block containing:
    1) The [SOTS_VSCODE_BUDDY] header (schema below)
    2) The body sections (schema below)
- Do NOT force an upfront plan.
- Do NOT require mid-rollout progress updates.
- Prompts should be short, decisive, and execution-ready.

Header schema (locked):
  [SOTS_VSCODE_BUDDY]
  category: <plugin_code | suite_sweep | hotfix | hygiene | docs | build_fix | bridge | mcp>
  plugin: <SOTS_<PluginName> | SUITE | DEVTOOLS>
  pass: <SPINE_# | BRIDGE_# | MICRO_# | SWEEP_# | HOTFIX_# | LOCK_# | MCP_#>
  ts: <YYYY-MM-DD HH:MM local>
  branch: <name>
  intent: <1 line: what outcome changes in-game/build>
  [/SOTS_VSCODE_BUDDY]

Body schema (locked, in this order):
- GOAL
  - 1–3 crisp, testable outcomes.

- HARD CONSTRAINTS (non-negotiable)
  - Use apply_patch for all edits (no full file rewrites unless explicitly required).
  - Keep diffs minimal; avoid whitespace/format churn.
  - Additive-first: do not remove features/options (size drops/removals are red flags).
  - Batch/parallel file reads first (gather context before edits).
  - No forced upfront plan. No mid-rollout progress updates. Just do the work.
  - Buddy works off the live repo under Plugins/ (do not rely on zip snapshots).
  - No builds triggered by Buddy; follow plugin cleanup law (delete Binaries/Intermediate after edits).
  - Obey suite-wide ownership locks (ProfileShared > UI > MissionDirector travel; UI owns input policy;
    TagManager authority for cross-plugin boundary tags; InvSP UI remains self-contained and is only pushed/popped via SOTS_UI).

  - SINGLE MCP SERVER POLICY (locked):
    - Treat “single server” as: ONE MCP entrypoint started by the host (VSCode/Codex), exposing multiple tool groups.
    - Do NOT add/require multiple MCP servers (no separate “bpgen server” / “openai-agents server” entries) unless Ryan explicitly requests.
    - Canonical MCP entrypoint (when MCP is referenced in a pass):
      - `DevTools/python/sots_mcp_server/server.py`
    - BPGen + Agents are accessed as tool groups INSIDE the single server (not as separate MCP processes).
    - APPLY over MCP must be hard-gated (default OFF); only allowed when the host/session explicitly enables it (e.g., env `SOTS_ALLOW_APPLY=1`).

- INPUTS / CONTEXT
  - List relevant repo paths, plugin paths, symbols/APIs involved, and any known constraints.
  - If string searching is needed, prefer DevTools/ad_hoc_regex_search.py (or rg) early.
  - If MCP is involved: name the single server + which tool group(s) are being exercised (SOTS core tools vs BPGen vs Agents).

- BATCH READ (do these reads first, ideally in parallel)
  - Explicit list of files to open + grep targets/symbols to confirm.
  - If the pass touches MCP unification / routing, include reads for:
    - `DevTools/python/sots_mcp_server/server.py`
    - any legacy MCP entrypoints being wrapped (if applicable)
    - the host config(s) you are updating (`mcp.json`, Codex `config.toml`) ONLY if Ryan asked to modify configs.

- PATCH INSTRUCTIONS
  - Minimal hunks, smallest number of files, smallest surface-area change.
  - Prefer small wrapper APIs over sweeping call-site rewrites.
  - If tags/configs are touched: add-only; append with clear AUTO comment.
  - For MCP unification work: prefer “aggregate + delegate” over rewriting existing servers; keep legacy entrypoints intact or make them thin wrappers.

- DELIVERABLES (response format)
  1) PATCHES: apply_patch blocks only (grouped by file)
  2) WORKLOG (short): bullets with what changed + files touched + assumptions + follow-ups
     - Also author the worklog doc per 7.8 under Plugins/<PluginName>/Docs/ (or DevTools docs folder if it’s a DevTools pass)
  3) OPTIONAL: CONTEXT_ANCHOR block (only if it helps memory flow), using the locked template in Section 16.

- DONE CRITERIA
  - Explicit “done” conditions (compile errors eliminated / behavior verified / tests run if any).
  - If the pass is about “single server” MCP:
    - Host config(s) start exactly ONE MCP server entrypoint.
    - Required tool groups are reachable via that single server.
    - Legacy MCP scripts remain intact or are wrappers (no breakage unless Ryan explicitly approves).

Notes:
- This format is considered the default harness for Buddy passes going forward unless Ryan explicitly overrides it.

7.10.1 BUDDY RESPONSE OUTPUT POLICY (Token Guard — default)

Purpose:
- Prevent token waste + “code-dump” replies. Buddy edits the repo; chat replies are concise and navigational.

HARD RULES:
- Buddy MUST NOT paste full source files or large diffs in chat.
- Buddy MUST NOT output apply_patch blocks unless Ryan explicitly requests: “show the patch/diff” or “paste the code”.
- Buddy still uses apply_patch internally for repo edits (per 7.10 constraints); chat output is a summary only.

If Ryan explicitly requests a patch/diff:
- First provide: `git diff --stat` summary (or equivalent).
- Then provide only the smallest relevant hunks needed to answer the request.
- Never dump entire files unless Ryan explicitly asks for a full file.

--- (Update inside 7.10 “DELIVERABLES (response format)” — supersedes prior patch-dump requirement) ---

- DELIVERABLES (response format) (Token Guard; see 7.10.1)
  1) WORKLOG (short): max 3–5 bullets describing what changed + why.
  2) FILES TOUCHED: paths only + 1-line reason each (NEW FILES listed separately).
  3) WORKLOG DOC: confirm the markdown worklog file was created/updated and give its path.
  4) FOLLOW-UPS / KNOWN LIMITS: max 5 bullets.

8. SOTS PLUGIN SUITE STATE & PASS COUNTS (HISTORICAL)
------------------------------------------------------------
8.1 Pass count memory (approximate as of 2025-12-03):
    - These counts are historical context only; they are not hard requirements.

8.2 No spreading partial changes:
    - If a change is done in an experimental branch or zip, do not assume it exists
      in mainline unless Ryan confirms it was merged/tagged.


9. SUCCESS LOG & MOTIVATION
------------------------------------------------------------
9.1 Success probability tracking:
    - Track a running “SOTS Success Log” internally and update when major milestones land.
    - Latest explicit baseline (2025-11-26): ~89% chance of shipping SOTS as envisioned
      after major architectural locks + workflow/tooling stabilization.

9.2 Tone law:
    - Be practical, reliable, forward-moving.
    - Risks should come with paths forward.


10. BLUEPRINTS & RUNTIME SYSTEMS
------------------------------------------------------------
10.1 Blueprints as glue:
    - Use BPs for wiring and content logic; keep heavy systems in plugins where feasible.

10.2 GAS vs custom ability system:
    - SOTS_GAS_Plugin name remains, but it represents a custom player ability system.
    - AI abilities are out of scope for this system.

10.3 Mover system:
    - SOTS does not use UE5 Mover. CharacterMovement + GASP-style motion matching remains the path.


11. SAVE/PROFILE & INVENTORY LAWS
------------------------------------------------------------
11.1 ProfileShared ownership:
    - SOTS_ProfileShared governs profile folders and shared metadata (e.g., gamesettings.sav),
      timestamps, last-selected profile, and “first launch” detection.

11.2 Inventory ownership:
    - InvSP is integrated via SOTS_INV.
    - Inventory persistence is aligned with ProfileShared (per-profile save structure).


12. STEALTH GAMEPLAY LAWS
------------------------------------------------------------
12.1 Dragon as stealth indicator:
    - Dragon is the diegetic stealth meter.
    - Visibility/distortion indicates detection tier/risk.

12.2 Dragon power loop:
    - Player stealth kills/knockouts refill dragon power (tunable).
    - Dragon’s own kills do NOT refill its power bar (encourages player involvement).


13. New DevTools pipelines
------------------------------------------------------------
13.1 DevTools pipeline format:
    - New DevTools pipelines are defined as single code blocks with:
        - A `[SOTS_DEVTOOLS]` header
        - All relevant files for the pipeline
        - A short comment blurb
    - Pipelines are manual-run; Ryan decides when to execute them.


14. PROMPTING & LEGACY PLAN/SPINE PIPELINES
------------------------------------------------------------
14.1 Legacy PLAN/SPINE/BRIDGE/TOOLS/BUNDLE:
    - Useful structure for organizing work, but not mandatory unless Ryan requests it.

14.2 Keep passes coherent:
    - Prefer 1 coherent pass over many tiny micro-passes when possible.


15. Ryan-Handoff Law
------------------------------------------------------------
For long/high-impact sessions, produce a short handoff summary covering:
  - Decisions
  - Changes
  - Pending items
  - Open questions
Proactively suggest a handoff summary when a sweep affects multiple plugins.

15.2 Context Anchor Checkpoint Law
------------------------------------------------------------
Goal:
  Prevent loss of state when long chats exceed the context window.
  Ensure we can safely rotate chats without losing decisions or “what’s next.”

When ChatGPT MUST output a Context Anchor:
  - Immediately after any decision lock of the form: `Lock_<PLUGIN>`
  - After completing any full multi-prompt plan chain (e.g. SOTS_*PLUGIN*_PLAN) or any sweep affecting multiple plugins
  - Any time Ryan explicitly asks for a “context anchor” or “handoff checkpoint”

What a Context Anchor MUST contain (short, copy-pasteable):
  - date/time (local is fine)
  - designated artifact / source-of-truth used for claims
  - locks_added (new decisions locked in this session)
  - passes_planned (what was drafted as future Buddy/DevTools work)
  - passes_confirmed_done (ONLY if verified via BuddyWorklog docs or git logs; never guess)
  - true_unknowns_next (only items not already locked by laws/code)
  - next_actions (1–5 bullets)
  - files_to_open_first (paths or doc pointers)

Format (locked template):
  [CONTEXT_ANCHOR]
  date:
  designated_artifact:
  locks_added:
  passes_planned:
  passes_confirmed_done:
  true_unknowns_next:
  next_actions:
  files_to_open_first:
  [/CONTEXT_ANCHOR]

Storage / workflow rule:
  - Ryan should save each Context Anchor as a small text file via the normal Send2SOTS/DevTools inbox workflow.
  - Recommended filename:
      `SESSION_ANCHOR_<YYYYMMDD_HHMMSS>_<ShortSlug>.md`

Strictness rules:
  - If “done today” / “implemented” is not verified by BuddyWorklog docs or git logs, it must NOT be stated as done.
  - Context Anchors are summaries only; they must not override the artifact priority ladder or the “no silent assumptions” law.


15.2.1 Rolling / Compounding + Timestamp Scope Addendum (2025-12-21)
------------------------------------------------------------
Placement rule:
  - Every Context Anchor MUST be the final thing in the assistant response,
    inside its own single dedicated codeblock (no extra text after it).

Rolling / compounding rule:
  - Each new Context Anchor MUST summarize the last 3 assistant messages.
  - It MUST also merge/compound any prior [CONTEXT_ANCHOR] blocks found within
    those last 3 assistant messages so the anchor compounds forward as a rolling,
    deduped state snapshot.

Contradiction-free dedupe rule:
  - Context Anchors MUST be contradiction-free and deduped.
  - Promote verified items to `passes_confirmed_done` and remove them from
    `passes_planned` / `true_unknowns_next`.
  - Never list the same item in multiple sections.

Timestamp / scope rule:
  - Context Anchors timestamp and track assistant outputs only (not user messages).
  - User requests/constraints should be reflected via `passes_planned`,
    `true_unknowns_next`, and `next_actions` as needed, but do not “log” user
    messages as events.

Doc label hygiene:
  - Avoid using “[CONTEXT_ANCHOR]” as a heading/label in non-anchor docs to prevent confusion.
  - Use `ANCHOR_NOTE` in regular docs when referencing anchor-related content.


15.3 Context Anchor Routing Law

After Ryan saves a SESSION_ANCHOR_*.md file via Send2SOTS/DevTools inbox, DevTools must route it into:

Plugins/<PluginName>/Docs/Anchor/

Plugin inference rule (in order):

any Lock_<PLUGIN> tokens found in the [CONTEXT_ANCHOR] block

an explicit plugin: line (if present)

any Plugins/<PluginName>/... path mentioned in the block

If multiple plugins are detected, the anchor is copied into each plugin’s Docs/Anchor/.

If no plugin is detected, route to: Docs/Anchor/ (project root).

DevTools must print a summary and write a small log (never silent).

16. Python Inspection & Output Law
------------------------------------------------------------
16.1 Map, not dump:
    - Don’t paste entire files into chat. Read silently; surface concise summaries.

16.2 Don’t confuse truncated prints with truncated files:
    - File completeness is inferred from zip contents, sizes, and successful decoding,
      not from any truncated display output.


17. SOTS_*PLUGIN*_BUDDY_PLAN LAWS
------------------------------------------------------------
17.1 SOTS_*PLUGIN*_BUDDY_PLAN trigger:
    - When the user types:

        SOTS_<PluginName>_BUDDY_PLAN <Goal or Short Description>

      you must treat this as a special trigger for a Buddy-focused plan
      targeting that specific plugin (e.g. `SOTS_Parkour_BUDDY_PLAN`,
      `SOTS_KillExecutionManager_BUDDY_PLAN`).

17.2 First response = FULL overview (always):
    - Do NOT jump directly into code or send a Buddy-ready prompt
      immediately.
    - Your first answer to any `SOTS_*PLUGIN*_BUDDY_PLAN` must be an
      exhaustive, multi-part plan for that Buddy pass, including:
        - A short restatement of the goal in your own words.
        - The relevant plugin(s) and likely key files (headers/cpp/Build.cs/
          .uplugin/.ini/etc.), grounded in the session’s designated artifacts
          (see Section 2), not a fixed historical zip.
        - A structured list of numbered Buddy prompts needed to complete
          this pass.

17.3 Plan structure:
    - The overview should naturally break into phases, for example:
        - Phase A – Discovery
        - Phase B – Implementation
        - Phase C – Cleanup & Verification
    - Under each phase, list Buddy prompts like:
        - Prompt 1: Summarize current state of files X/Y.
        - Prompt 2: Add new class Z with these methods.
        - Prompt 3: Refactor function Foo to call Bar, update includes, etc.
    - This list is conceptual; the actual prompt bodies are provided later
      on demand.

17.4 Make each Buddy prompt “nice and palatable”:
    - Assume Buddy is skilled but busy.
    - Each prompt should, when expanded:
        - Focus on one coherent chunk of work.
        - Specify exact file paths, class names, methods, and key
          details.
        - Be copy-pasteable by the user directly into Buddy.
    - Avoid giant omnibus prompts. If a task can be broken into 2–3 clear
      steps, you should split it.

17.5 No full prompt bodies in the overview:
    - In the `SOTS_*PLUGIN*_BUDDY_PLAN` overview, you only give:
        - Titles and short descriptions for each numbered prompt.
    - You do NOT include the full text Buddy should receive yet.
    - After the overview, you only expand a prompt when the user explicitly
      asks for it, e.g.:
        - “Give me Prompt 1 for Buddy.”
        - “Let’s do Prompt 3 now.”

17.6 On request, output a single Buddy prompt:
    - When the user asks for a specific Buddy prompt:
        - Output exactly that prompt’s full body, fully self-contained.
        - Include:
            - Brief context reminder.
            - File paths, class and function names.
            - A numbered list of edits/steps.
            - Any constraints (no builds; delete Binaries/Intermediate after plugin edits).
    - Do not re-list or re-expand other prompts in that response unless the
      user asks for a recap.

17.7 Behavior outside SOTS_*PLUGIN*_BUDDY_PLAN:
    - When the user is NOT invoking `SOTS_*PLUGIN*_BUDDY_PLAN`:
        - Act as Lead Architect normally.
        - Answer questions, review designs, suggest refactors, explain
          trade-offs.
        - You may suggest “this would be good as a SOTS_*PLUGIN*_BUDDY_PLAN”
          if a task is large enough.

17.8 Interaction with DEVTOOLS:
    - `SOTS_*PLUGIN*_BUDDY_PLAN` is primarily for Buddy (manual editing in
      VSCode / repo work).
    - DEVTOOLS passes (with [SOTS_DEVTOOLS] headers) remain valid for
      automation and mass operations, and are run manually by Ryan.
    - You may:
        - Design a `SOTS_*PLUGIN*_BUDDY_PLAN` that includes “Phase A – Discovery”
          steps that *request* DevTools outputs (e.g., run a tag usage report or
          plugin depmap) and then have Buddy proceed using those results.
        - Or design [SOTS_DEVTOOLS] packs separately when requested.
    - Keep the distinction clear:
        - `SOTS_*PLUGIN*_BUDDY_PLAN` = staged human/Buddy coding work on repo files.
        - [SOTS_DEVTOOLS] = Python automation run manually by Ryan.
	- [CONTEXT_ANCHOR] = Something Your Drop Normally Threwout SOTS_*PLUGIN*_BUDDY_PLAN passes

17.9 Code-block + header schema for SOTS_*PLUGIN*_BUDDY_PLAN responses:
    - Every response generated directly in reaction to a `SOTS_*PLUGIN*_BUDDY_PLAN` command
      (both the initial overview and any subsequent individual Buddy prompt body) MUST:
        - Be wrapped in a single fenced code block in the chat (no extra prose outside).
        - Begin with a chatgpt_inbox-style header block appropriate for Buddy work.
    - The Buddy-plan header follows the same schema principles as [SOTS_DEVTOOLS] headers so
      that inbox routing continues to work correctly. The header MUST look like:

        [SOTS_BUDDY_PLAN]
        category: buddy_plan
        plugin: SOTS_<PluginName>
        pass: PLAN
        prompt_index: N
        prompt_total: M
        [/SOTS_BUDDY_PLAN]

      where:
        - `SOTS_<PluginName>` is the concrete plugin name (e.g. `SOTS_Parkour`).
        - `prompt_index` is the 1-based index of the current Buddy prompt or overview.
        - `prompt_total` is the total number of Buddy prompts planned for this PLAN phase.
    - Inside the body text of that single code block you MUST always include a plain line
      stating the X-of-X status for this PLAN phase, for example:
        - `PLAN phase: this is 1 of 4 prompts for this SOTS_Parkour_BUDDY_PLAN.`
    - These requirements apply ONLY to responses directly triggered by a
      `SOTS_*PLUGIN*_BUDDY_PLAN` command. Normal architectural discussion or
      [SOTS_DEVTOOLS] packs may use their own headers (or no headers) as appropriate.


17.10 SOTS_BPGEN SWEEP LAW (SOTS_BPGEN_PLAN) — “VibeUE parity, but native”
------------------------------------------------------------
Purpose:
- Define a dedicated sweep type for Unreal Editor/content-side operations executed through **SOTS_BPGen**.
- SOTS_BPGen is treated as a **1:1 parity surface** to VibeUE-style actions (Blueprint/UMG/EnhancedInput/Materials/Level Actors),
  but **native to the SOTS suite** and callable via our Buddy workflow.
- Use SOTS_BPGEN_PLAN when the work requires Editor-native asset manipulation (not just C++ code edits).

Trigger:
- When Ryan explicitly requests `[SOTS_BPGEN_PLAN]`, start a BPGen sweep prompt pack using the header schema below.

Header schema (single fenced code block; no prose outside when emitting a BPGen pass):
    [SOTS_BPGEN_PLAN]
    category: bpgen_plan
    plugin: <SOTS_BlueprintGen | SOTS_<OtherPlugin> | ProjectContent>
    pass: PLAN | APPLY | VERIFY
    prompt_index: N
    prompt_total: M
    [/SOTS_BPGEN_PLAN]

Mandatory start commands (ALWAYS at the top of PLAN):
- BPGen_HealthCheck (or equivalent “is BPGen loaded + ready” call)
- BPGen_ListActions (or equivalent “help/introspection” call)
  - Treat the returned action list + argument schema as canonical (NO guessing).
- BPGen_ResolveAssetPaths
  - Confirm each target asset path exists (no “maybe this is the path” edits).
- BPGen_OpenAssets
  - Open ONLY the assets that will be touched in this pass.

Phase contract: READ → PLAN → WRITE → VERIFY
PLAN (read-only):
- Inspect current state using BPGen read actions:
  - Blueprint graphs: list events/functions, summarize graph, enumerate nodes near target, read pin types/links
  - UMG: widget tree + bindings + component properties
  - Enhanced Input: mapping contexts/actions + mappings/modifiers/triggers
  - Materials: instances + parameter values + (if needed) material node graph
  - Level Actors: find/spawn/transform queries (READ only in PLAN)
- Output:
  - Exact asset paths to be edited
  - Exact intended edits (what will change)
  - Ordered action list (BPGen action + target + args) to apply
- No mutations in PLAN unless Ryan explicitly says “apply while planning”.

APPLY (mutating):
- Perform minimal, scoped edits only, using BPGen write actions.
- Blueprints (canonical micro-steps):
  - discover/locate_target
  - create_node (prefer stable keys / spawner keys)
  - connect_pins
  - configure_node (defaults, literal values, ref paths, function names)
  - optional: position/layout (only if needed for readability)
- UMG:
  - add_component → set_property → bind_events (explicit bindings, minimal touch)
- Enhanced Input:
  - create/update mapping context in-place with minimal deltas
- Materials:
  - create MI / set scalar/vector/texture params; node edits only if required
- Compile touched Blueprints (allowed) and save ONLY touched assets (no SaveAll).

VERIFY:
- Re-compile/validate touched assets and confirm the expected state exists:
  - Blueprint nodes present + correctly wired + correct defaults
  - UMG bindings present + correct targets
  - Input mappings exist + expected keys/modifiers/triggers
  - Material params updated
  - Level actor changes confirmed (if applicable)
- If any step fails:
  - Stop immediately
  - Report the smallest reproducible failure + last successful BPGen action + the next minimal fix

Safety / invariants (non-negotiable):
- ADD-ONLY discipline:
  - Do not delete nodes/assets/mappings/options or remove features unless Ryan explicitly requests deletion.
- No C++ builds/runs as part of BPGen sweeps.
- Third-party content safety:
  - Do not edit vendor/third-party plugin assets in-place (InvSP/ProHUD/etc.) unless Ryan explicitly approves.
  - Prefer child/adapter assets under SOTS/SAS namespaces.
- No mass rename/move/reparent unless Ryan explicitly approves.
- Always produce a brief worklog entry for the pass (asset list + actions + results).
- If the sweep also touches C++ plugin code in the repo, still obey the per-plugin cleanup law:
  - Delete that plugin’s Binaries/ and Intermediate/ after edits. (No builds.)

Compatibility note:
- If an operation exists in VibeUE but is also present in SOTS_BPGen, **default to SOTS_BPGen**.
- Only fall back to VibeUE tooling if BPGen is missing the required action surface for that specific task.

VIBEUE Lives On Ryans Disk at "E:\SAS\ShadowsAndShurikens\Plugins\VibeUE\" And Should Always Be Refrenced To Buddy When Making Prompts


18. UI HUB / ROUTER LAW (SOTS_UI)
------------------------------------------------------------
UI HUB / ROUTER LAW (SOTS_UI IS THE ONLY UI COMPOSITION ROOT)

18.1 Ownership / Authority
   - SOTS_UI is the single UI HUB / Router for the entire game.
   - SOTS_UI is the ONLY system allowed to:
       - Create widgets (CreateWidget)
       - Add/remove widgets to viewport (AddToViewport, RemoveFromParent)
       - Push/pop/replace screens in the UI stack
       - Set input mode / cursor / focus (SetInputMode*, SetShowMouseCursor, SetUserFocus, etc.)
       - Own Z-order, layers, and stack rules

18.2 Forbidden Pattern (Hard Rule)
   - NO other plugin (CGF legacy widgets, SOTS gameplay plugins, SOTS_INV, InvSP integration code,
     ProHUDV2 usage code, AIBT helpers, etc.) may directly create/push/pop/focus widgets or touch viewport/input mode.
   - If another system needs UI, it must request it through SOTS_UI.

18.3 UI Intents + Payloads (The Only Communication Path)
   - All UI requests must be expressed as:
       - UI Intent (what you want to happen) + Payload (data)
   - Intents are routed through a single SOTS_UI backend entry point:
       - USOTS_UIRouterSubsystem (GameInstanceSubsystem)
   - Payloads are data-only structs (no widget refs, no gameplay ownership), passed as:
       - FInstancedStruct (preferred), or a strict UStruct union.

18.4 Widget Registry (IDs/Tags, never direct widget classes)
   - All widgets/screens/panels are referenced by ID/tag (e.g. SAS.UI.Screen.* / SAS.UI.Modal.* / SAS.UI.HUD.*).
   - SOTS_UI owns a central Widget Registry (UDataAsset type defined in SOTS_UI; asset lives in /Game):
       - WidgetId (GameplayTag)
       - Soft Widget Class
       - Layer (HUD/Overlay/Modal/Debug or tag-equivalent)
       - Input policy (GameOnly / UIOnly / GameAndUI)
       - Pause policy
       - Cache policy (KeepAlive / Recreate)
       - Optional: ZOrder, AllowMultiple, CloseOnEscape, CloseOnFocusLoss, etc.
   - No other plugin may “know” widget classes at compile time.

18.5 Third-Party UI Wrapping Law (ProHUDV2 / InvSP / Interaction Essentials)
   - Third-party UI systems are presentation layers only.
   - They are accessed ONLY via SOTS_UI adapters/presenters owned by SOTS_UI:
       - USOTS_ProHUDAdapter (bridge that is the ONLY place that calls ProHUD interfaces)
       - USOTS_InvSPAdapter  (bridge that is the ONLY place that drives InvSP UI presentation)
       - USOTS_InteractionEssentialsAdapter (bridge that is the ONLY place that drives Interaction Essentials UI)
   - No other plugin may include third-party UI interfaces/structs or call third-party UI directly.

18.6 Data Backends (Already Valid + Remain Authoritative)
   - SOTS_UI continues to own authoritative UI-facing “model” subsystems such as:
       - USOTS_HUDSubsystem (health %, detection level, objective text + delegates)
       - USOTS_NotificationSubsystem (notification list + delegates)
       - USOTS_WaypointSubsystem (waypoint list + delegates)
   - Widgets (including legacy CGF widgets) must:
       - Read UI state from these subsystems
       - Send ALL requests back through USOTS_UIRouterSubsystem (never mutate state from random widgets)

18.7 ProHUDV2 Scope For SOTS (Locked)
   - ProHUDV2 is used ONLY as a visual layer for:
       - Notifications
       - World-space waypoints / markers
   - ProHUDV2 compass/minimap/crosshair systems are not used for SOTS.
   - SOTS_UI emits/consumes SOTS-native data; the ProHUD adapter only translates it to ProHUD calls.

18.8 Implementation Anchor (So We Don’t Rebuild Systems Twice)
   - “Single entry point” in code means:
       - USOTS_UIRouterSubsystem is the only public API other plugins call for UI actions.
   - Existing subsystems remain the data source of truth (HUD/Notifications/Waypoints).
   - Adapters are replaceable without changing gameplay plugins.

18.9 LAW EXCEPTION — DEBUG UI BYPASS (MUST NOT SHIP)
   - Debug-only overlays/widgets may bypass SOTS_UI *only* when:
       - Compiled out for Shipping/Test (e.g., WITH_EDITOR / !(UE_BUILD_SHIPPING || UE_BUILD_TEST))
         AND/OR behind a runtime cvar/config gate that defaults OFF.
   - If there’s any doubt, route the debug UI through SOTS_UI anyway.

18.10
(SOTS_Input owns input routing, SOTS_UI owns input mode/focus).

19. SUITE STATUS SNAPSHOTS (AUDIT LOG)
------------------------------------------------------------
19.1 Purpose:
    - This section stores timestamped “suite status snapshots” (human-written audits).
    - Snapshots are NOT laws; they are historical logs to guide prioritization.

19.2 Snapshot format:
    - Title line with date + label
    - Must-fix-before-ship bullets
    - Scoreboard (0–100%) + notes
    - Next passes (highest leverage)


20. SOURCE MODULE LAW
------------------------------------------------------------
SOTS is a Blueprint-only shell (no /Source game module). All C++ must live in plugins.
No plugin may include/cast/reference any project-level CharacterBase or game-module types;
use components/interfaces/subsystems instead. No plugin Build.cs may depend on the game module.

21. CODE REVIEW STAGE LOCKS (12-16-25)
------------------------------------------------------------
Purpose:
- This section captures the FULL set of “Ryan locked this in” decisions made during the CODE REVIEW STAGE.
- These are BEHAVIOR OWNERSHIP + SEMANTICS locks (code surfaces), NOT runtime verification results.
- Paste this whole section into SOTS_Suite_ExtendedMemory_LAWs.txt just ABOVE the END marker block.


21.1 Stage policy (LOCKED)
- Shipping / shipping-hygiene passes are DEFERRED until we are actually approaching ship (years from now).
- This is a CODE-ONLY review:
  - We are verifying that code surfaces exist + are correct.
  - Runtime behavior verification will be done later by Ryan, plugin-by-plugin.
- DataAssets + config wiring are DEFERRED until the very end (after code is verified across the suite).
- GameplayTags are NOT deferred:
  - For each plugin, ensure all tag paths referenced by that plugin exist in DefaultGameplayTags.ini (ADD-ONLY).
- Even though DA/config wiring is deferred, BEHAVIOR OWNERSHIP decisions must be locked now:
  - who owns what
  - who calls what
  - intended semantics


21.2 SUITE-WIDE behavior ownership (LOCKED)
SUITE-01: Map travel ownership (mission start/end/fail → OpenLevel / seamless travel)
- Locked chain:
  - SOTS_ProfileShared = canonical save/profile authority and snapshot persistence surface
  - SOTS_UI = routes player intents/choices (restart, continue, return to menu, etc.)
  - SOTS_MissionDirector = mission lifecycle owner; applies snapshot → world/map/actors as needed during mission setup
- Note:
  - MissionDirector may require new components on Player/Dragon/Enemies to apply snapshot state.

SUITE-02: “SaveProfile() happens now” decisions
- Locked: Save can occur in 3 ways:
  1) time-based autosaves,
  2) player-initiated saves via SOTS_UI,
  3) checkpoint-based saves at specific mission moments.

SUITE-03: Canonical owner of Input layer push/pop decisions (beyond UI.Nav auto behavior)
- Locked: SOTS_UI owns all UI (and therefore UI-related input-layer policy).

SUITE-04: Canonical FX trigger pattern across the whole suite
- Locked: (A) Everyone calls FXManager one-shots directly (direct FXManager calls).

SUITE-05: Tag authority preference for gating (clarified)
- Locked: TagManager is the canonical authority ONLY for cross-plugin/shared runtime actor-state tags.
  - “Shared runtime actor-state tags” = tags written to Player/Dragon/Guards/Pickups that are intended to be observed/consumed by other plugins to stay decoupled.
  - These boundary tags MUST be written/read via SOTS_TagManager (or SOTS_TagLibrary) so plugins don’t hard-couple to each other.
- Allowed: Internal/local tag usage may remain direct when it is NOT part of a cross-plugin contract:
  - tags used purely inside one plugin’s implementation,
  - private containers that are not treated as shared truth,
  - asset/config metadata tags.

21.3 SUITE CONTRACTS (LOCKED) — CANONICAL (DRIVE THE SUITE FROM THIS)


Purpose
- This section is the “single-read” contract spec for the SOTS plugin suite.
- It is written to drive future passes and prevent ownership drift.
- Questionnaire/answers are historical provenance; THIS is the operational truth.

Stage (CODE REVIEW STAGE)
- We lock: behavior ownership, cross-plugin seams, tag authority rules, and surface semantics.
- We defer: shipping hygiene, DataAssets/config wiring, runtime tuning, content authoring.
- GameplayTags audit is NOT deferred: DefaultGameplayTags.ini is add-only.

Definitions
- “Owner”: the only system that may decide/drive that behavior.
- “Seam”: the minimal public contract other plugins are allowed to use.
- “Intent”: a message/payload request to another owner (no direct coupling to internals).


21.3.0 Suite-wide invariants (apply everywhere)
- Travel chain (authoritative): ProfileShared → SOTS_UI → MissionDirector
- Save triggers (authoritative): autosave/time, UI-initiated save, checkpoint save
- UI ownership: only SOTS_UI can create/push/pop/focus widgets + own input mode/pause/focus
- FX pattern: gameplay systems trigger FX via FXManager one-shots (no UI dependency)
- Tag authority (boundary rule):
  - Cross-plugin runtime actor-state tags (Player/Dragon/Guards/Pickups observed by other plugins) MUST use TagManager.
  - Purely internal/local tags inside one plugin MAY bypass TagManager.
- Cross-plugin tag reads use TagManager union-view (never assume only one source of tags).
- Reward chain (authoritative routing): MissionDirector → SkillTree → Stats → UI (FX listens via events; SkillTree/Stats do not call UI directly)
- Blueprint-only project shell: no plugin assumes a game module or project-level CharacterBase.



21.3.1 SOTS_TagManager — Boundary Tag Authority
OWNER
- Owns: cross-plugin runtime actor-state tags + cross-plugin union-view reads.

SEAMS (public contract)
- GetActorTags (union view): IGameplayTagAssetInterface + TagManager loose tags + scoped tags (ref-counted)
- Reactive events: tag-added/removed (or change) for TagManager-managed tags (BP + C++)
- Scoped loose tags: handle-based, ref-counted, auto-clean on EndPlay

INVARIANTS
- Boundary tags: no bypass (all writes via subsystem/TagLibrary)
- Reads across plugins: always use union-view API


21.3.2 SOTS_ProfileShared — Save Root + Snapshot Governance
OWNER
- Owns: canonical profile folder root + profile metadata storage.

SEAMS
- Snapshot IO: versioned snapshot format + restore path
- Provider priority table: deterministic restore ordering when multiple providers contribute

INVARIANTS
- Profile folder structure is canonical save root (all profile-scoped artifacts live under it)
- Restore transform policy:
  - Always attempt to restore transform
  - If transform missing/unreasonable/corrupt → skip apply + log (no crash, no partial corrupt apply)

AUTHORITY NOTE
- MissionDirector is authoritative for TotalPlaySeconds accumulation; ProfileShared stores/serializes it.


21.3.3 SOTS_Input — Runtime Enhanced Input Spine
OWNER
- Owns: runtime-only Enhanced Input routing spine (gameplay input plumbing)

NOT OWNER
- Does NOT own UI focus / input mode / pause (those belong to SOTS_UI)

SEAMS
- Input device tracking: IsGamepadActive + OnInputDeviceChanged (BP + C++)
- Layer seam: Input.Layer.Dragon.Control exists (v1 seam; gameplay use can expand later)

BUFFER WINDOW CONTRACT (minimal + strict)
- Buffer windows ONLY for: Execution / Vanish / QTE
- Open/close via AnimNotifyState
- Queue size = 1 (latest-wins)
- Auto-clear backstop: clear on montage end/cancel/abort (AnimInstance delegates) to prevent stuck inputs

21.3.3.1 SOTS_Input — CGF_Parkour Integration Contract (LOCKED)

Owner
- SOTS_Input owns the Enhanced Input plumbing and forwarding policy into CGF_Parkour.
- CGF_Parkour remains authoritative for parkour behavior; SOTS_Input only feeds inputs and gates routing.

Parkour feed seam (canonical)
- Forwarding happens in PlayerController.
- The only supported feed mechanism is calling the player ParkourComponent’s AddInput intake API.
- Forwarded inputs:
  - Move axis (Triggered)
  - Look axis (Triggered)
  - Jump (Pressed/Released)
  - Crouch/Drop/Descend (Pressed/Released), treated as the same key while ParkourState != NotBusy
- When UI input mode is active: do not forward any parkour inputs.

Routing/gating while Parkour is active
- BodyDrag start: hard-block.
- Inventory open: hard-block.
- KEM start: NOT hard-blocked.
  - Parkour context is a primary KEM entrypoint (ledge kill execution path) and requires dedicated routing/handling.

Dragon layer routing
- Input.Layer.Dragon.Control is authoritative.
- When dragon control layer is active: never forward parkour inputs.

Buffer-window interaction (Execution/Vanish/QTE)
- During montage buffer windows: parkour input is hard-blocked.
- Transition handling during these windows is done via sequences or motion-warp / move-component calls (with smoke FX), not via live parkour input.

Debug surfaces
- Must expose: active device, active layer, parkour-forwarding enabled, last forwarded IA+value, and block reason.

21.3.4 SOTS_UI — Only UI Router / Stack Owner
OWNER
- Owns: ALL widget create/push/pop/focus, UI stack behavior, UI input mode/pause/focus decisions

SEAMS
- UI intents + payloads are the only allowed request mechanism from other plugins
- Back/Escape policy: closes top UI layer/modal; ReturnToMainMenu uses intent flow (not ad-hoc calls)
- Third-party UI integration: ONLY via SOTS_UI adapters/presenters; widgets addressed via IDs/tags through a registry

ADAPTER MINIMUM SURFACES (locked)
- ProHUDV2 adapter:
  - HUD lifecycle: EnsureHUDCreated (+ optional Show/Hide)
  - Notifications: PushNotification (SOTS-native spec)
  - World markers/waypoints: AddOrUpdate, Remove, optional RemoveAll
  - Legacy calls (HitFeedback/Recoil/SwitchTask/V1_*) only via router
- InvSP adapter:
  - Open/Close/Toggle inventory
  - Shortcut menu visibility
  - Pickup/first-time notifications
  - Router owns input mode/pause (InvSP helper calls are transitional only)
- InteractionEssentials adapter:
  - Wrap IE specifics behind an adapter; router never calls IE nodes directly

UI ↔ Interaction verb short-circuit
- UI may short-circuit canonical Interaction.Verb.* into UI flows (must tolerate missing metadata during bring-up)


21.3.5 SOTS_MissionDirector — Mission Lifecycle + Objectives + Rewards
OWNER
- Owns: mission lifecycle, objective state machine, mission event intake, reward dispatch routing

SEAMS
- Objective intake is event-driven (no per-frame polling requirement)
- Objective types (v1): Kill / NonLethal / Steal / Locate / Sabotage / Interrogate
- Rewards chain routing: MD → SkillTree → Stats → UI (FX listens; MD does not directly “drive UI widgets”)

INVARIANTS
- Travel chain is ProfileShared → UI → MissionDirector; MD is authoritative for mission lifecycle events


21.3.6 SOTS_GlobalStealthManager — Stealth Tier/State Authority
OWNER
- Owns: stealth tier/state evaluation + decay/timers

PRODUCERS (authoritative inputs)
- PlayerStealthComponent is the producer into GSM
- LightProbe feeds PlayerStealthComponent (LightProbe is NOT a GSM producer directly)

OUTPUT MODEL
- “Dragon is stealth meter”: dragon visibility/FX binds to GSM tier/state outputs (no per-system ad-hoc logic)

CADENCE
- Timer/event driven (no tick requirement)
- Producers push updates on change; GSM evaluates/decays on fixed cadence


21.3.7 SOTS_AIPerception — Stimulus Ingest + Reports to GSM
OWNER
- Owns: stimulus ingestion + conversion into detection/suspicion outputs reported into GSM

SEAMS
- Must support report calls for: sight / hearing / damage / noise
  - Include location + instigator when available

INVARIANTS
- Always report suspicion/detection outputs to GSM (not transitions-only)
- Triggers FX via FXManager one-shots (no UI dependency)


21.3.8 SOTS_GAS_Plugin — Tag-Gated Ability Semantics
OWNER
- Owns: ability gating semantics (for the GAS_Plugin scope), using TagManager for boundary reads

SEAMS / RULES
- Tag gating authority: TagManager is authoritative for boundary tag reads
- Owner requirements semantics:
  - RequiredOwner = HasAll
  - BlockedOwner = HasAny
  - Inventory tag gating supports any-of and all-of
- Rank restore is deterministic; no silent partial restore (log if unable to apply)


21.3.9 SOTS_SkillTree — Unlock Authority + Broadcast
OWNER
- Owns: unlock definitions, unlock evaluation, point spend, unlock event broadcast

SEAMS
- Registration timing: register at startup / safehouse / mission init (ready before first unlock opportunity)
- Points model: global points pool (not per-tree pools)
- Unlock identity: hybrid (explicit IDs + tags as identity)
- Tag mirror for cross-plugin visibility uses TagManager
- Unlock broadcast event: FX and UI listen; SkillTree does not call UI directly


21.3.10 SOTS_Stats — Per-Pawn Stats + Snapshot Restore
OWNER
- Owns: stat storage and reconciliation per pawn

SEAMS / RULES
- Separate components per pawn (avoid monolithic “god component”)
- Snapshot authority: snapshots are authoritative for restore
- Live runtime changes must reconcile back to snapshot deterministically (no silent drift)


21.3.11 OmniTrace — Diagnostics Only
OWNER
- Owns: debug/diagnostics utilities

SEAMS
- BP-callable debug draw + stable log category
- No gameplay authority


21.3.12.1 Interaction verb consumers (LOCKED: emitter/subscriber; no cycles)
OWNER / DIRECTION
- SOTS_Interaction is the EMITTER only for canonical action requests.
- Verb consumers SUBSCRIBE and act:
  - SOTS_BodyDrag consumes Interaction.Verb.DragStart / DragStop
  - SOTS_KillExecutionManager consumes Interaction.Verb.Execute

HARD RULES
- Interaction MUST NOT include/call into BodyDrag or KEM (no direct routing; no module/plugin deps).
- Consumers MAY depend on Interaction (one-way) to bind the event and read the payload.
- If a consumer receives incomplete payload data, it must fall back internally (do not force Interaction to hard-couple):
  - KEM may resolve missing ExecutionTag via its own selection/gates and proceed via blessed entrypoints.

TAGMANAGER RELATION (clarification; non-contradicting)
- TagManager remains the boundary authority for shared runtime actor-state tags.
- ActionRequest routing is NOT replaced by TagManager; it is a separate seam used for verb/payload delivery.


21.3.13 SOTS_INV — Inventory Identity + Provider Policy + UI Routing
OWNER
- Owns: canonical inventory identity rules + provider determinism

SEAMS / RULES
- Canonical identity: ItemId == ItemTag name
- Provider authority: BP provider is canonical for item definition data; providers must be deterministic
- InvSP access policy: InvSP is accessed ONLY via SOTS_UI adapters/presenters (no direct UI calls from gameplay systems)
- Inventory UI ownership: SOTS_UI owns open/close + input mode; gameplay systems/components never push/pop widgets or set input mode


21.3.14 SOTS_FX_Plugin — FXManager One-Shot Contract
OWNER
- Owns: FX triggering contract via FXManager

SEAMS / RULES
- Systems trigger FX via FXManager one-shots
- No “persistent FX” without going through FXManager pattern
- Pool overflow: reject + log (throttle if needed); never silently drop
- No UI ownership/dependency (UI may request FX; FX must not require UI)


21.3.15 SOTS_Steam — v1 Narrow Scope
OWNER
- Owns: Steam integration scope for v1

RULE
- Leaderboards first, achievements second (keep scope narrow)


21.3.16 SOTS_Debug — One-Button Debug + Logging
OWNER
- Owns: stable debug log category + one-button debug flow

SEAM
- Triggered via SOTS_Input (no custom side-channels)


21.3.17 LightProbePlugin — Light Sampling Feed Only
OWNER
- Owns: light sampling implementation (not stealth state)

RULES
- Probe cube never casts visible shadows (debug viz must be opt-in and non-gameplay affecting)
- Only feeds PlayerStealthComponent (does not own stealth state)
- Capture policy: on-demand only (no CaptureEveryFrame); timer/capture loop runs only when a valid render target exists


21.3.18 SOTS_UDSBridge — Breadcrumb Feed Contract
OWNER
- Owns: breadcrumb emission contract

RULES
- Breadcrumbs used; defaults: 30 seconds / 30 count
- Consumption chain: AIPerception → AIBT consumes


21.3.19 SOTS_BodyDrag — Player-Only + Flow Ownership
OWNER
- Owns: body drag behavior

RULES
- Player-only; tag-based blocking
- Physics defaults: Dead=true, KO=false
- Flow ownership: Input → Interaction → BodyDrag (no alternate entrypoints)


21.3.20 SOTS_MMSS — Music Resume Rules
OWNER
- Owns: music system resume semantics

RULES
- Respect TrackId when MissionId is None
- Resume uses “close enough” time matching (tolerant), not exact match
- Multi-layer support is later; v1 prioritizes stable/simple behavior


21.3.21 SOTS_EdUtil — Frozen Until Requested
RULE
- Finished; no changes unless Ryan explicitly requests


21.3.22 BlueprintCommentLinks — Explicitly Deferred
RULE
- Skip work until Ryan explicitly asks otherwise


21.3.23 BEP — Export-Only Guardrails
RULES
- No tag reporting in BEP
- Destructive operations require explicit guardrails + confirmation
- Default behavior for changes is add-only patches

21.3.24 SOTS_KillExecutionManager (KEM) — Canonical Behavior Contract
Purpose

KEM is the suite’s authoritative system for executions/takedowns: validating eligibility, selecting the best execution, taking control for the cinematic, resolving final target state, and broadcasting a universal completion signal + structured outcome data for the entire suite.

Ownership

KEM owns

Execution/takedown lifecycle from “attempt” → “resolved”

Target resolution and final-state application

Cinematic camera orchestration for executions

Witness escalation rules (QTE escalation)

Universal completion broadcast + structured outcome payloads

KEM does not own

UI routing or widget management (SOTS_UI owns all UI creation/push/pop/focus)

Stealth tier authority (GSM owns tier/state evaluation)

Entry Points

KEM may start only from:

Interact while controlling the dragon

Interact while controlling the ninja

Cutscene/Sequencer trigger

Start Gates

KEM may only start when the player is fully undetected.

KEM must hard-block start when any of these apply (minimum set):

Player is in a detected tier

Target is alerted

Player is mid-parkour (or otherwise in a movement state that invalidates executions)

Unstable traversal states (ledges/roofs/etc.) that risk execution stability

Any blocking gameplay tags on player/target/execution definition

(Plus any additional tag-based hard blocks you define later — tags are part of the gate)

Control Handoff + Time Behavior

On start, KEM takes full control ownership of player + target until resolved.

KEM supports micro slowmo beats only, driven by Blueprint montage notifies (notify-driven time beats, not global pausing).

Input buffering while KEM is active is restricted to escape/QTE-related inputs only.

Core Rule: Always Finishes + Witness QTE Escalation

Executions and takedowns always fully finish.

If the player is spotted/witnessed during an execution:

A QTE event is triggered immediately.

If the player passes the QTE, they are guaranteed a short escape window.

If the player fails the QTE, they are very shortly killed by the AI.

Eligibility Validation + Target Picking

Eligibility is validated per execution using tracing:

Must pass range

Must pass line of sight

Must pass vertical/horizontal checks per execution (trace-driven constraints)

Boss/elites:

Always eligible under the same eligibility rules (still subject to trace/LOS and tag blocks).

When multiple targets are valid:

Distance always wins

Secondary tie-breaker: the target closest to the player’s camera center (only after distance)

Prompt Policy

Uses a full standard interact prompt when an execution is available.

Execution Selection Pipeline

Execution selection is a 3-stage pipeline:

Best match

Tags

Random among remaining valid options

Selection considers all of these inputs (all are enabled):

Equipped weapon/tool

Lethal vs non-lethal mode

Player stance

Target archetype

Surface context

Entry mode (dragon/ninja/cutscene)

Contextual stealth/suspicion tags used as inputs (even if start is undetected-only)

Lethal vs non-lethal is determined by equipped tool.

Alignment + Movement (Two execution systems supported)

Root motion travel:

Allowed (executions may move/turn/drag/etc.)

Alignment supports two systems, with different warp rules:

CAS executions: both warp to a shared root transform

Spawn-Actor system executions: may warp player-to-target or target-to-player depending on the execution

If alignment fails due to geometry/nav/space constraints:

Try alternate executions/animations, re-validating via tracing each time

If all options are exhausted, the attempt fails to start (no forced clipping start)

Camera Contract (KEEP THIS EXACT INTENT)

Camera style:

Full cinematic cut

Hard requirement:

All executions must support a set of 2 possible camera animation tracks, driven via a Camera Sequence system.

Implementation path is allowed to be either:

A third-party plugin or

A new SOTS plugin (undecided for now)

Camera collision/occlusion:

Standard camera collision rules for v1 (no special “camera wall solver” requirement unless added later)

Outcome Resolution + Final State Model

Target state change is applied at a defined animation notify moment (not “only at montage end”).

Final-state model is broader than Dead/KO and is treated like a state machine:

Alive / Dead / KO / Sleep / Stun / Busy / Waiting / NotAvailable

Outcome support by tool type:

Different item/tool types can produce different subsets of these states
(example: poisons may support multiple outcomes; melee may only support KO/Stun)

Bodies:

Lethal produces a persistent corpse behavior (as the default lethal body outcome).

Post-Execution Flow

Default: return to stealth gameplay immediately after completion.

If witness/QTE escalation occurred:

On QTE pass: guaranteed short escape window

On QTE fail: near-term AI kill (fast fail)

Loot/drop:

KEM triggers the AI’s inventory component to spawn/drop an item on the ragdoll based on the outcome.

UI presentation remains governed by the UI/inventory routing contracts (no direct widget work in KEM).

Suite Broadcast Contract (KEM is a major broadcaster)

On completion, KEM must provide two outputs:

A universal “KEM finished” gameplay-tag signal emitted via TagManager so all systems can bind to one common completion event.

A structured outcome payload (suite-consumable data), at minimum supporting:

MissionDirector: outcome info for objective logic (kill type / non-lethal type / etc.)

Stats: stat/event data

SkillTree: progression data when applicable

FX: one-shot triggers

AIPerception: stimuli emissions when applicable (noise/damage/etc.)

Reward processing timing:

Reward handling may be batched, but completion signaling must be immediate and reliable.

Save/Load + Edge-Case Guardrails

Saving is blocked while KEM is active.

If the target becomes invalid mid-execution (despawn/destroyed/externally removed), KEM resolves via:

Fade to black

Reset player position/state to pre-KEM start

Possession swaps must be made not possible during KEM.

21.3.25 SOTS_BlueprintGen — EXPERIMENTAL / DEFERRED (LOCKED)
- Status: In testing; final behavior/contract is intentionally undefined for now.
- Rule: Do not use, extend, or refactor BlueprintGen unless Ryan explicitly requests it.
- Rationale: Experimental + focus is shipping the game; reduce moving parts.

21.3.26 SOTS_BPGen_Bridge — EXPERIMENTAL / DEFERRED (LOCKED)
- Status: In testing; final behavior/contract is intentionally undefined for now.
- Rule: Do not use, extend, or refactor BPGen_Bridge unless Ryan explicitly requests it.
- Rationale: Experimental + focus is shipping the game; reduce moving parts.

===========================================================================
End of File...
===========================================================================















Why you still here ??? lol :P