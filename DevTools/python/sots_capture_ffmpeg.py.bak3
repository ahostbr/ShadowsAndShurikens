# sots_capture_ffmpeg.py
# SOTS Debug Capture wrapper for Windows + ffmpeg (gdigrab).
#
# UX:
#   - Launch opens an interactive menu (confirm before recording)
#   - When you press 'q' in ffmpeg, the script returns to the menu
#   - While recording, ffmpeg shows progress/stats; we also print "Press Q to stop"
#
# PERSISTENT SETTINGS:
#   - Loads last-used settings from: <script_dir>/SOTS_Capture/settings.json
#   - Auto-saves settings when you apply presets / edit settings / exit (unless disabled)
#
# QUICK PRESETS:
#   - Apply from main menu (hotkeys) or preset menu using "p1", "p2", ... (no conflict with menu numbers)
#   - Preset #1: "CRISP_UI" -> pix_fmt=yuv444p + crf=28 (sharper UI text)
#
# Defaults (if no settings.json and no CLI overrides):
#   - 1 fps
#   - FULL virtual desktop (multi-monitor) at native resolution (no scaling)
#   - mouse cursor included
#   - no audio
#   - saves to: <script_dir>/SOTS_Capture/YYYYMMDD/<auto_filename>.mp4
#   - writes:  <same>.log (the exact ffmpeg command)
#
# Stop capture:
#   - Press 'q' in the ffmpeg window/console, OR use --duration.
#
# ffmpeg location:
#   - First tries your project-local ffmpeg at:
#       DevTools/python/ffmpeg/win64/bin/ffmpeg.exe   (relative to this script)
#   - Then tries a couple other nearby layouts
#   - Finally falls back to PATH (shutil.which("ffmpeg"))
#
# Notes:
#   - Requires Windows.
#   - Some protected/hardware surfaces may not capture correctly with gdigrab.

from __future__ import annotations

import argparse
import datetime as dt
import json
import shlex
import shutil
import subprocess
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import ctypes
from ctypes import wintypes


# -----------------------------
# Win32 helpers (ctypes)
# -----------------------------

user32 = ctypes.WinDLL("user32", use_last_error=True)

SM_XVIRTUALSCREEN = 76
SM_YVIRTUALSCREEN = 77
SM_CXVIRTUALSCREEN = 78
SM_CYVIRTUALSCREEN = 79


def get_virtual_screen_rect() -> Tuple[int, int, int, int]:
    """Returns (x, y, w, h) for the full virtual desktop (all monitors)."""
    x = user32.GetSystemMetrics(SM_XVIRTUALSCREEN)
    y = user32.GetSystemMetrics(SM_YVIRTUALSCREEN)
    w = user32.GetSystemMetrics(SM_CXVIRTUALSCREEN)
    h = user32.GetSystemMetrics(SM_CYVIRTUALSCREEN)
    return int(x), int(y), int(w), int(h)


@dataclass
class MonitorInfo:
    index: int
    device: str
    left: int
    top: int
    right: int
    bottom: int

    @property
    def width(self) -> int:
        return self.right - self.left

    @property
    def height(self) -> int:
        return self.bottom - self.top


class RECT(ctypes.Structure):
    _fields_ = [
        ("left", wintypes.LONG),
        ("top", wintypes.LONG),
        ("right", wintypes.LONG),
        ("bottom", wintypes.LONG),
    ]


class MONITORINFOEXW(ctypes.Structure):
    _fields_ = [
        ("cbSize", wintypes.DWORD),
        ("rcMonitor", RECT),
        ("rcWork", RECT),
        ("dwFlags", wintypes.DWORD),
        ("szDevice", wintypes.WCHAR * 32),
    ]


MONITORENUMPROC = ctypes.WINFUNCTYPE(
    wintypes.BOOL,
    wintypes.HMONITOR,
    wintypes.HDC,
    ctypes.POINTER(RECT),
    wintypes.LPARAM,
)


def get_monitors() -> List[MonitorInfo]:
    monitors: List[MonitorInfo] = []

    def _callback(hMonitor, hdcMonitor, lprcMonitor, dwData):
        info = MONITORINFOEXW()
        info.cbSize = ctypes.sizeof(MONITORINFOEXW)
        if not user32.GetMonitorInfoW(hMonitor, ctypes.byref(info)):
            return True

        rc = info.rcMonitor
        idx = len(monitors)
        monitors.append(
            MonitorInfo(
                index=idx,
                device=str(info.szDevice),
                left=int(rc.left),
                top=int(rc.top),
                right=int(rc.right),
                bottom=int(rc.bottom),
            )
        )
        return True

    cb = MONITORENUMPROC(_callback)
    if not user32.EnumDisplayMonitors(0, 0, cb, 0):
        raise RuntimeError("EnumDisplayMonitors failed")

    return monitors


# -----------------------------
# Config / presets
# -----------------------------

SETTINGS_SCHEMA_VERSION = 1

SCALE_PRESETS: Dict[str, Optional[Tuple[int, int]]] = {
    "none": None,  # default: no scaling, keep native clarity
    "4k": (3840, 2160),
    "2160p": (3840, 2160),
    "1440p": (2560, 1440),
    "1080p": (1920, 1080),
    "720p": (1280, 720),
}

PIX_FMT_PRESETS = ["yuv420p", "yuv444p", "rgb24"]


@dataclass
class CaptureConfig:
    # "profile" is the quick-preset name (NOT the x264 preset)
    profile: str = "DEFAULT"

    mode: str = "virtual"          # virtual|desktop|monitor|window
    fps: float = 1.0
    out: str = ""                  # optional; absolute or relative
    duration: float = 0.0          # 0 => until 'q'
    crf: int = 30
    x264_preset: str = "veryfast"
    draw_mouse: int = 1
    window_title: str = ""
    monitor_index: int = 0
    scale_preset: str = "none"
    scale_w: int = 0
    scale_h: int = 0
    pix_fmt: str = "yuv420p"

    # tool paths (optional)
    ffmpeg_path: str = ""
    ffprobe_path: str = ""

    @staticmethod
    def defaults() -> "CaptureConfig":
        return CaptureConfig()

    def to_dict(self) -> Dict[str, Any]:
        d = asdict(self)
        return {
            "schema_version": SETTINGS_SCHEMA_VERSION,
            "saved_utc": dt.datetime.utcnow().isoformat(timespec="seconds") + "Z",
            "capture": d,
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "CaptureConfig":
        capture = data.get("capture", {})
        cfg = CaptureConfig.defaults()

        for k in asdict(cfg).keys():
            if k in capture:
                setattr(cfg, k, capture[k])

        cfg.mode = str(cfg.mode).lower()
        cfg.scale_preset = str(cfg.scale_preset).lower()
        cfg.pix_fmt = str(cfg.pix_fmt)
        cfg.profile = str(cfg.profile) if cfg.profile else "DEFAULT"
        return cfg


def build_vf(scale_preset: str, scale_w: int, scale_h: int) -> Optional[str]:
    if scale_preset.lower() != "none":
        preset = SCALE_PRESETS.get(scale_preset.lower())
        if preset is None:
            raise ValueError(f"Unknown scale preset: {scale_preset}")
        w, h = preset
        return f"scale={w}:{h}"

    if scale_w > 0 and scale_h > 0:
        return f"scale={scale_w}:{scale_h}"

    return None


def quote_cmd(cmd: List[str]) -> str:
    return " ".join(shlex.quote(c) for c in cmd)


def print_extended_help(parser: argparse.ArgumentParser) -> None:
    print(parser.format_help())
    print(
        "\n"
        "----------------------------------------\n"
        "SOTS_CAPTURE Extended Help (-help)\n"
        "----------------------------------------\n"
        "Menu mode (default):\n"
        "  - Script starts in a menu\n"
        "  - You confirm before recording starts\n"
        "  - When you press 'q' in ffmpeg, you return to the menu\n"
        "\n"
        "Persistent settings:\n"
        "  - Loads/saves last-used settings to:\n"
        "      <script_dir>/SOTS_Capture/settings.json\n"
        "\n"
        "Quick presets hotkeys:\n"
        "  - p1, p2, p3, ... (no conflict with menu numbers)\n"
        "\n"
        "Stop capture:\n"
        "  - Press 'q' in the ffmpeg window/console\n"
        "  - OR set a fixed capture time: --duration 20\n"
    )


def find_local_tool(script_dir: Path, explicit_path: str, exe_name: str) -> Optional[str]:
    if explicit_path:
        p = Path(explicit_path)
        if p.exists():
            return str(p)
        return None

    candidates = [
        script_dir / "ffmpeg" / "win64" / "bin" / exe_name,
        script_dir / "SOTS_Capture" / "ffmpeg" / "win64" / "bin" / exe_name,
        script_dir.parent / "python" / "ffmpeg" / "win64" / "bin" / exe_name,
    ]

    for c in candidates:
        if c.exists():
            return str(c)

    which = shutil.which(Path(exe_name).stem)
    return which


def resolve_output_path(script_dir: Path, out_arg: str, filename_default: str) -> Path:
    day_folder = script_dir / "SOTS_Capture" / dt.datetime.now().strftime("%Y%m%d")
    day_folder.mkdir(parents=True, exist_ok=True)

    if not out_arg:
        return day_folder / filename_default

    p = Path(out_arg)

    if p.is_absolute():
        p.parent.mkdir(parents=True, exist_ok=True)
        return p

    target = day_folder / p
    target.parent.mkdir(parents=True, exist_ok=True)
    return target


def settings_file_path(script_dir: Path, override_path: str = "") -> Path:
    if override_path.strip():
        return Path(override_path)
    return script_dir / "SOTS_Capture" / "settings.json"


def load_settings(script_dir: Path, path_override: str, enabled: bool) -> Optional[CaptureConfig]:
    if not enabled:
        print("[SOTS_CAPTURE] Settings load disabled (--no-load-settings).")
        return None

    p = settings_file_path(script_dir, path_override)
    if not p.exists():
        print(f"[SOTS_CAPTURE] No settings file found (ok): {p}")
        return None

    try:
        data = json.loads(p.read_text(encoding="utf-8"))
        cfg = CaptureConfig.from_dict(data)
        print(f"[SOTS_CAPTURE] Loaded settings: {p}")
        return cfg
    except Exception as e:
        print(f"[SOTS_CAPTURE] WARNING: failed to load settings.json: {p}")
        print(f"[SOTS_CAPTURE] Reason: {e}")
        return None


def save_settings(script_dir: Path, cfg: CaptureConfig, path_override: str, enabled: bool) -> bool:
    if not enabled:
        print("[SOTS_CAPTURE] Settings save disabled (--no-save-settings).")
        return False

    p = settings_file_path(script_dir, path_override)
    p.parent.mkdir(parents=True, exist_ok=True)

    try:
        p.write_text(json.dumps(cfg.to_dict(), indent=2), encoding="utf-8")
        print(f"[SOTS_CAPTURE] Saved settings: {p}")
        return True
    except Exception as e:
        print(f"[SOTS_CAPTURE] WARNING: failed to save settings.json: {p}")
        print(f"[SOTS_CAPTURE] Reason: {e}")
        return False


def yes_no(prompt: str, default: bool = False) -> bool:
    suffix = " [Y/n]: " if default else " [y/N]: "
    while True:
        ans = input(prompt + suffix).strip().lower()
        if not ans:
            return default
        if ans in ("y", "yes"):
            return True
        if ans in ("n", "no"):
            return False
        print("Please enter y or n.")


def pause(msg: str = "Press Enter to continue...") -> None:
    try:
        input(msg)
    except EOFError:
        pass


def safe_int(prompt: str, cur: int, min_v: Optional[int] = None, max_v: Optional[int] = None) -> int:
    while True:
        s = input(f"{prompt} (current: {cur}) > ").strip()
        if s == "":
            return cur
        try:
            v = int(s)
        except ValueError:
            print("Enter a valid integer (or blank to keep current).")
            continue
        if min_v is not None and v < min_v:
            print(f"Must be >= {min_v}")
            continue
        if max_v is not None and v > max_v:
            print(f"Must be <= {max_v}")
            continue
        return v


def safe_float(prompt: str, cur: float, min_v: Optional[float] = None, max_v: Optional[float] = None) -> float:
    while True:
        s = input(f"{prompt} (current: {cur}) > ").strip()
        if s == "":
            return cur
        try:
            v = float(s)
        except ValueError:
            print("Enter a valid number (or blank to keep current).")
            continue
        if min_v is not None and v < min_v:
            print(f"Must be >= {min_v}")
            continue
        if max_v is not None and v > max_v:
            print(f"Must be <= {max_v}")
            continue
        return v


def safe_str(prompt: str, cur: str, allow_blank_keep: bool = True) -> str:
    s = input(f"{prompt} (current: {cur}) > ").strip()
    if s == "" and allow_blank_keep:
        return cur
    return s


def print_config_summary(cfg: CaptureConfig, script_dir: Path) -> None:
    day_folder = script_dir / "SOTS_Capture" / dt.datetime.now().strftime("%Y%m%d")

    print("\n==============================")
    print("SOTS_CAPTURE Current Settings")
    print("==============================")
    print(f"profile      : {cfg.profile}")
    print(f"mode         : {cfg.mode}")
    print(f"fps          : {cfg.fps}")
    print(f"duration     : {cfg.duration}  (0 = until 'q')")
    print(f"draw_mouse   : {cfg.draw_mouse}")
    print(f"crf          : {cfg.crf}")
    print(f"x264_preset  : {cfg.x264_preset}")
    print(f"pix_fmt      : {cfg.pix_fmt}")
    print(f"scale_preset : {cfg.scale_preset}")
    print(f"scale_w/h    : {cfg.scale_w} x {cfg.scale_h}")
    print(f"monitor_index: {cfg.monitor_index}")
    print(f"window_title : {cfg.window_title}")
    print(f"out          : {cfg.out if cfg.out else '(auto)'}")
    print(f"save folder  : {day_folder}")
    print("==============================\n")


# -----------------------------
# Quick Presets (Profiles)
# -----------------------------

@dataclass
class Profile:
    key: str          # "p1", "p2", ...
    name: str
    desc: str

    mode: Optional[str] = None
    fps: Optional[float] = None
    scale_preset: Optional[str] = None
    scale_w: Optional[int] = None
    scale_h: Optional[int] = None
    pix_fmt: Optional[str] = None
    crf: Optional[int] = None
    x264_preset: Optional[str] = None
    draw_mouse: Optional[int] = None
    window_title: Optional[str] = None
    monitor_index: Optional[int] = None


PROFILES: List[Profile] = [
    Profile(
        key="p1",
        name="CRISP_UI",
        desc="1fps full virtual; sharp UI text (pix_fmt=yuv444p, crf=28).",
        mode="virtual",
        fps=1.0,
        pix_fmt="yuv444p",
        crf=28,
        x264_preset="veryfast",
        scale_preset="none",
    ),
    Profile(
        key="p2",
        name="TINY_FILE",
        desc="1fps full virtual; small file (1080p downscale, yuv420p, crf=32).",
        mode="virtual",
        fps=1.0,
        scale_preset="1080p",
        pix_fmt="yuv420p",
        crf=32,
        x264_preset="veryfast",
    ),
    Profile(
        key="p3",
        name="FAST_SCAN",
        desc="2fps full virtual; medium size (1080p downscale, yuv420p, crf=30).",
        mode="virtual",
        fps=2.0,
        scale_preset="1080p",
        pix_fmt="yuv420p",
        crf=30,
        x264_preset="veryfast",
    ),
    Profile(
        key="p4",
        name="UE_WINDOW_CRISP",
        desc='1fps window capture "Unreal Editor" (sharp UI text, yuv444p, crf=28).',
        mode="window",
        fps=1.0,
        window_title="Unreal Editor",
        pix_fmt="yuv444p",
        crf=28,
        x264_preset="veryfast",
        scale_preset="none",
    ),
    Profile(
        key="p5",
        name="PRIMARY_ONLY",
        desc="1fps primary desktop only (no downscale).",
        mode="desktop",
        fps=1.0,
        pix_fmt="yuv420p",
        crf=30,
        x264_preset="veryfast",
        scale_preset="none",
    ),
]


def apply_profile(cfg: CaptureConfig, prof: Profile) -> None:
    cfg.profile = prof.name

    if prof.mode is not None:
        cfg.mode = prof.mode
    if prof.fps is not None:
        cfg.fps = float(prof.fps)
    if prof.scale_preset is not None:
        cfg.scale_preset = str(prof.scale_preset).lower()
        cfg.scale_w = 0
        cfg.scale_h = 0
    if prof.scale_w is not None:
        cfg.scale_w = int(prof.scale_w)
    if prof.scale_h is not None:
        cfg.scale_h = int(prof.scale_h)
    if prof.pix_fmt is not None:
        cfg.pix_fmt = str(prof.pix_fmt)
    if prof.crf is not None:
        cfg.crf = int(prof.crf)
    if prof.x264_preset is not None:
        cfg.x264_preset = str(prof.x264_preset)
    if prof.draw_mouse is not None:
        cfg.draw_mouse = int(prof.draw_mouse)
    if prof.window_title is not None:
        cfg.window_title = str(prof.window_title)
    if prof.monitor_index is not None:
        cfg.monitor_index = int(prof.monitor_index)


# -----------------------------
# ffmpeg command construction
# -----------------------------

def build_ffmpeg_cmd(
    ffmpeg: str,
    cfg: CaptureConfig,
    script_dir: Path,
) -> Tuple[List[str], Path, Path]:
    ts = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    filename_default = f"SOTS_capture_{cfg.mode}_{cfg.fps}fps_{ts}.mp4"
    out_path = resolve_output_path(script_dir, cfg.out, filename_default)
    log_path = out_path.with_suffix(".log")

    vf = build_vf(cfg.scale_preset, cfg.scale_w, cfg.scale_h)

    cmd: List[str] = [
        ffmpeg,
        "-y",
        "-f",
        "gdigrab",
        "-framerate",
        str(cfg.fps),
        "-draw_mouse",
        str(cfg.draw_mouse),
        "-stats",
    ]

    if cfg.mode == "virtual":
        vx, vy, vw, vh = get_virtual_screen_rect()
        cmd += [
            "-offset_x",
            str(vx),
            "-offset_y",
            str(vy),
            "-video_size",
            f"{vw}x{vh}",
            "-i",
            "desktop",
        ]
    elif cfg.mode == "desktop":
        cmd += ["-i", "desktop"]
    elif cfg.mode == "monitor":
        mons = get_monitors()
        if cfg.monitor_index < 0 or cfg.monitor_index >= len(mons):
            raise ValueError(f"monitor_index out of range (0..{len(mons)-1})")
        m = mons[cfg.monitor_index]
        cmd += [
            "-offset_x",
            str(m.left),
            "-offset_y",
            str(m.top),
            "-video_size",
            f"{m.width}x{m.height}",
            "-i",
            "desktop",
        ]
    elif cfg.mode == "window":
        if not cfg.window_title.strip():
            raise ValueError("window_title is required for mode=window")
        cmd += ["-i", f"title={cfg.window_title}"]
    else:
        raise ValueError(f"Unknown mode: {cfg.mode}")

    if cfg.duration and cfg.duration > 0:
        cmd += ["-t", str(cfg.duration)]

    if vf:
        cmd += ["-vf", vf]

    cmd += [
        "-c:v",
        "libx264",
        "-preset",
        cfg.x264_preset,
        "-crf",
        str(cfg.crf),
        "-pix_fmt",
        str(cfg.pix_fmt),
        "-movflags",
        "+faststart",
        str(out_path),
    ]

    return cmd, out_path, log_path


def run_recording(ffmpeg: str, cfg: CaptureConfig, script_dir: Path) -> int:
    cmd, out_path, log_path = build_ffmpeg_cmd(ffmpeg, cfg, script_dir)
    printable = quote_cmd(cmd)

    log_path.write_text(printable + "\n", encoding="utf-8")

    print("\n[SOTS_CAPTURE] ========================================")
    print(f"[SOTS_CAPTURE] Saving folder: {out_path.parent}")
    print(f"[SOTS_CAPTURE] Writing:       {out_path}")
    print(f"[SOTS_CAPTURE] Log:           {log_path}")
    print(f"[SOTS_CAPTURE] Cmd:           {printable}")
    print("[SOTS_CAPTURE] ========================================")
    print("\n[SOTS_CAPTURE] RECORDING...")
    print("[SOTS_CAPTURE] Press 'q' in the ffmpeg window/console to stop.")
    print("[SOTS_CAPTURE] (After stop, you'll return to this menu.)\n")

    try:
        proc = subprocess.Popen(cmd)
        rc = proc.wait()
    except KeyboardInterrupt:
        print("\n[SOTS_CAPTURE] KeyboardInterrupt received. Stopping ffmpeg...")
        try:
            proc.terminate()  # type: ignore[name-defined]
        except Exception:
            pass
        rc = 130

    print(f"\n[SOTS_CAPTURE] ffmpeg exit code: {rc}")
    if rc == 0:
        print(f"[SOTS_CAPTURE] Saved: {out_path}")
    else:
        print("[SOTS_CAPTURE] Recording may be incomplete. Check console/log.")
    return int(rc)


# -----------------------------
# Menu UI
# -----------------------------

def edit_settings_menu(cfg: CaptureConfig, script_dir: Path) -> None:
    while True:
        print_config_summary(cfg, script_dir)
        print("Edit Settings")
        print("  1) mode (virtual/desktop/monitor/window)")
        print("  2) fps")
        print("  3) duration (0 = until 'q')")
        print("  4) output name/path (blank = auto)")
        print("  5) quality (crf/x264_preset/pix_fmt)")
        print("  6) target details (monitor_index/window_title)")
        print("  7) scaling (preset or custom)")
        print("  8) draw_mouse (0/1)")
        print("  B) back to main menu")
        choice = input("> ").strip().lower()

        if choice == "b":
            return

        if choice == "1":
            print("\nSelect mode:")
            print("  1) virtual (ALL monitors)")
            print("  2) desktop (primary only)")
            print("  3) monitor (single monitor by index)")
            print("  4) window (by title)")
            sel = input("> ").strip()
            if sel == "1":
                cfg.mode = "virtual"
            elif sel == "2":
                cfg.mode = "desktop"
            elif sel == "3":
                cfg.mode = "monitor"
            elif sel == "4":
                cfg.mode = "window"
            else:
                print("Invalid selection.")
                continue
            cfg.profile = "CUSTOM"

        elif choice == "2":
            cfg.fps = safe_float("fps", cfg.fps, min_v=0.1, max_v=60.0)
            cfg.profile = "CUSTOM"

        elif choice == "3":
            cfg.duration = safe_float("duration seconds (0=until q)", cfg.duration, min_v=0.0)
            cfg.profile = "CUSTOM"

        elif choice == "4":
            new_out = input(f"out (current: {cfg.out if cfg.out else '(auto)'}) > ").strip()
            cfg.out = new_out
            cfg.profile = "CUSTOM"

        elif choice == "5":
            cfg.crf = safe_int("crf (higher=smaller, lower=better)", cfg.crf, min_v=0, max_v=51)
            cfg.x264_preset = safe_str("x264_preset (ultrafast..veryslow)", cfg.x264_preset)

            print("\nPixel format presets:")
            for i, pf in enumerate(PIX_FMT_PRESETS, start=1):
                print(f"  {i}) {pf}")
            sel = input(f"pix_fmt (current: {cfg.pix_fmt}) [1-{len(PIX_FMT_PRESETS)} or blank to keep] > ").strip()
            if sel:
                try:
                    idx = int(sel) - 1
                    if 0 <= idx < len(PIX_FMT_PRESETS):
                        cfg.pix_fmt = PIX_FMT_PRESETS[idx]
                except ValueError:
                    print("Invalid pix_fmt selection.")
            cfg.profile = "CUSTOM"

        elif choice == "6":
            if cfg.mode == "monitor":
                cfg.monitor_index = safe_int("monitor_index", cfg.monitor_index, min_v=0)
                cfg.profile = "CUSTOM"
            elif cfg.mode == "window":
                cfg.window_title = safe_str("window_title", cfg.window_title, allow_blank_keep=False)
                cfg.profile = "CUSTOM"
            else:
                print("Current mode is not monitor/window.")
                pause()

        elif choice == "7":
            print("\nScaling:")
            print("  1) preset")
            print("  2) custom")
            print("  3) clear (none)")
            sel = input("> ").strip()
            if sel == "1":
                keys = list(SCALE_PRESETS.keys())
                for i, k in enumerate(keys, start=1):
                    print(f"  {i}) {k}")
                pick = input(f"Select preset (current: {cfg.scale_preset}) > ").strip()
                try:
                    idx = int(pick) - 1
                    if 0 <= idx < len(keys):
                        cfg.scale_preset = keys[idx]
                        cfg.scale_w = 0
                        cfg.scale_h = 0
                        cfg.profile = "CUSTOM"
                except ValueError:
                    print("Invalid preset.")
            elif sel == "2":
                cfg.scale_preset = "none"
                cfg.scale_w = safe_int("scale_w", cfg.scale_w, min_v=0)
                cfg.scale_h = safe_int("scale_h", cfg.scale_h, min_v=0)
                cfg.profile = "CUSTOM"
            elif sel == "3":
                cfg.scale_preset = "none"
                cfg.scale_w = 0
                cfg.scale_h = 0
                cfg.profile = "CUSTOM"
            else:
                print("Invalid selection.")

        elif choice == "8":
            cfg.draw_mouse = safe_int("draw_mouse (0/1)", cfg.draw_mouse, min_v=0, max_v=1)
            cfg.profile = "CUSTOM"

        else:
            print("Unknown option.")


def list_monitors_ui() -> None:
    mons = get_monitors()
    print("\n[SOTS_CAPTURE] Monitors:")
    for m in mons:
        print(
            f"  [{m.index}] {m.device} rect=({m.left},{m.top})-({m.right},{m.bottom}) "
            f"size={m.width}x{m.height}"
        )
    vx, vy, vw, vh = get_virtual_screen_rect()
    print(f"[SOTS_CAPTURE] VirtualScreen rect=({vx},{vy}) size={vw}x{vh}\n")
    pause()


def presets_menu(cfg: CaptureConfig) -> None:
    print("\nQuick Presets (type p1/p2/...)")
    for prof in PROFILES:
        print(f"  {prof.key}) {prof.name} - {prof.desc}")
    print("  B) back")

    choice = input("> ").strip().lower()
    if choice == "b":
        return

    for prof in PROFILES:
        if choice == prof.key:
            apply_profile(cfg, prof)
            print(f"[SOTS_CAPTURE] Applied preset: {prof.name}")
            pause()
            return

    print("Unknown preset.")
    pause()


def main_menu_loop(
    ffmpeg: str,
    cfg: CaptureConfig,
    script_dir: Path,
    ap: argparse.ArgumentParser,
    settings_path_override: str,
    enable_save: bool,
) -> int:
    while True:
        print_config_summary(cfg, script_dir)

        print("Main Menu")
        print("  1) Start recording (uses current settings)")
        print("  2) Edit settings")
        print("  3) Show ffmpeg command (preview)")
        print("  4) List monitors")
        print("  5) Presets (menu)")
        print("  S) Save settings now")
        print("  R) Reset to defaults")
        print("  H) Show help (-help)")
        print("  Q) Quit")

        print("\nQuick preset hotkeys:")
        print("  p1=CRISP_UI  p2=TINY_FILE  p3=FAST_SCAN  p4=UE_WINDOW_CRISP  p5=PRIMARY_ONLY")
        choice = input("> ").strip().lower()

        # Preset hotkeys: p1/p2/... (no conflict with menu numbers)
        applied = False
        for prof in PROFILES:
            if choice == prof.key:
                apply_profile(cfg, prof)
                save_settings(script_dir, cfg, settings_path_override, enable_save)
                applied = True
                break
        if applied:
            continue

        if choice == "q":
            save_settings(script_dir, cfg, settings_path_override, enable_save)
            print("[SOTS_CAPTURE] Bye.")
            return 0

        if choice == "1":
            if not yes_no("Start recording now?", default=True):
                continue
            try:
                rc = run_recording(ffmpeg, cfg, script_dir)
            except ValueError as e:
                print(f"[SOTS_CAPTURE] ERROR: {e}")
                pause()
                continue

            save_settings(script_dir, cfg, settings_path_override, enable_save)
            pause("Press Enter to return to menu...")
            continue

        if choice == "2":
            edit_settings_menu(cfg, script_dir)
            save_settings(script_dir, cfg, settings_path_override, enable_save)
            continue

        if choice == "3":
            try:
                cmd, out_path, log_path = build_ffmpeg_cmd(ffmpeg, cfg, script_dir)
                print("\n[SOTS_CAPTURE] Command preview:")
                print(quote_cmd(cmd))
                print(f"\n[SOTS_CAPTURE] Would write: {out_path}")
                print(f"[SOTS_CAPTURE] Would log:   {log_path}\n")
            except ValueError as e:
                print(f"[SOTS_CAPTURE] ERROR: {e}")
            pause()
            continue

        if choice == "4":
            list_monitors_ui()
            continue

        if choice == "5":
            presets_menu(cfg)
            save_settings(script_dir, cfg, settings_path_override, enable_save)
            continue

        if choice == "s":
            save_settings(script_dir, cfg, settings_path_override, enable_save)
            pause()
            continue

        if choice == "r":
            if yes_no("Reset ALL settings to defaults?", default=False):
                cfg2 = CaptureConfig.defaults()
                cfg.__dict__.update(cfg2.__dict__)
                save_settings(script_dir, cfg, settings_path_override, enable_save)
            continue

        if choice == "h":
            print_extended_help(ap)
            pause()
            continue

        print("Unknown option.")


# -----------------------------
# Entry
# -----------------------------

def main() -> int:
    ap = argparse.ArgumentParser(description="SOTS Debug Capture (ffmpeg + gdigrab, Windows)")

    ap.add_argument(
        "-help",
        dest="help_long",
        action="store_true",
        help="Show extended help (examples + troubleshooting) and exit.",
    )

    ap.add_argument(
        "--auto",
        action="store_true",
        help="Start recording immediately (skip menu + confirmation).",
    )

    ap.add_argument(
        "--settings-path",
        default="",
        help="Optional override path for settings.json (default: <script_dir>/SOTS_Capture/settings.json).",
    )
    ap.add_argument(
        "--no-load-settings",
        action="store_true",
        help="Do not load settings.json at startup.",
    )
    ap.add_argument(
        "--no-save-settings",
        action="store_true",
        help="Do not save settings.json (no persistence).",
    )

    ap.add_argument(
        "--mode",
        choices=["virtual", "desktop", "monitor", "window"],
        default="virtual",
        help="Capture target. virtual=all monitors (default). desktop=primary. monitor=single monitor rect. window=by title.",
    )
    ap.add_argument("--fps", type=float, default=1.0, help="Capture framerate (default 1 fps)")
    ap.add_argument("--out", default="", help="Output mp4 path (see -help)")
    ap.add_argument("--duration", type=float, default=0.0, help="Optional duration in seconds (0 = until q)")
    ap.add_argument("--crf", type=int, default=30, help="x264 CRF (higher=smaller, lower=better). Default 30")
    ap.add_argument("--preset", default="veryfast", help="x264 preset (ultrafast..veryslow). Default veryfast")
    ap.add_argument("--draw-mouse", type=int, default=1, choices=[0, 1], help="Include mouse cursor (default 1)")
    ap.add_argument("--window-title", default="", help='For --mode window, example: "Unreal Editor"')
    ap.add_argument("--monitor-index", type=int, default=0, help="For --mode monitor, index from --list-monitors")
    ap.add_argument("--scale-preset", default="none", choices=list(SCALE_PRESETS.keys()), help="Optional downscale preset")
    ap.add_argument("--scale-w", type=int, default=0, help="Optional custom scale width (requires --scale-h)")
    ap.add_argument("--scale-h", type=int, default=0, help="Optional custom scale height (requires --scale-w)")
    ap.add_argument("--pix-fmt", default="yuv420p", help="Output pixel format (default yuv420p). Try yuv444p.")
    ap.add_argument("--list-monitors", action="store_true", help="Print monitor list and exit")
    ap.add_argument("--ffmpeg-path", default="", help="Optional explicit path to ffmpeg.exe.")
    ap.add_argument("--ffprobe-path", default="", help="Optional explicit path to ffprobe.exe.")

    args = ap.parse_args()

    if args.help_long:
        print_extended_help(ap)
        return 0

    script_dir = Path(__file__).resolve().parent

    ffmpeg = find_local_tool(script_dir, args.ffmpeg_path, "ffmpeg.exe")
    if not ffmpeg:
        print("[SOTS_CAPTURE] ERROR: ffmpeg not found.")
        print("[SOTS_CAPTURE] Tip: run:  python sots_capture_ffmpeg.py -help")
        return 2

    if args.list_monitors:
        list_monitors_ui()
        return 0

    enable_load = not args.no_load_settings
    enable_save = not args.no_save_settings

    loaded = load_settings(script_dir, args.settings_path, enabled=enable_load)
    cfg = loaded if loaded is not None else CaptureConfig.defaults()

    # CLI overrides
    cfg.mode = str(args.mode).lower()
    cfg.fps = float(args.fps)
    cfg.out = str(args.out)
    cfg.duration = float(args.duration)
    cfg.crf = int(args.crf)
    cfg.x264_preset = str(args.preset)
    cfg.draw_mouse = int(args.draw_mouse)
    cfg.window_title = str(args.window_title)
    cfg.monitor_index = int(args.monitor_index)
    cfg.scale_preset = str(args.scale_preset).lower()
    cfg.scale_w = int(args.scale_w)
    cfg.scale_h = int(args.scale_h)
    cfg.pix_fmt = str(args.pix_fmt)

    if args.auto:
        rc = run_recording(ffmpeg, cfg, script_dir)
        save_settings(script_dir, cfg, args.settings_path, enabled=enable_save)
        return rc

    rc = main_menu_loop(
        ffmpeg=ffmpeg,
        cfg=cfg,
        script_dir=script_dir,
        ap=ap,
        settings_path_override=args.settings_path,
        enable_save=enable_save,
    )
    return rc


if __name__ == "__main__":
    raise SystemExit(main())
