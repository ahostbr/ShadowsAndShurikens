Alright, here’s a full set of ready-to-paste prompts for VSCodeBuddy, one per major bucket. You can drop them into Buddy exactly as-is and run them one by one.

PROMPT 1 – Detection Tree + OmniTrace Parity

Goal: Expand SOTS_ParkourComponent’s detection so it mirrors CGF_Parkour’s full probe tree (mantle, vault, drop, tic-tac, ledge move, hops, etc.) using OmniTrace as the backend, with trace sizes/offsets matching the CGF exports.

Context & Sources

Use the CGF Blueprint exports as the reference:

E:\SAS\ShadowsAndShurikens\BlueprintExports\CGF_PARKOUR_ONLY\ParkourComponent_Readable.txt

…\ABP_SandboxCharacterParkour_Readable.txt

Any other files in that folder that show trace logic (tic-tac, ledge move, etc.).

Target plugin code:

Plugins/SOTS_Parkour/Source/SOTS_Parkour/Private/SOTS_ParkourComponent.cpp

Plugins/SOTS_Parkour/Source/SOTS_Parkour/Public/SOTS_ParkourComponent.h

Any small helper types already defined for probe settings (structs/enums).

What to implement

Map out CGF’s trace tree

From ParkourComponent_Readable.txt, identify:

First capsule trace (already mostly mirrored).

Second capsule trace.

Vault-specific traces.

Tic-tac traces.

Ledge move / side move / corner move / air-hang / back-hop / predictive jump traces.

For each, note:

Start location, direction vector, length, radius/half-height.

Any offsets/adjustments for “falling vs grounded”, or climb state.

Design C++ helpers

In SOTS_ParkourComponent, add private helper methods for each conceptual probe, for example (names are suggestions, adapt to your existing naming):

BuildFirstCapsuleTrace(...)

BuildSecondCapsuleTrace(...)

BuildVaultSurfaceTrace(...)

BuildTicTacTrace(...)

BuildLedgeMoveTrace(...)

BuildCornerMoveTrace(...)

BuildPredictiveJumpTrace(...)

Each helper should:

Compute the correct start/end and shapes with the same math as CGF.

Package it into OmniTrace’s request type (whatever your canonical SOTS trace struct is).

Prefer to centralize “magic numbers” into config/struct fields if possible.

Integrate with OmniTrace

Where CGF fires a trace in BP, SOTS must:

Use the helper to build an OmniTrace request.

Call your OmniTrace API to execute it.

Make sure all traces use the same collision channels that CGF used (from the BP exports).

Hook into classification

Update the classification logic so that:

Mantle / Vault / Drop / TicTac / LedgeMove / CornerMove / etc. are chosen based on the results of the expanded probe set.

You don’t just run one or two traces and guess; it should follow the branching logic observed in ParkourComponent_Readable.txt.

Where BP used select nodes or branch chains based on multiple trace results, replicate that decision tree in C++.

Config surface

Expose tunable values that were “magic numbers” in CGF (distances, heights, radii) as:

Component properties, or

USOTS_ParkourSettings defaults.

Comment each one with which CGF node/section it mirrors.

Definition of Done

For a given input situation (e.g., approaching a waist-high obstacle, full-height ledge, tic-tac wall), SOTS_Parkour should pick the same high-level action CGF would: mantle vs vault vs tic-tac vs ledge move, etc.

All relevant traces are done via OmniTrace but preserve CGF math (distances, offsets, sizes).

The detection logic is readable, with clear helper functions and no duplicated magic numbers.

PROMPT 2 – State Machine, Tags & Replication

Goal: Expand SOTS_Parkour’s runtime state machine to match CGF_Parkour’s behavior (states, transitions, tick updates, ledge offsets), and bridge it properly into your global gameplay tag spine, including any needed replication.

Context & Sources

Reference:

BlueprintExports\CGF_PARKOUR_ONLY\ParkourComponent_Readable.txt

Any state/enum/tag usage visible in that file (e.g., NotBusy, Climb, Vault, TicTac, CornerMove, etc.).

Target:

SOTS_ParkourComponent.h/.cpp

SOTS TagManager plugin (for global tag usage, not to be modified here, but to align with its tag style).

What to implement

Identify CGF states & transitions

From the BP export, list:

All parkour states (NotBusy, Entering, Climb, Vault, Mantle, TicTac, CornerMove, BeamHidden, etc.).

How they transition (conditions for entering/exiting).

Any per-tick behaviors (e.g., maintaining ledge offset, checking auto-climb, timers).

Extend SOTS enums / state structs

If you currently have a minimal enum for states:

Add the missing entries seen in CGF.

If you already planned a tag-based state system:

Keep the enum for internal C++ clarity, but make sure each state has a corresponding GameplayTag mapping (e.g., Parkour.State.Climb).

Implement a proper tick-based state machine

In TickComponent, or a dedicated UpdateStateMachine(DeltaTime):

Handle the full state graph transitions:

Idle → Entering (when an action is detected).

Entering → Active.

Active → Exiting.

Exiting → Idle (NotBusy).

Special cases like TicTac, CornerMove, BeamHidden should also have clear enter/exit paths.

Implement per-state update logic:

Maintain any ledge offsets.

Respect “first climb move” or “only once per ledge” logic.

Auto-climb gates and timers if CGF had them.

Tag bridge

Add a thin bridge so that whenever the state changes:

SOTS_Parkour can update one or more gameplay tags (via TagManager or your existing helper).

Example: Parkour.State.NotBusy, Parkour.State.Climb, Parkour.State.Vault.

Do the same (or prepare for) Action/Direction/ClimbStyle tags:

Parkour.Action.Mantle, Parkour.Direction.Forward, Parkour.ClimbStyle.High, etc.

Make sure the tag mapping is one place (e.g., small helper or mapping table).

Replication

Identify which state changes in CGF implied networked behavior (corner moves, big transitions).

For SOTS_Parkour:

Implement Server_ and Multicast_ RPCs where appropriate for state or movement that must be seen by other clients.

Ensure the server is authoritative for traces and classification.

Keep it clean and future-proof (even if SOTS stays SP, don’t preclude MP).

Definition of Done

State transitions and behaviors in SOTS_Parkour match CGF’s logic as closely as possible.

Gameplay tags reflect parkour state/action/direction/climb style in a consistent, centralized way.

Replication is set up for any actions that would logically need it (based on CGF behavior), with server doing the authoritative classification.

PROMPT 3 – OutParkour Loader + ActionSet Integration

Goal: Integrate the exported OutParkour data (JSON/DataTable) into USOTS_ParkourActionSet so that classification picks the correct action row and uses its montage, play rate, and warp windows.

Context & Sources

Reference data:

BlueprintExports\CGF_PARKOUR_ONLY\OutParkour_Readable.txt

BlueprintExports\CGF_PARKOUR_ONLY\OutParkour_Readable.json

Target code:

USOTS_ParkourActionSet and any related structs (ActionData, WarpWindow, etc.) in the SOTS_Parkour plugin.

SOTS_ParkourComponent where actions are chosen.

What to implement

Understand OutParkour schema

From the JSON export, identify:

The keys/fields for:

Action name / identifier.

Montage asset path/name.

Play rate, start time/section.

Warp windows: start/end times, offsets, rotation/facing flags, reversed rotation, height adjustment.

Map these fields to your existing SOTS structs:

If necessary, add missing fields to FSOTS_ParkourActionData and FSOTS_ParkourWarpWindow.

Implement a loader

Create a loader that:

Reads the OutParkour JSON (or a DataTable that’s already imported from it).

Populates a USOTS_ParkourActionSet instance with all rows.

Design options:

Load at editor time and bake into an asset.

Or load at runtime from a known JSON file path.

Keep it simple and robust, with logging if a row is malformed.

Classification → action data

In SOTS_ParkourComponent (where you classify detection as mantle/vault/drop/etc.):

Once you know the type (and potentially sub-type: height, side, direction):

Query the USOTS_ParkourActionSet for the appropriate action row.

Copy the action data into a runtime structure:

Montage reference, play rate, start/loop sections.

Warp windows.

Montage hook

Ensure there is a clear execution path from:

Classified action → chosen FSOTS_ParkourActionData → PlayMontageUsingActionData(...) style function.

That function should:

Start the montage at the correct time/section.

Use the play rate from the data.

Trigger registration of warp windows (next prompt).

Definition of Done

There is a clear, working pipeline:

OutParkour JSON → USOTS_ParkourActionSet → runtime selection in SOTS_ParkourComponent.

All key CGF OutParkour fields are represented in the SOTS structs.

Mantle/vault/drop/tic-tac actions in SOTS now use data-driven definitions instead of hard-coded values.

PROMPT 4 – MotionWarp Windows & Root-Motion Modifiers

Goal: Achieve motion warp parity with CGF: multiple warp windows per action, correct offsets/rotations, and hooks for root-motion modifiers like SkewWarp.

Context & Sources

Reference:

OutParkour JSON (warp window definitions).

Any CGF nodes related to Motion Warp / Motion Warping / SkewWarp in:

ParkourComponent_Readable.txt

OutParkour_Readable.txt

Target:

FSOTS_ParkourWarpWindow / FSOTS_ParkourWarpRuntimeTarget

SOTS_ParkourComponent motion-warp setup code.

What to implement

Warp window representation

Confirm FSOTS_ParkourWarpWindow has:

Start time, end time.

Offset / position mode.

Rotation/facing mode.

Flags for reversed rotation, height adjustment, etc.

If anything is missing compared to OutParkour, extend the struct.

Runtime warp targets

For each warp window in the chosen action:

Compute a FSOTS_ParkourWarpRuntimeTarget:

Position: based on ledge location, player capsule, and OutParkour offsets.

Rotation: apply facing mode and reversed rotation flag.

Height adjustments: apply where indicated by the data.

Register these targets with the MotionWarping component in the same way CGF did:

Multiple named windows per action if needed.

Integration with montage play

When playing the action montage:

Register all relevant warp windows before or at the correct window start times.

Ensure the names/tags you use match the expectations of any animation notifies or curves.

Root-motion modifiers (SkewWarp)

If CGF used a SkewWarp or similar node:

Add a small C++ helper or configuration that can apply similar adjustments.

The key outcome:

Character aligns naturally with the ledge and doesn’t foot-slide or drift unrealistically.

Definition of Done

For actions like mantle / vault / tic-tac:

The character’s root motion is visibly warped toward the same ledge/target positions CGF would use.

Multiple warp windows per montage are supported.

Core parameters (facing, offsets, reversed rotation, height adjustment) behave like the CGF Blueprint version.

PROMPT 5 – Anim / IK Interfaces + Notifies Wiring

Goal: Wire SOTS_Parkour into the ABP interfaces and notifies so that IK, retargeting, and state display match CGF_Parkour behavior.

Context & Sources

Reference:

ParkourABPInterface_Readable.txt

ParkourInterface_Readable.txt

ReachLedgeIK_Readable.txt

OutParkour_Readable.txt

ABP_ParkourGenericRetarget_Readable.txt

Target:

Any interface types in SOTS related to parkour.

SOTS_ParkourComponent.

Any existing notify handlers or delegates.

What to implement

Interface calls from SOTS_Parkour

When parkour state/action/climb style changes:

Call into the AnimBP interface (or a C++/BP bridge) with:

Current state.

Current action.

Current climb style.

Make sure these values map directly to what the ABP expects, as seen in the exports.

If there are functions to set:

Hand/foot ledge transforms.

Climb movement vectors.

IK flags.

Implement them and call them at the right points in the parkour flow.

ReachLedgeIK notify integration

From ReachLedgeIK_Readable.txt, identify:

Which hand is being driven.

What flags it toggles (e.g., Left/Right Climb IK, First/Second IK).

In SOTS:

Implement a way for the notify to call back into the parkour component (or vice versa) to:

Turn IK on/off for each hand at begin/end of the notify.

Fetch the correct ledge transform so the IK target is accurate.

OutParkour notify integration

From OutParkour_Readable.txt, confirm its behavior:

Typically it resets parkour state/action to NotBusy/NoAction when the montage finishes.

Implement matching behavior:

Ensure when this notify fires:

SOTS_Parkour resets to the correct idle state.

Tags and interfaces are updated accordingly.

ABP data expectations

In ABP_ParkourGenericRetarget_Readable.txt, check:

What data is being read (states, curves, offsets, IK toggles).

Make sure those data points have a clear source:

Either from SOTS_ParkourComponent, global tags, or ABP-side variables that are set by the interface.

Definition of Done

When a parkour action plays:

The ABP receives correct state/action/style updates.

ReachLedgeIK notifies toggle IK behavior properly, with ledge transforms provided by SOTS_Parkour.

OutParkour notifies return the system cleanly to NotBusy.

IK and retarget behavior in SOTS looks and behaves like it did in CGF.

PROMPT 6 – UI/Debug Stats + Mirror Helper

Goal: Restore CGF-style parkour stats UI and add a mirror helper library based on NewMirrorDataTable, so that debugging and side-mirroring are easy and data-driven.

Context & Sources

Reference:

ParkourStats_Readable.txt

ParkourStatsWidget_Interface_Readable.txt

NewMirrorDataTable.json

Target:

SOTS_Parkour plugin + (if needed) SOTS_UI plugin.

A small mirror library or helper in SOTS_Parkour.

What to implement

Parkour stats UI bridge

Look at the stats widget interface in the exports:

Methods like Set State/Action/ClimbStyle.

Decide where this belongs in SOTS:

Either keep it as a widget-level interface, or

Route it through SOTS_UI.

Implement a simple bridge so:

SOTS_Parkour pushes current state/action/climb style to the stats widget when they change.

The widget displays them for debug purposes.

Mirror helper from NewMirrorDataTable

Parse NewMirrorDataTable.json:

It’s a large mapping of bone L↔R.

Implement a helper (e.g., USOTS_ParkourMirrorLibrary) that:

Exposes functions like GetMirroredBoneName(FName Bone) or returns both sides.

Optionally caches the mapping for fast lookup.

If any retarget or IK code needs to know left vs right:

Make it use this library instead of hard-coded names.

Definition of Done

There is an easy way to see parkour state/action/style in-game via a debug widget.

A mirror helper exists, backed by the data from NewMirrorDataTable.json, and can be used by any system that needs left/right bone pairing.

If you want, I can next compress these into a single “meta prompt” that tells Buddy: “run PROMPT 1–6 in order as part of Parkour V3 parity” so they’re grouped as one codex for the V3 pass.
