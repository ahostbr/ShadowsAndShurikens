ChatGPT inbox file
Label: chatgpt_code_block
URL: https://chatgpt.com/g/g-p-692a52e132d48191884b9f1868e99825-sots-cgf-5-7-overhaul/c/69305e4b-2aec-832f-9efb-243f72da899a
Type: code_block
# SOTS_BlueprintGen SPINE 3
# Goal: Turn struct/enum creation into REAL builder logic.
# - Implement CreateStructAssetFromDef and CreateEnumAssetFromDef using UE asset APIs.
# - Keep function skeleton + graph spec application as stubs for a later SPINE.
# This pack ONLY writes files; no automatic runs.

[SOTS_DEVTOOLS]
tool: write_files
[/SOTS_DEVTOOLS]

=== FILE: Plugins/SOTS_BlueprintGen/Source/SOTS_BlueprintGen/SOTS_BlueprintGen.Build.cs ===
using UnrealBuildTool;

public class SOTS_BlueprintGen : ModuleRules
{
    public SOTS_BlueprintGen(ReadOnlyTargetRules Target) : base(Target)
    {
        Type = ModuleType.Editor;
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "Core",
                "CoreUObject",
                "Engine",
                "UnrealEd",
                "Kismet",
                "BlueprintGraph",
                "KismetCompiler",
                "Kismet2",
                "AssetTools",
                "EditorSubsystem",
                "EditorFramework",
                "Json",
                "JsonUtilities",
                "UserDefinedStructure",
                "Slate",
                "SlateCore",
                "InputCore"
            }
        );

        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                "Projects",
                "ApplicationCore",
                "PropertyEditor",
                "ToolMenus",
                "EditorStyle",
                "AssetRegistry"
            }
        );

        // Additional modules (e.g. commandlets) will be added in later SPINE passes.
    }
}
=== END FILE ===

=== FILE: Plugins/SOTS_BlueprintGen/Source/SOTS_BlueprintGen/Private/SOTS_BPGenBuilder.cpp ===
#include "SOTS_BPGenBuilder.h"
#include "SOTS_BlueprintGen.h"

#include "AssetToolsModule.h"
#include "Kismet2/StructureEditorUtils.h"
#include "Engine/UserDefinedStruct.h"
#include "Engine/UserDefinedEnum.h"
#include "UObject/Package.h"
#include "UObject/SavePackage.h"
#include "Misc/PackageName.h"
#include "EdGraph/EdGraphPin.h"
#include "AssetRegistry/AssetRegistryModule.h"

namespace
{
	static FString GetNormalizedPackageName(const FString& InAssetPath)
	{
		FString Result = InAssetPath;
		Result.TrimStartAndEndInline();
		return Result;
	}

	static FName GetSafeObjectName(const FName& InName, const FString& AssetPath)
	{
		if (!InName.IsNone())
		{
			return InName;
		}

		FString DummyLeft, Right;
		if (AssetPath.Split(TEXT("/"), &DummyLeft, &Right, ESearchCase::IgnoreCase, ESearchDir::FromEnd))
		{
			return FName(*Right);
		}

		return FName(TEXT("SOTS_BPGenObject"));
	}

	static void FillPinTypeFromBPGen(const FSOTS_BPGenPin& InPin, FEdGraphPinType& OutType)
	{
		OutType.ResetToDefaults();

		OutType.PinCategory = InPin.Category;
		OutType.PinSubCategory = InPin.SubCategory;
		OutType.PinSubCategoryObject = nullptr;

		if (!InPin.SubObjectPath.IsEmpty())
		{
			if (UObject* LoadedObj = LoadObject<UObject>(nullptr, *InPin.SubObjectPath))
			{
				OutType.PinSubCategoryObject = LoadedObj;
			}
		}

		switch (InPin.ContainerType)
		{
		case ESOTS_BPGenContainerType::Array:
			OutType.ContainerType = EPinContainerType::Array;
			break;
		case ESOTS_BPGenContainerType::Set:
			OutType.ContainerType = EPinContainerType::Set;
			break;
		case ESOTS_BPGenContainerType::Map:
			OutType.ContainerType = EPinContainerType::Map;
			break;
		default:
			OutType.ContainerType = EPinContainerType::None;
			break;
		}
	}
}

FSOTS_BPGenAssetResult USOTS_BPGenBuilder::CreateStructAssetFromDef(
	const UObject* WorldContextObject,
	const FSOTS_BPGenStructDef& StructDef)
{
	FSOTS_BPGenAssetResult Result;
	Result.AssetPath = StructDef.AssetPath;

	if (StructDef.AssetPath.IsEmpty())
	{
		Result.bSuccess = false;
		Result.Message = TEXT("StructDef.AssetPath is empty.");
		UE_LOG(LogSOTS_BlueprintGen, Error, TEXT("CreateStructAssetFromDef failed: AssetPath is empty."));
		return Result;
	}

	const FString PackageName = GetNormalizedPackageName(StructDef.AssetPath);
	const FName StructName = GetSafeObjectName(StructDef.StructName, PackageName);

	UPackage* Package = CreatePackage(*PackageName);
	if (!Package)
	{
		Result.bSuccess = false;
		Result.Message = FString::Printf(TEXT("Failed to create or load package '%s'."), *PackageName);
		UE_LOG(LogSOTS_BlueprintGen, Error, TEXT("%s"), *Result.Message);
		return Result;
	}

	UUserDefinedStruct* TargetStruct = FindObject<UUserDefinedStruct>(Package, *StructName.ToString());
	if (!TargetStruct)
	{
		TargetStruct = FStructureEditorUtils::CreateUserDefinedStruct(
			Package,
			StructName,
			RF_Public | RF_Standalone | RF_Transactional);

		if (!TargetStruct)
		{
			Result.bSuccess = false;
			Result.Message = FString::Printf(TEXT("Failed to create user-defined struct '%s'."), *StructName.ToString());
			UE_LOG(LogSOTS_BlueprintGen, Error, TEXT("%s"), *Result.Message);
			return Result;
		}
	}
	else
	{
		UE_LOG(LogSOTS_BlueprintGen, Log,
			TEXT("CreateStructAssetFromDef: Updating existing struct '%s' in package '%s'."),
			*StructName.ToString(), *PackageName);
	}

	TArray<FStructVariableDescription>& VarDescs = FStructureEditorUtils::GetVarDesc(TargetStruct);
	VarDescs.Reset();

	for (const FSOTS_BPGenPin& MemberPin : StructDef.Members)
	{
		FStructVariableDescription NewVar;
		NewVar.VarGuid = FGuid::NewGuid();
		NewVar.VarName = MemberPin.Name.IsNone() ? FName(TEXT("Member")) : MemberPin.Name;
		NewVar.FriendlyName = NewVar.VarName.ToString();
		FillPinTypeFromBPGen(MemberPin, NewVar.VarType);

		VarDescs.Add(MoveTemp(NewVar));
	}

	FStructureEditorUtils::OnStructureChanged(TargetStruct);

	FAssetRegistryModule::AssetCreated(TargetStruct);
	Package->MarkPackageDirty();

	const FString FileName = FPackageName::LongPackageNameToFilename(PackageName, FPackageName::GetAssetPackageExtension());

	FSavePackageArgs SaveArgs;
	SaveArgs.TopLevelFlags = RF_Public | RF_Standalone;
	SaveArgs.Error = GError;
	SaveArgs.bWarnOfLongFilename = false;

	if (!UPackage::SavePackage(Package, TargetStruct, *FileName, SaveArgs))
	{
		Result.bSuccess = false;
		Result.Message = FString::Printf(TEXT("Failed to save struct package '%s'."), *FileName);
		UE_LOG(LogSOTS_BlueprintGen, Error, TEXT("%s"), *Result.Message);
		return Result;
	}

	Result.bSuccess = true;
	Result.Message = FString::Printf(TEXT("Struct '%s' created/updated at '%s'."), *StructName.ToString(), *PackageName);
	return Result;
}

FSOTS_BPGenAssetResult USOTS_BPGenBuilder::CreateEnumAssetFromDef(
	const UObject* WorldContextObject,
	const FSOTS_BPGenEnumDef& EnumDef)
{
	FSOTS_BPGenAssetResult Result;
	Result.AssetPath = EnumDef.AssetPath;

	if (EnumDef.AssetPath.IsEmpty())
	{
		Result.bSuccess = false;
		Result.Message = TEXT("EnumDef.AssetPath is empty.");
		UE_LOG(LogSOTS_BlueprintGen, Error, TEXT("CreateEnumAssetFromDef failed: AssetPath is empty."));
		return Result;
	}

	const FString PackageName = GetNormalizedPackageName(EnumDef.AssetPath);
	const FName EnumName = GetSafeObjectName(EnumDef.EnumName, PackageName);

	UPackage* Package = CreatePackage(*PackageName);
	if (!Package)
	{
		Result.bSuccess = false;
		Result.Message = FString::Printf(TEXT("Failed to create or load package '%s'."), *PackageName);
		UE_LOG(LogSOTS_BlueprintGen, Error, TEXT("%s"), *Result.Message);
		return Result;
	}

	UUserDefinedEnum* TargetEnum = FindObject<UUserDefinedEnum>(Package, *EnumName.ToString());
	if (!TargetEnum)
	{
		TargetEnum = NewObject<UUserDefinedEnum>(
			Package,
			EnumName,
			RF_Public | RF_Standalone | RF_Transactional);

		if (!TargetEnum)
		{
			Result.bSuccess = false;
			Result.Message = FString::Printf(TEXT("Failed to create user-defined enum '%s'."), *EnumName.ToString());
			UE_LOG(LogSOTS_BlueprintGen, Error, TEXT("%s"), *Result.Message);
			return Result;
		}
	}
	else
	{
		UE_LOG(LogSOTS_BlueprintGen, Log,
			TEXT("CreateEnumAssetFromDef: Updating existing enum '%s' in package '%s'."),
			*EnumName.ToString(), *PackageName);
	}

	TArray<TPair<FName, int64>> EnumNames;
	for (int32 Index = 0; Index < EnumDef.Values.Num(); ++Index)
	{
		const FString& EntryString = EnumDef.Values[Index];
		const FName EntryName = FName(*EntryString);

		EnumNames.Add(TPair<FName, int64>(EntryName, Index));
	}

	TargetEnum->SetEnums(EnumNames, UUserDefinedEnum::ECppForm::Regular);
	TargetEnum->MarkPackageDirty();

	FAssetRegistryModule::AssetCreated(TargetEnum);
	Package->MarkPackageDirty();

	const FString FileName = FPackageName::LongPackageNameToFilename(PackageName, FPackageName::GetAssetPackageExtension());

	FSavePackageArgs SaveArgs;
	SaveArgs.TopLevelFlags = RF_Public | RF_Standalone;
	SaveArgs.Error = GError;
	SaveArgs.bWarnOfLongFilename = false;

	if (!UPackage::SavePackage(Package, TargetEnum, *FileName, SaveArgs))
	{
		Result.bSuccess = false;
		Result.Message = FString::Printf(TEXT("Failed to save enum package '%s'."), *FileName);
		UE_LOG(LogSOTS_BlueprintGen, Error, TEXT("%s"), *Result.Message);
		return Result;
	}

	Result.bSuccess = true;
	Result.Message = FString::Printf(TEXT("Enum '%s' created/updated at '%s'."), *EnumName.ToString(), *PackageName);
	return Result;
}

FSOTS_BPGenApplyResult USOTS_BPGenBuilder::ApplyFunctionSkeleton(
	const UObject* WorldContextObject,
	const FSOTS_BPGenFunctionDef& FunctionDef)
{
	FSOTS_BPGenApplyResult Result;
	Result.TargetBlueprintPath = FunctionDef.TargetBlueprintPath;
	Result.FunctionName = FunctionDef.FunctionName;

	UE_LOG(LogSOTS_BlueprintGen, Warning,
		TEXT("ApplyFunctionSkeleton (SPINE 3 stub) called for Blueprint '%s', Function '%s'"),
		*FunctionDef.TargetBlueprintPath,
		*FunctionDef.FunctionName.ToString());

	Result.bSuccess = false;
	Result.ErrorMessage = TEXT("ApplyFunctionSkeleton is not implemented yet (SPINE 3 stub).");
	return Result;
}

FSOTS_BPGenApplyResult USOTS_BPGenBuilder::ApplyGraphSpecToFunction(
	const UObject* WorldContextObject,
	const FSOTS_BPGenFunctionDef& FunctionDef,
	const FSOTS_BPGenGraphSpec& GraphSpec)
{
	FSOTS_BPGenApplyResult Result;
	Result.TargetBlueprintPath = FunctionDef.TargetBlueprintPath;
	Result.FunctionName = FunctionDef.FunctionName;

	UE_LOG(LogSOTS_BlueprintGen, Warning,
		TEXT("ApplyGraphSpecToFunction (SPINE 3 stub) called for Blueprint '%s', Function '%s' with %d nodes / %d links"),
		*FunctionDef.TargetBlueprintPath,
		*FunctionDef.FunctionName.ToString(),
		GraphSpec.Nodes.Num(),
		GraphSpec.Links.Num());

	Result.bSuccess = false;
	Result.ErrorMessage = TEXT("ApplyGraphSpecToFunction is not implemented yet (SPINE 3 stub).");
	return Result;
}
=== END FILE ===
