ChatGPT inbox file
Label: chatgpt_code_block
URL: https://chatgpt.com/g/g-p-692a52e132d48191884b9f1868e99825-sots-cgf-5-7-overhaul/c/693033da-92e4-8330-aa6e-d876788863e1
Type: code_block
# SOTS DevTools – SOTS_Parkour SPINE 1
# ------------------------------------
# Goal:
#   - Establish the SOTS_Parkour plugin’s SPINE 1 baseline:
#       * Core enums + FSOTS_ParkourResult struct.
#       * Minimal USOTS_ParkourComponent skeleton with high-level
#         entry/exit flow, owner caching, and simple gating.
#   - No detection, traces, OmniTrace, or movement logic yet.
#   - Safe to compile and expose to Blueprints as a read-only parkour
#     state/result surface and entry/cancel API.
#
# Usage:
#   - Save this whole block to a .txt file under DevTools/chatgpt_inbox.
#   - Run:
#       python DevTools/python/write_files.py --source PATH_TO_FILE.txt
#   - Files will be written under Plugins/SOTS_Parkour/...

[SOTS_DEVTOOLS]
tool: write_files
category: plugin_spine
plugin: SOTS_Parkour
pass: SPINE_1
description: "SOTS_Parkour SPINE 1 – enums, result struct, and ActorComponent skeleton (no detection/OmniTrace yet)."
[/SOTS_DEVTOOLS]

=== FILE: Plugins/SOTS_Parkour/SOTS_Parkour.uplugin ===
{
  "FileVersion": 3,
  "Version": 1,
  "VersionName": "1.0.0",
  "FriendlyName": "SOTS Parkour",
  "Description": "Core parkour spine for Shadows And Shurikens. Provides a dedicated parkour ActorComponent that will evolve from the original CGF ParkourComponent.",
  "Category": "SOTS",
  "CreatedBy": "Kuroryuu Dev",
  "CreatedByURL": "",
  "DocsURL": "",
  "MarketplaceURL": "",
  "SupportURL": "",
  "CanContainContent": false,
  "IsBetaVersion": true,
  "IsExperimentalVersion": false,
  "Installed": false,
  "EnabledByDefault": true,
  "EngineVersion": "5.7.0",
  "Modules": [
    {
      "Name": "SOTS_Parkour",
      "Type": "Runtime",
      "LoadingPhase": "Default"
    }
  ]
}

=== END FILE ===

=== FILE: Plugins/SOTS_Parkour/Source/SOTS_Parkour/SOTS_Parkour.Build.cs ===
// SOTS_Parkour.Build.cs
// Runtime module for the SOTS Parkour plugin (SPINE 1 skeleton).

using UnrealBuildTool;

public class SOTS_Parkour : ModuleRules
{
    public SOTS_Parkour(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "Core",
                "CoreUObject",
                "Engine"
            }
        );

        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
            }
        );
    }
}

=== END FILE ===

=== FILE: Plugins/SOTS_Parkour/Source/SOTS_Parkour/Public/SOTS_ParkourTypes.h ===
// SOTS_ParkourTypes.h
// Core enums and result struct for SOTS parkour (SPINE 1 baseline).

#pragma once

#include "CoreMinimal.h"
#include "Engine/EngineTypes.h"
#include "SOTS_ParkourTypes.generated.h"

/** High-level state of the parkour component. */
UENUM(BlueprintType)
enum class ESOTS_ParkourState : uint8
{
    Idle        UMETA(DisplayName = "Idle"),
    Entering    UMETA(DisplayName = "Entering"),
    Active      UMETA(DisplayName = "Active"),
    Exiting     UMETA(DisplayName = "Exiting")
};

/** Style of climbing the player is currently using. */
UENUM(BlueprintType)
enum class ESOTS_ClimbStyle : uint8
{
    None        UMETA(DisplayName = "None"),
    FreeHang    UMETA(DisplayName = "Free Hang"),
    Braced      UMETA(DisplayName = "Braced")
};

/** The type of parkour action selected from the detection/classification step. */
UENUM(BlueprintType)
enum class ESOTS_ParkourAction : uint8
{
    None            UMETA(DisplayName = "None"),
    Mantle          UMETA(DisplayName = "Mantle"),
    Vault           UMETA(DisplayName = "Vault"),
    LedgeMove       UMETA(DisplayName = "Ledge Move"),
    Drop            UMETA(DisplayName = "Drop"),
    TicTac          UMETA(DisplayName = "Tic Tac"),
    BackHop         UMETA(DisplayName = "Back Hop"),
    PredictJump     UMETA(DisplayName = "Predictive Jump"),
    AirHang         UMETA(DisplayName = "Air Hang")
};

/**
 * Unified result container for a single parkour opportunity evaluation.
 * Later passes will mirror the full CGF result family inside this struct.
 */
USTRUCT(BlueprintType)
struct SOTS_PARKOUR_API FSOTS_ParkourResult
{
    GENERATED_BODY()

public:
    /** Whether this result contains a valid parkour opportunity. */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    bool bHasResult = false;

    /** The chosen parkour action (mantle, vault, tic-tac, etc). */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    ESOTS_ParkourAction Action = ESOTS_ParkourAction::None;

    /** The climbing style (e.g. free hang vs braced). */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    ESOTS_ClimbStyle ClimbStyle = ESOTS_ClimbStyle::None;

    /** Representative world-space location for this result (e.g. ledge point). */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    FVector WorldLocation = FVector::ZeroVector;

    /** Representative world-space normal (e.g. wall or ledge normal). */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    FVector WorldNormal = FVector::UpVector;

    /** Raw hit information used to derive this result (first/primary hit). */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    FHitResult Hit;

    FSOTS_ParkourResult() = default;

    /** Reset all fields to a clean, invalid state. */
    void Reset()
    {
        bHasResult   = false;
        Action       = ESOTS_ParkourAction::None;
        ClimbStyle   = ESOTS_ClimbStyle::None;
        WorldLocation = FVector::ZeroVector;
        WorldNormal   = FVector::UpVector;
        Hit           = FHitResult();
    }
};

=== END FILE ===

=== FILE: Plugins/SOTS_Parkour/Source/SOTS_Parkour/Public/SOTS_ParkourComponent.h ===
// SOTS_ParkourComponent.h
// SPINE 1: Skeleton ActorComponent for SOTS parkour, with high-level
// entry/exit flow and owner caching. Detection, traces, and movement
// will be added in later passes.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "SOTS_ParkourTypes.h"
#include "SOTS_ParkourComponent.generated.h"

class ACharacter;
class UCharacterMovementComponent;

UCLASS(ClassGroup = (SOTS), meta = (BlueprintSpawnableComponent))
class SOTS_PARKOUR_API USOTS_ParkourComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    USOTS_ParkourComponent();

protected:
    virtual void BeginPlay() override;

public:
    /** Returns true if the parkour system considers itself currently active. */
    UFUNCTION(BlueprintPure, Category = "SOTS|Parkour")
    bool IsParkourActive() const { return ParkourState == ESOTS_ParkourState::Active; }

    /** Current high-level parkour state (idle, entering, active, exiting). */
    UFUNCTION(BlueprintPure, Category = "SOTS|Parkour")
    ESOTS_ParkourState GetParkourState() const { return ParkourState; }

    /** Current climb style (free hang vs braced). */
    UFUNCTION(BlueprintPure, Category = "SOTS|Parkour")
    ESOTS_ClimbStyle GetCurrentClimbStyle() const { return CurrentClimbStyle; }

    /** Current parkour action (mantle, vault, tic-tac, etc). */
    UFUNCTION(BlueprintPure, Category = "SOTS|Parkour")
    ESOTS_ParkourAction GetCurrentAction() const { return CurrentAction; }

    /** Last computed parkour result from a detection pass. */
    UFUNCTION(BlueprintPure, Category = "SOTS|Parkour")
    const FSOTS_ParkourResult& GetLastResult() const { return LastResult; }

    /**
     * Request that parkour begin.
     *
     * In SPINE 1 this only drives high-level state transitions (Idle → Entering).
     * Later passes will perform detection, fill LastResult, and move the
     * character or reject the attempt.
     */
    UFUNCTION(BlueprintCallable, Category = "SOTS|Parkour")
    void RequestParkour();

    /**
     * Cancel/stop parkour for the owning actor.
     *
     * In SPINE 1 this simply resets state and clears the last result. Later passes
     * will add proper transition handling (e.g., exit animations).
     */
    UFUNCTION(BlueprintCallable, Category = "SOTS|Parkour")
    void CancelParkour();

protected:
    /** High-level state of the parkour system for this actor. */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    ESOTS_ParkourState ParkourState = ESOTS_ParkourState::Idle;

    /** Climb style currently selected (mapped from CGF logic in later passes). */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    ESOTS_ClimbStyle CurrentClimbStyle = ESOTS_ClimbStyle::None;

    /** The parkour action chosen by the last successful classification. */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    ESOTS_ParkourAction CurrentAction = ESOTS_ParkourAction::None;

    /** Unified result container for the last parkour opportunity evaluation. */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "SOTS|Parkour")
    FSOTS_ParkourResult LastResult;

    /** Cached owning character (if the owner is a character). */
    UPROPERTY(Transient)
    TWeakObjectPtr<ACharacter> CachedCharacter;

    /** Cached movement component from the owning character (if available). */
    UPROPERTY(Transient)
    UCharacterMovementComponent* CachedMovementComponent = nullptr;

    /** Simple internal helper: can the owner currently attempt parkour at all? */
    bool CanAttemptParkourInternal() const;
};

=== END FILE ===

=== FILE: Plugins/SOTS_Parkour/Source/SOTS_Parkour/Private/SOTS_ParkourComponent.cpp ===
// SOTS_ParkourComponent.cpp
// SPINE 1: Minimal implementation with high-level entry/exit flow,
// owner caching, and simple gating. Detection, traces, and movement
// are not implemented yet.

#include "SOTS_ParkourComponent.h"

#include "GameFramework/Actor.h"
#include "GameFramework/Character.h"
#include "GameFramework/CharacterMovementComponent.h"

USOTS_ParkourComponent::USOTS_ParkourComponent()
{
    PrimaryComponentTick.bCanEverTick = false; // No tick needed in the skeleton passes

    // Initial state is idle; other fields already have default initializers.
    ParkourState      = ESOTS_ParkourState::Idle;
    CurrentClimbStyle = ESOTS_ClimbStyle::None;
    CurrentAction     = ESOTS_ParkourAction::None;
    LastResult.Reset();
}

void USOTS_ParkourComponent::BeginPlay()
{
    Super::BeginPlay();

    AActor* Owner = GetOwner();
    if (Owner)
    {
        if (ACharacter* AsCharacter = Cast<ACharacter>(Owner))
        {
            CachedCharacter = AsCharacter;
            CachedMovementComponent = AsCharacter->GetCharacterMovement();
        }
    }

    // SPINE 1: No movement mode hooks or input bindings yet.
    // Later passes will integrate with the player character’s input and
    // traversal systems.
}

bool USOTS_ParkourComponent::CanAttemptParkourInternal() const
{
    // Owner must be a valid character.
    if (!CachedCharacter.IsValid())
    {
        return false;
    }

    // In SPINE 1 we only allow attempts from Idle state. Later passes will
    // mirror CGF’s richer gating (movement mode, velocity, etc.).
    if (ParkourState != ESOTS_ParkourState::Idle)
    {
        return false;
    }

    return true;
}

void USOTS_ParkourComponent::RequestParkour()
{
    if (!CanAttemptParkourInternal())
    {
        return;
    }

    // Entering is a placeholder state that later passes will expand to:
    // - Run detection
    // - Fill LastResult
    // - Transition to Active or back to Idle.
    ParkourState = ESOTS_ParkourState::Entering;

    // SPINE 1: We do not yet compute a real result or move the character.
    // This is the hook that later passes will build the full CGF/TNT-based
    // detection and execution pipeline on top of.
}

void USOTS_ParkourComponent::CancelParkour()
{
    if (ParkourState == ESOTS_ParkourState::Idle)
    {
        // Nothing to cancel.
        return;
    }

    // Clear current action/context.
    CurrentAction     = ESOTS_ParkourAction::None;
    CurrentClimbStyle = ESOTS_ClimbStyle::None;
    LastResult.Reset();

    // Later we may want a proper Exiting state with animations. For now,
    // go straight back to Idle for safety and simplicity.
    ParkourState = ESOTS_ParkourState::Idle;
}

=== END FILE ===
