Opened the zip — it’s VibeUE, an Editor Unreal plugin that exposes a command-driven Blueprint editing stack (create/modify BPs, variables, functions, nodes, UMG) and pairs it with a Python MCP server + “tool” wrappers.

The part that’s a goldmine for finishing SOTS_BlueprintGen is how VibeUE solves the exact “BPGen hard problem”:

The key idea to steal: Node Discovery → Descriptor → Spawn

Your BPGen currently spawns nodes by NodeType with a big special-case chain in:

Plugins/SOTS_BlueprintGen/.../SOTS_BPGenBuilder.cpp → ApplyGraphSpecToFunction()

VibeUE instead does:

Discover nodes via Blueprint action database (node spawners)

Return a descriptor that includes a stable spawner_key (+ pin info)

Spawn by descriptor (reliable even for weird K2 nodes / library functions / variable nodes)

Where to look in the case study:

Source/VibeUE/Public/Commands/BlueprintReflection.h

FNodeSpawnerDescriptor (the “descriptor contract”)

Source/VibeUE/Private/Commands/BlueprintReflection.cpp

DiscoverNodesWithDescriptors(...) (builds descriptors from the action registry)

ExtractDescriptorFromSpawner(...) (how they compute spawner_key)

CreateNodeFromDescriptor(...) (spawns nodes using cached spawners)

test_prompts/blueprint/manage_blueprint_function_and_nodes.md

“Node Discovery (CRITICAL Workflow)” section shows the intended generation loop

What this unlocks for SOTS_BPGen

You can stop trying to pre-support every node class up front.

Instead, BPGen can:

accept either NodeType (your current path) or a new optional SpawnerKey

when SpawnerKey exists → spawn through the action database spawner

only keep special-case spawns for a tiny set of “synthetic” nodes (e.g., reroute) or your custom nodes

Second idea to steal: Schema-based pin linking

BPGen currently does FromPin->MakeLinkTo(ToPin).

VibeUE does:

Schema->TryCreateConnection(SourcePin, TargetPin)

fallback to MakeLinkTo only if needed

optional “break existing links” policy

returns structured info about created/broken links

Where:

Source/VibeUE/Private/Services/Blueprint/BlueprintNodeService.cpp → ConnectPinsAdvanced(...)

Source/VibeUE/Private/Commands/BlueprintNodeCommands.cpp → HandleConnectPins(...) calls into that

This will make BPGen graph application way less fragile.

Concrete “finish BPGen” integration plan (Buddy-ready)
BPGen_SPINE_A — Add descriptor discovery API (no behavior change yet)

[STATUS 2025-12-18] DONE via USOTS_BPGenDiscovery::DiscoverNodesWithDescriptors (spawner_key + optional pin descriptors).

Add a BPGen-side struct similar to FNodeSpawnerDescriptor (don’t need all fields day 1)

Add a builder utility: DiscoverNodesWithDescriptors(SearchTerm, BlueprintContext, bReturnPins)

Cache spawners by SpawnerKey

BPGen_SPINE_B — Spawn nodes by SpawnerKey (fallback to existing NodeType chain)

Extend FSOTS_BPGenGraphNode with:

SpawnerKey (string, optional)

(optional) ExternalTarget fields (function path / var name) if you want parity with VibeUE

In ApplyGraphSpecToFunction:

if SpawnerKey set → spawn via spawner

else → run your current NodeType special-case logic

BPGen_SPINE_C — Replace MakeLinkTo with Schema TryCreateConnection

Use UEdGraphSchema_K2::TryCreateConnection

Add optional link policy in FSOTS_BPGenGraphLink:

bBreakExistingFrom, bBreakExistingTo (default false)

BPGen_SPINE_D — “generation loop” docs + test harness

Add a BPGen doc that mirrors VibeUE’s “Discovery first” workflow

Update your existing test (BuildTestAllNodesGraphForBPPrintHello) to use:

discover → 2) spawn via spawner key → 3) connect via schema → 4) compile

One line takeaway

VibeUE proves the scalable solution is: BlueprintActionDatabase discovery + spawner_key identifiers, then BPGen becomes a thin “apply spec” layer instead of an ever-growing node whitelist.

If you want, I can turn the above into a single Buddy prompt pack (BPGen_SPINE_A–D) in your usual style so you can paste it straight into your workflow.

BPGen_SPINE_A
Thought for 9m 39s
Send2SOTS
/* 
BPGen_SPINE_A — Node Discovery (descriptor + stable spawner keys)
Goal: Add an editor-side discovery API to SOTS_BlueprintGen so DevTools/jobs can query available Blueprint nodes
      (function calls, variable get/set, casts, common K2 nodes) and receive a stable “spawner_key” + metadata
      that can later be translated into FSOTS_BPGenGraphNode specs (FunctionPath/StructPath/ExtraData).
Reference case study (from the uploaded zip): VibeUE’s node discovery + descriptor system:
  - Source/VibeUE/Public/Commands/BlueprintReflection.h  (FNodeSpawnerDescriptor + FPinDescriptor)
  - Source/VibeUE/Private/Commands/BlueprintReflection.cpp (BlueprintActionDatabase / NodeSpawner enumeration + caching)
Constraints (SOTS laws):
  - ADD-ONLY changes (do not remove existing functionality)
  - No builds/runs
  - After edits: delete this plugin’s Binaries/ and Intermediate/
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen
pass: BPGen_SPINE_A
stage: CODE_REVIEW (code-only, no DA/config shipping sweep)
focus: Implement node discovery API + descriptor structs (BlueprintCallable), modeled after VibeUE.

--------------------------------------------------------------------
0) First step (quick repo sanity)
- Use DevTools/ad_hoc_regex_search.py (or quick local search) for:
  - "BPGen" "Discovery" "NodeSpawner" "BlueprintActionDatabase" in Plugins/SOTS_BlueprintGen/
  - Confirm no existing discovery API already exists.
- Confirm plugin module is Editor (it is) and can include editor-only headers safely.

--------------------------------------------------------------------
1) Add new BPGen descriptor types (ADD-ONLY)
File: Plugins/SOTS_BlueprintGen/Source/SOTS_BlueprintGen/Public/SOTS_BPGenTypes.h
(Preferred: add near other “Result/Graph” structs; keep JSON comments consistent)

Add these USTRUCTs (names can vary, but keep them SOTS_* and BlueprintType):

A) FSOTS_BPGenDiscoveredPinDescriptor
- PinName (FName or FString)
- Direction (ESOTS_BPGenPinDirection)
- PinCategory / PinSubCategory (FName or FString)
- SubObjectPath (FString)  // matches BPGen’s SubObjectPath schema
- ContainerType (FString)  // "None"/"Array"/"Set"/"Map" (match existing container parsing)
- DefaultValue (FString)
- bIsHidden, bIsAdvanced (bool)  // optional but useful
- Tooltip (FString)              // optional

B) FSOTS_BPGenNodeSpawnerDescriptor
- SpawnerKey (FString)      // STABLE unique key (see section 3)
- DisplayName (FString)
- Category (FString)
- Keywords (TArray<FString>)   // optional
- Tooltip (FString)
- NodeClassName (FName or FString)   // “K2Node_CallFunction”, etc.
- NodeClassPath (FString)            // full path for debugging (optional)
- NodeType (FString)                 // “function_call”, “variable_get”, “variable_set”, “cast”, “event”, “generic”, “synthetic”
- FunctionPath (FString)             // if function-call/event: UFunction->GetPathName()
- StructPath (FString)               // if struct-based nodes: UScriptStruct->GetPathName()
- VariableName (FName or FString)    // if var get/set
- VariableOwnerClassPath (FString)   // optional; helps disambiguate
- VariablePinCategory/SubCategory/SubObjectPath/ContainerType (strings)  // optional but HIGH VALUE for auto-building ExtraData
- TargetClassPath (FString)          // for dynamic cast nodes, etc.
- Pins (TArray<FSOTS_BPGenDiscoveredPinDescriptor>)  // optional toggle
- bIsSynthetic (bool)                // “reroute/knot”, etc. (optional)

C) FSOTS_BPGenNodeDiscoveryResult
- bSuccess (bool)
- BlueprintAssetPath (FString)  // the queried BP, if any
- SearchText (FString)
- MaxResults (int32)
- Descriptors (TArray<FSOTS_BPGenNodeSpawnerDescriptor>)
- Errors (TArray<FString>)
- Warnings (TArray<FString>)

Keep schema comments “JSON: …” style consistent with existing BPGen structs.

--------------------------------------------------------------------
2) Add a discovery BlueprintFunctionLibrary (ADD-ONLY)
New files:
- Plugins/SOTS_BlueprintGen/Source/SOTS_BlueprintGen/Public/SOTS_BPGenDiscovery.h
- Plugins/SOTS_BlueprintGen/Source/SOTS_BlueprintGen/Private/SOTS_BPGenDiscovery.cpp

Class: USOTS_BPGenDiscovery (or USOTS_BPGenDiscoveryLibrary)
Expose (BlueprintCallable; CallInEditor is fine):

UFUNCTION(BlueprintCallable, Category="SOTS|BPGen|Discovery")
static FSOTS_BPGenNodeDiscoveryResult DiscoverNodesWithDescriptors(
  const UObject* WorldContextObject,
  const FString& BlueprintAssetPath,   // allow empty -> “global/common” discovery
  const FString& SearchText,
  int32 MaxResults = 200,
  bool bIncludePins = false
);

Optional extra helpers (nice-to-have but keep scope tight):
- DiscoverFunctionNodesByClassPath(...)
- ClearDiscoverySpawnerCache() (if you implement caching like VibeUE)

--------------------------------------------------------------------
3) Implementation notes (mirror VibeUE; keep it robust in UE5.7)
In SOTS_BPGenDiscovery.cpp:

A) Load blueprint context (if BlueprintAssetPath provided)
- UBlueprint* BP = LoadObject<UBlueprint>(nullptr, *BlueprintAssetPath);
- If not found: set bSuccess=false, Errors+=... and return.
- (Optional) If BP is not fully loaded/compiled, try refresh skeleton safely:
  - FKismetEditorUtilities::CompileBlueprint(BP)  (ONLY if it’s safe in commandlet/editor context; otherwise skip + warn)

B) Enumerate actions via BlueprintActionDatabase / menu builder
Use the same core approach as VibeUE:
- Include headers:
  - BlueprintActionDatabase.h
  - BlueprintNodeSpawner.h (+ BlueprintFunctionNodeSpawner.h, BlueprintVariableNodeSpawner.h)
  - BlueprintActionMenuBuilder.h / BlueprintActionMenuUtils.h
  - EdGraphSchema_K2.h
- Build a context that includes BP (and optionally a graph) and gather actions.
- Apply SearchText filtering:
  - Match against DisplayName, Keywords, Category, Tooltip (case-insensitive contains).
- Stop at MaxResults.

C) Build stable SpawnerKey (critical)
Use a deterministic key that survives sessions and doesn’t depend on pointer addresses:
- Function spawners: SpawnerKey = UFunction->GetPathName()
  - Also fill: FunctionPath = same string
  - NodeType = "function_call"
  - NodeClassName = "K2Node_CallFunction" (or the spawner’s node class name)
- Variable spawners: SpawnerKey = OwnerClassPath + ":" + PropertyName
  - OwnerClassPath = Property->GetOwnerStruct()->GetPathName() (or GetOwnerClass()->GetPathName())
  - Fill VariableName = PropertyName
  - NodeType = "variable_get"/"variable_set" depending on spawner/action
  - If you can, derive PinCategory/SubCategory/SubObjectPath/ContainerType by converting FProperty->FEdGraphPinType
- Cast nodes: SpawnerKey = "K2Node_DynamicCast|" + TargetClass->GetPathName()
- Synthetic/common nodes without real spawners (if you include them): e.g.
  - "K2Node_Knot" or "K2Node_Branch" etc.

D) Optional pin descriptors (bIncludePins)
If bIncludePins=true:
- Safest pattern: create a transient graph in the BP, invoke the spawner to create a node, read pins, then destroy/cleanup.
- Convert UEdGraphPin -> FSOTS_BPGenDiscoveredPinDescriptor:
  - Name, Direction, PinType.PinCategory/SubCategory, SubCategoryObject->GetPathName(), ContainerType, DefaultValue, bHidden/Advanced, Tooltip
- WARNING: keep this guarded; pin spawning can be expensive. Respect MaxResults.

--------------------------------------------------------------------
4) WHY this directly helps BPGen graph generation
After SPINE_A, DevTools can:
- Search for “Print String”, get FunctionPath = "/Script/Engine.KismetSystemLibrary:PrintString"
- Feed BPGen GraphSpec node:
  - NodeType = "K2Node_CallFunction"
  - FunctionPath = discovered FunctionPath
- For variable get/set, it can auto-fill ExtraData keys BPGen already expects:
  - PinCategory, PinSubCategory, SubObjectPath, ContainerType, DefaultValue

(Do NOT implement the “translate descriptor -> GraphNodeSpec” helper in SPINE_A unless it’s trivial; that’s SPINE_B.)

--------------------------------------------------------------------
5) Minimal docs/worklog (ADD-ONLY)
Add:
- Plugins/SOTS_BlueprintGen/Docs/Worklogs/BPGen_SPINE_A_NodeDiscovery_<timestamp>.md
Include:
  - What functions/structs were added
  - Notes about key format choices
  - Any UE5.7 API quirks encountered (menu builder, database calls)
  - Reminder: no build/run

Optional:
- Plugins/SOTS_BlueprintGen/Docs/Anchor/Anchor_BPGen_SPINE_A_NodeDiscovery.md
(Short [CONTEXT_ANCHOR] style summary; helpful for future passes)

--------------------------------------------------------------------
6) Cleanup (required)
- Delete:
  - Plugins/SOTS_BlueprintGen/Binaries/
  - Plugins/SOTS_BlueprintGen/Intermediate/

Done criteria:
- New structs exist in SOTS_BPGenTypes.h (add-only)
- New discovery library compiles in principle (header/cpp consistent; includes correct)
- Discovery returns stable keys + FunctionPath for function nodes at minimum
- Worklog added
- Cleanup done

Sources
BPGen_SPINE_B
Send2SOTS
/*
BPGen_SPINE_B — Spawn Nodes by SpawnerKey (descriptor-driven generation)
Goal: Extend SOTS_BlueprintGen so a GraphSpec node can be created using a stable SpawnerKey discovered in SPINE_A.
      This removes the need to hardcode node-class special cases for most “normal” nodes (function calls, var get/set, cast).
Reference case study: VibeUE’s CreateNodeFromDescriptor(...) using cached spawners built from discovery.
Constraints (SOTS laws):
  - ADD-ONLY changes (do not remove/alter existing NodeType-based behavior)
  - No builds/runs
  - After edits: delete this plugin’s Binaries/ and Intermediate/
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen
pass: BPGen_SPINE_B
stage: CODE_REVIEW (code-only, no DA/config shipping sweep)
focus: Add SpawnerKey path to GraphSpec + builder spawn path + caching.

--------------------------------------------------------------------
0) Pre-scan (5 minutes)
- Locate existing graph-apply entrypoints:
  - Search: "ApplyGraphSpecToFunction" "CreateNode" "Spawn" "NodeType" in SOTS_BlueprintGen
- Identify current struct used for “nodes in a graph spec” (likely FSOTS_BPGenGraphNode or similar).
- Confirm there is a centralized node spawn function; if not, create one (ADD-ONLY) and route new path through it.

--------------------------------------------------------------------
1) Extend GraphSpec node schema (ADD-ONLY, backward compatible)
File: Plugins/SOTS_BlueprintGen/Source/SOTS_BlueprintGen/Public/SOTS_BPGenTypes.h

In the node spec struct (example name):
- FSOTS_BPGenGraphNode

Add fields:
- SpawnerKey (FString)   // optional; if set -> spawn via spawner registry
- bPreferSpawnerKey (bool, default true) // optional; lets callers force old behavior if needed

Keep JSON-style comments:
  // JSON: "spawner_key": "..."

Compatibility rules:
- Existing pipeline continues to work if SpawnerKey empty.
- NodeType/FunctionPath/etc remain honored exactly as before.

--------------------------------------------------------------------
2) Add a spawner registry cache (ADD-ONLY)
New files (or tuck into existing discovery files if you already created them):
- Public/SOTS_BPGenSpawnerRegistry.h
- Private/SOTS_BPGenSpawnerRegistry.cpp

Class: FSOTS_BPGenSpawnerRegistry (non-UObject singleton-ish helper) OR UEditorSubsystem if you prefer.
Required surface:
- static bool ResolveSpawnerByKey(const FString& SpawnerKey, TSharedPtr<FBlueprintNodeSpawner>& OutSpawner, FString& OutError);
- static void PrimeCacheForBlueprint(UBlueprint* BP);      // optional
- static void ClearCache();

Implementation approach (mirror VibeUE):
- Use BlueprintActionDatabase / action menu builder to enumerate node spawners.
- Build SpawnerKey deterministically (same exact rules as SPINE_A).
- Store map: SpawnerKey -> TSharedPtr<FBlueprintNodeSpawner>
- IMPORTANT: registry may be global (not per-BP) but should include enough actions to satisfy most needs.
- If context-sensitive actions require BP context, allow cache to be “best effort” and fallback to context scan on miss.

Miss strategy:
- On Resolve miss:
  1) If caller provides BP context, do a context-bound scan to try to find the key.
  2) If still not found: return false with error.

--------------------------------------------------------------------
3) Implement “spawn by spawner key” in builder (ADD-ONLY)
File: Plugins/SOTS_BlueprintGen/Source/SOTS_BlueprintGen/Private/SOTS_BPGenBuilder.cpp
(or wherever node creation happens)

Add a new function (or equivalent):
- UEdGraphNode* SpawnNodeFromSpawnerKey(
    UBlueprint* Blueprint,
    UEdGraph* Graph,
    const FString& SpawnerKey,
    const FVector2D& NodePos,
    FString& OutError
  );

Steps:
A) Resolve spawner:
- TSharedPtr<FBlueprintNodeSpawner> Spawner;
- if !Registry.ResolveSpawnerByKey(SpawnerKey, Spawner, Err) -> OutError=Err; return nullptr;

B) Invoke spawner:
- Use FBlueprintActionContext / FBlueprintActionMenuBuilder patterns if needed,
  but simplest is:
  - ensure Graph not null
  - call Spawner->Invoke(Graph, /*Bindings*/ ???, NodePos)
UE APIs vary; choose the correct UE5.7 pattern:
- In many UE versions, BlueprintNodeSpawner has:
  - Invoke(UEdGraph* ParentGraph, FBindingSet const& Bindings, FVector2D const Location)
If Bindings are needed:
- Create empty FBindingSet (works for most function nodes)
- For variable spawners, if bindings required, attempt:
  - FBlueprintActionMenuItem or the spawner’s “GetBindings” path (best effort)
If binding complexity blocks you:
- Defer “property-bound” variable spawners to SPINE_C and keep SPINE_B limited to function-call and generic K2 nodes.
  (But TRY first—variable get/set is a major win.)

C) Post-spawn configure:
- If node supports defaults (call-function nodes):
  - if you already have “SetPinDefaultValueFromSpec” utilities, keep using them.
- Ensure node is added to graph transactionally consistent with existing BPGen behavior.

--------------------------------------------------------------------
4) Wire it into ApplyGraphSpecToFunction (ADD-ONLY)
In the loop where nodes are created:
- If (NodeSpec.SpawnerKey not empty) AND (NodeSpec.bPreferSpawnerKey true):
  - try SpawnNodeFromSpawnerKey(...)
  - If success: continue
  - If fail: add warning and FALL BACK to existing NodeType-based creation
    (this fallback is important for stability and keeps add-only promise)

Also:
- If NodeSpec.NodeType is empty BUT SpawnerKey exists, allow it (SpawnerKey-only graphs).

--------------------------------------------------------------------
5) Minimal translation helper (optional but HIGH VALUE)
Add a helper to convert SPINE_A descriptor into a GraphSpec node:
- FSOTS_BPGenGraphNode MakeGraphNodeFromDescriptor(const FSOTS_BPGenNodeSpawnerDescriptor& D);

Rules:
- Set SpawnerKey = D.SpawnerKey
- If D.FunctionPath not empty: also set FunctionPath (nice for debugging)
- If var spawner: set VariableName/OwnerClassPath/pin type hints into ExtraData if BPGen already expects them

This is OPTIONAL in SPINE_B; if time gets tight, leave it for SPINE_D.

--------------------------------------------------------------------
6) Document key formats + fallback behavior
Docs:
- Plugins/SOTS_BlueprintGen/Docs/Worklogs/BPGen_SPINE_B_SpawnBySpawnerKey_<timestamp>.md
Include:
- SpawnerKey format rules (must match SPINE_A exactly)
- Spawn path: resolve -> invoke -> configure -> connect
- Fallback path: if spawner missing or invoke fails -> existing NodeType pipeline
- Notes on which node categories are confirmed supported by spawner path (functions first)

Optional:
- Docs/BPGen_SpawnerKey_Spec.md (tiny spec doc)

--------------------------------------------------------------------
7) Cleanup (required)
- Delete:
  - Plugins/SOTS_BlueprintGen/Binaries/
  - Plugins/SOTS_BlueprintGen/Intermediate/

Done criteria:
- GraphSpec node supports SpawnerKey without breaking old JSON/specs.
- Builder attempts spawner spawn first (when key present), then falls back to existing code.
- Registry cache exists and is add-only.
- Worklog added; cleanup done.

BPGen_SPINE_B
Thought for 30s
Send2SOTS
/*
BPGen_SPINE_B — Spawn Nodes by SpawnerKey (descriptor-driven generation)
Goal: Extend SOTS_BlueprintGen so a GraphSpec node can be created using a stable SpawnerKey (from SPINE_A discovery),
      while keeping ALL existing NodeType/FunctionPath logic intact as a fallback (ADD-ONLY).
Primary win: function calls (K2Node_CallFunction) become “data-driven” instead of hardcoded.
Secondary win: variable get/set + cast via bindings, if feasible in UE5.7 action pipeline.
Constraints:
  - ADD-ONLY (do not delete/replace existing paths; just add a new path + fallback)
  - No build/run
  - Cleanup: delete plugin Binaries/ + Intermediate after edits
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen
pass: BPGen_SPINE_B
stage: CODE_REVIEW (code-only)
focus: SpawnerKey in spec + spawner registry + spawn-by-key path + fallback.

--------------------------------------------------------------------
0) Repo scan (do this first)
A) Find the node creation choke-point(s):
- Search in Plugins/SOTS_BlueprintGen/ for:
  - "ApplyGraphSpecToFunction"
  - "CreateNode" "SpawnNode" "NodeType" "K2Node_"
  - "MakeLinkTo" (graph wiring pass)
B) Identify the GraphSpec node struct (likely FSOTS_BPGenGraphNode).

--------------------------------------------------------------------
1) Extend GraphSpec node schema (ADD-ONLY, backward compatible)
File: Public/SOTS_BPGenTypes.h

In FSOTS_BPGenGraphNode (or equivalent), add:
- FString SpawnerKey;        // JSON: "spawner_key"
- bool bPreferSpawnerKey = true;  // JSON: "prefer_spawner_key" (optional but useful)

Rules:
- If SpawnerKey empty -> nothing changes.
- If SpawnerKey provided -> attempt spawner path first (when bPreferSpawnerKey true),
  but ALWAYS fallback to existing NodeType path on failure.

--------------------------------------------------------------------
2) Add a small “resolved spawner” cache (ADD-ONLY)
New files:
- Public/SOTS_BPGenSpawnerRegistry.h
- Private/SOTS_BPGenSpawnerRegistry.cpp

Add a tiny POD struct:
- struct FSOTS_BPGenResolvedSpawner
  {
    TWeakObjectPtr<class UBlueprintNodeSpawner> Spawner;
    struct FBindingSet Bindings; // defined in BlueprintNodeSpawner.h (verify exact type name in UE5.7 headers)
    FString DebugDisplayName;
    FString DebugCategory;
  };

Registry map:
- TMap<FString, FSOTS_BPGenResolvedSpawner> KeyToSpawner;

API:
- static bool ResolveForContext(UBlueprint* BP, UEdGraph* Graph, const FString& SpawnerKey, FSOTS_BPGenResolvedSpawner& Out, FString& OutError);
- static void PrimeCacheForContext(UBlueprint* BP, UEdGraph* Graph, int32 MaxItemsToCache = 5000); // optional; called lazily
- static void ClearCache();

IMPORTANT:
- Cache should be “best effort” and context-friendly:
  - On Resolve miss: try to (re)prime cache for BP/Graph context once, then lookup again.
  - Do NOT hard-fail without attempting a context scan.

--------------------------------------------------------------------
3) How to build the cache (mirror VibeUE, but keep it practical)
Implementation guidance (UE API names differ; you MUST confirm via header search in Engine/Source):

A) Use the action system (BlueprintActionDatabase / action menu builder) to enumerate actions:
- Includes you’ll likely need (verify exact paths):
  - BlueprintActionDatabase.h
  - BlueprintActionMenuBuilder.h (or BlueprintActionMenuUtils.h)
  - BlueprintNodeSpawner.h
  - BlueprintFunctionNodeSpawner.h
  - BlueprintVariableNodeSpawner.h
  - EdGraphSchema_K2.h

B) Build a context that includes the BP + Graph (context-sensitive matters):
- Use whatever UE5.7 provides:
  - FBlueprintActionContext
  - BlueprintActionMenuBuilder, etc.

C) For each discovered action item, extract:
- UBlueprintNodeSpawner* Spawner
- FBindingSet Bindings (if available from the action item)
- DisplayName/Category for debugging

CRITICAL extraction step:
- You need BOTH “Spawner” and “Bindings” if you want variable get/set to work reliably.
- The easiest path is usually:
  - enumerate “menu items” (not raw spawners)
  - each menu item provides a spawner + binding set

If you can’t find the binding accessor quickly:
- Search Engine sources for “GetBindings(” and “FBindingSet” to find the canonical way in UE5.7.

D) Compute the same deterministic SpawnerKey format as SPINE_A (must match exactly):
- Function call:
  - Key = Function->GetPathName()
  - Example: "/Script/Engine.KismetSystemLibrary:PrintString"
- Variable get/set:
  - Key = OwnerClassOrStructPath + ":" + PropertyName
  - Example: "/Script/MyModule.MyClass:Health"
  - (If UE gives you a property path or GUID, you may include it after the name, but KEEP the prefix stable.)
- Dynamic cast:
  - Key = "K2Node_DynamicCast|" + TargetClass->GetPathName()
- Generic K2 nodes (if they appear as actions with no function/property):
  - Key = "K2Node|" + NodeClassPathOrName

Store:
- KeyToSpawner.Add(Key, {Spawner, Bindings, DebugName, DebugCategory})

--------------------------------------------------------------------
4) Add “SpawnNodeFromSpawnerKey” path in the builder (ADD-ONLY)
In the builder file where nodes are created (likely Private/SOTS_BPGenBuilder.cpp), add:

UEdGraphNode* SpawnNodeFromSpawnerKey(
  UBlueprint* BP,
  UEdGraph* Graph,
  const FString& SpawnerKey,
  const FVector2D& NodePos,
  FString& OutError
);

Steps:
1) Resolve:
- FSOTS_BPGenResolvedSpawner R;
- if (!Registry.ResolveForContext(BP, Graph, SpawnerKey, R, Err)) { OutError=Err; return nullptr; }
- if (!R.Spawner.IsValid()) { OutError="Spawner expired: " + SpawnerKey; return nullptr; }

2) Invoke spawner:
- Find the UE5.7 signature for UBlueprintNodeSpawner::Invoke(...)
  - Typical pattern is: Invoke(UEdGraph* ParentGraph, const FBindingSet& Bindings, FVector2D Location)
- Use R.Bindings (even if empty) + NodePos.

3) Post-spawn setup (minimal):
- If your existing pipeline sets pin defaults / node metadata from the spec,
  keep doing that AFTER creation (this remains BPGen’s job).
- Do not change your existing “pin default application” logic—just reuse it.

Return node or set OutError with a useful message:
- include Key + DebugDisplayName + DebugCategory in error strings (huge for diagnosing discovery/spec mismatches).

--------------------------------------------------------------------
5) Wire into ApplyGraphSpecToFunction with strict fallback (ADD-ONLY)
Where BPGen loops GraphSpec.Nodes:
- If Node.SpawnerKey not empty AND Node.bPreferSpawnerKey:
  - Try SpawnNodeFromSpawnerKey(...)
  - If success: record NodeId -> CreatedNode mapping and continue
  - If failure:
    - Add a WARNING entry in result (not a hard failure)
    - Continue to existing NodeType-based spawn path exactly as before

Fallback behavior is non-negotiable:
- It preserves current BPGen behavior
- It lets you roll out descriptor-driven generation gradually

--------------------------------------------------------------------
6) Minimal “supported-by-spawner” target for SPINE_B
To keep SPINE_B from exploding in scope, lock “done” as:
✅ Function-call nodes via SpawnerKey (main objective)
✅ Generic action nodes that spawn without bindings (bonus)
➕ Variable get/set if bindings extraction is straightforward (attempt it, but do not block SPINE_B completion)

If variables don’t work yet:
- Log it in the worklog as “needs binding extraction follow-up”
- Keep old variable path as fallback (already exists)

--------------------------------------------------------------------
7) Worklog + cleanup (required)
Add:
- Docs/Worklogs/BPGen_SPINE_B_SpawnBySpawnerKey_<timestamp>.md

Worklog must include:
- SpawnerKey format spec (exact strings)
- Where registry enumerates actions + how bindings are captured
- Which node categories are confirmed supported by spawner path (at least function calls)
- Fallback behavior details

Cleanup:
- Delete Plugins/SOTS_BlueprintGen/Binaries/
- Delete Plugins/SOTS_BlueprintGen/Intermediate/

--------------------------------------------------------------------
Done criteria
- FSOTS_BPGenGraphNode accepts SpawnerKey without breaking old specs
- Builder attempts SpawnerKey spawn first and falls back cleanly
- Registry can resolve at least UFunction-path keys and spawn call-function nodes
- Worklog added; cleanup done
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_B]
- Added optional "SpawnerKey" to BPGen node specs (add-only).
- Implemented spawner registry cache mapping SpawnerKey -> (UBlueprintNodeSpawner + bindings).
- Builder now tries Spawn-by-SpawnerKey first, then falls back to legacy NodeType-based creation on failure.
- Primary support target: function call nodes (UFunction path keys). Variables/casts attempted if bindings are accessible.
*/

BPGen_SPINE_C
Send2SOTS
/*
BPGen_SPINE_C — Schema-based Pin Linking (TryCreateConnection + optional break policies)
Goal: Make SOTS_BlueprintGen graph wiring far less fragile by using the K2 schema to connect pins
      (UEdGraphSchema_K2::TryCreateConnection) instead of direct MakeLinkTo, while preserving legacy behavior.
Reference case study: VibeUE’s “ConnectPinsAdvanced” style helper (schema-first + structured results).
Constraints (SOTS laws):
  - ADD-ONLY changes (do not remove existing link behavior; introduce schema-first path + fallback)
  - No build/run
  - Cleanup: delete plugin Binaries/ + Intermediate after edits
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen
pass: BPGen_SPINE_C
stage: CODE_REVIEW (code-only)
focus: Robust pin connection: schema-first + optional link policies + better diagnostics.

--------------------------------------------------------------------
0) Repo scan (do this first)
- Find current pin-linking implementation:
  - Search in Plugins/SOTS_BlueprintGen/ for:
    - "MakeLinkTo("
    - "TryCreateConnection"
    - "BreakAllPinLinks"
    - "ConnectPins"
    - "ApplyGraphSpec" "Wire" "Link"
- Identify the “link spec” struct(s) used by BPGen:
  - likely FSOTS_BPGenGraphLink / FSOTS_BPGenLinkSpec / similar

--------------------------------------------------------------------
1) Extend LinkSpec with optional policy flags (ADD-ONLY)
File: Public/SOTS_BPGenTypes.h

In the link spec struct:
Add fields (all optional; default false):
- bool bBreakExistingFrom = false;   // JSON: "break_existing_from"
- bool bBreakExistingTo   = false;   // JSON: "break_existing_to"
- bool bUseSchema         = true;    // JSON: "use_schema" (optional; defaults true)

Notes:
- Keep old specs valid (no required fields).
- If you already have “bForce” or similar, do NOT change semantics; just add new toggles.

--------------------------------------------------------------------
2) Add a new “ConnectPinsSchemaFirst” helper (ADD-ONLY)
Preferred location: Private/SOTS_BPGenBuilder.cpp (or a new helper file if you want it reusable)

Signature suggestion:
static bool ConnectPinsSchemaFirst(
  UEdGraphPin* FromPin,
  UEdGraphPin* ToPin,
  const FSOTS_BPGenGraphLink& LinkSpec,
  FString& OutError,
  FString& OutWarning
);

Implementation steps:
A) Validate pins:
- if (!FromPin || !ToPin) -> OutError="Null pin"; return false
- if (FromPin->Direction == ToPin->Direction) -> OutError="Both pins same direction"; return false

B) Apply break policies (only when requested):
- if (LinkSpec.bBreakExistingFrom) FromPin->BreakAllPinLinks(true);
- if (LinkSpec.bBreakExistingTo)   ToPin->BreakAllPinLinks(true);

C) Schema-first connect:
- const UEdGraphSchema* Schema = FromPin->GetSchema();
  - If null, try ToPin->GetSchema()
- if Schema exists:
  - bool bOk = Schema->TryCreateConnection(FromPin, ToPin);
  - If bOk -> return true
  - else -> OutWarning = "Schema rejected connection; will fallback to MakeLinkTo"

D) Fallback (preserve legacy behavior):
- FromPin->MakeLinkTo(ToPin);
- return true (but set OutWarning if schema failed)

IMPORTANT:
- Do NOT remove old MakeLinkTo usage entirely; only move it behind schema attempt + fallback.

--------------------------------------------------------------------
3) Wire this into the graph-apply linking loop (ADD-ONLY)
Where BPGen processes LinkSpecs:
- Replace direct FromPin->MakeLinkTo(ToPin) with:
  - if (LinkSpec.bUseSchema) attempt ConnectPinsSchemaFirst(...)
  - else do legacy MakeLinkTo path (exactly as before)

Also add better per-link diagnostics in the result object (if BPGen already returns a result struct):
- On schema failure + fallback: store a warning string:
  - include NodeId/PinName on both sides (VERY helpful)
- On hard failure (null pins etc.): store an error string

--------------------------------------------------------------------
4) Pin resolution robustness (small add-only improvement if time allows)
If BPGen resolves pins by name, strengthen it (without changing existing rules):
- If pin not found by exact name:
  - attempt case-insensitive match
  - attempt “DisplayName” match if you store it (optional)
- If still not found: error with a clear list of available pin names on that node.

This is optional, but it massively reduces “silent spec mismatch” pain.

--------------------------------------------------------------------
5) Test harness / debug output (no build/run; just add code-level hooks)
Add a debug-only helper (guarded by WITH_EDITOR and/or a BPGen debug macro you already use):
- “DumpNodePins(Node)” that logs:
  - PinName, Direction, Category/SubCategory, LinkedTo count

Do not enable spam by default—just keep it callable from BPGen’s existing debug toggles if any.

--------------------------------------------------------------------
6) Worklog + docs (required)
Add:
- Docs/Worklogs/BPGen_SPINE_C_SchemaPinLinking_<timestamp>.md

Include:
- What new fields were added to LinkSpec
- The exact connection algorithm (schema-first, optional breaks, fallback)
- Example error/warning strings produced
- Note that schema rejects invalid type connections (expected) and fallback is present only to preserve legacy behavior

Optional (nice):
- Docs/Anchor/Anchor_BPGen_SPINE_C_SchemaPinLinking.md with a short [CONTEXT_ANCHOR] block

--------------------------------------------------------------------
7) Cleanup (required)
- Delete:
  - Plugins/SOTS_BlueprintGen/Binaries/
  - Plugins/SOTS_BlueprintGen/Intermediate/

Done criteria:
- LinkSpec supports break policies add-only
- BPGen uses TryCreateConnection first (when enabled) and falls back safely
- Warnings/errors are more informative (node/pin names)
- Worklog added; cleanup done
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_C]
- Added schema-first pin connection using UEdGraphSchema::TryCreateConnection with optional break-link policies.
- Preserved legacy MakeLinkTo as a fallback path (add-only).
- Improved link-time diagnostics (warnings when schema rejects, errors when pins can’t be resolved).
*/

BPGen_SPINE_D
Send2SOTS
/*
BPGen_SPINE_D — “Discovery-first” generation loop + minimal translator + test spec (Docs + Harness)
Goal: Make BPGen usable end-to-end in the new scalable workflow:
      1) Discover nodes -> 2) Create GraphSpec using SpawnerKey -> 3) Spawn nodes -> 4) Connect via schema -> 5) Compile
      Also add a tiny “descriptor -> GraphNodeSpec” translator helper and a small harness/example that exercises the loop.
Reference case study: VibeUE’s “Node Discovery (CRITICAL Workflow)” and manage_blueprint_function_and_nodes.md.
Constraints (SOTS laws):
  - ADD-ONLY changes (no removal of existing tests/utilities)
  - No build/run
  - Cleanup: delete plugin Binaries/ + Intermediate after edits
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen
pass: BPGen_SPINE_D
stage: CODE_REVIEW (code-only)
focus: docs + minimal glue + example harness that demonstrates discovery->spec->apply.

--------------------------------------------------------------------
0) Repo scan (do this first)
- Locate any existing test harness / example commandlet / editor utility:
  - Search in SOTS_BlueprintGen for: "Test" "Example" "Demo" "BuildTest" "Hello" "PrintString"
- Locate the public “apply graph spec” entrypoint:
  - e.g., USOTS_BPGenLibrary::ApplyGraphSpecToFunction (or similar)

--------------------------------------------------------------------
1) Add a minimal translator: Descriptor -> GraphNodeSpec (ADD-ONLY)
Add file (or place in discovery library if you prefer):
- Public/SOTS_BPGenDescriptorTranslator.h
- Private/SOTS_BPGenDescriptorTranslator.cpp

Function(s):
A) FSOTS_BPGenGraphNode MakeNodeSpecFromDescriptor(const FSOTS_BPGenNodeSpawnerDescriptor& D)
Rules (keep it minimal and deterministic):
- NodeSpec.SpawnerKey = D.SpawnerKey
- NodeSpec.bPreferSpawnerKey = true
- If D.FunctionPath not empty:
  - NodeSpec.FunctionPath = D.FunctionPath   // helpful for debugging + fallback
  - NodeSpec.NodeType = "K2Node_CallFunction" (ONLY if your system expects this; otherwise leave NodeType empty)
- If D.NodeClassName not empty and your spec supports it:
  - NodeSpec.NodeType = D.NodeClassName or a normalized type string (optional)
- For variable get/set:
  - NodeSpec.VariableName = D.VariableName
  - NodeSpec.VariableOwnerClassPath = D.VariableOwnerClassPath
  - (Optional) fill ExtraData keys BPGen already understands:
    - pin_category, pin_subcategory, subobject_path, container_type

B) FSOTS_BPGenGraphLink MakeLinkSpecByPinNames(
     const FString& FromNodeId, const FString& FromPinName,
     const FString& ToNodeId,   const FString& ToPinName,
     bool bUseSchema = true, bool bBreakFrom=false, bool bBreakTo=false)

This is just ergonomic sugar; keep it small.

IMPORTANT:
- This translator does NOT replace your existing JSON ingestion; it just helps generate correct specs from discovery.

--------------------------------------------------------------------
2) Add an “end-to-end” example harness (ADD-ONLY)
Pick the simplest integration point that already exists (examples):
- An editor-only “RunBPGenExample” BlueprintCallable function
- Or a small automation-test-style function (no need to register a full AutomationTest if that’s overhead)

New file suggestion:
- Public/SOTS_BPGenExamples.h
- Private/SOTS_BPGenExamples.cpp

Expose:
UFUNCTION(BlueprintCallable, CallInEditor, Category="SOTS|BPGen|Examples")
static bool Example_Generate_PrintString_FunctionGraph(
  const FString& BlueprintAssetPath,
  const FString& FunctionName,
  FString& OutReport
);

Algorithm:
1) Discover:
- Call DiscoverNodesWithDescriptors(BlueprintAssetPath, "Print String", Max=50, bIncludePins=false)
- Find descriptor whose FunctionPath == "/Script/Engine.KismetSystemLibrary:PrintString"
  (or contains "KismetSystemLibrary" + "PrintString")
2) Build GraphSpec:
- Create GraphSpec for target function:
  - Nodes:
    - Entry node (if BPGen already creates it automatically, skip)
    - PrintString node spec (via MakeNodeSpecFromDescriptor)
    - (Optional) literal string via “MakeLiteralString” node or set DefaultValue on PrintString’s InString pin
  - Links:
    - Exec: Entry.Then -> PrintString.Execute
3) Apply:
- Use existing ApplyGraphSpecToFunction to create/modify the function graph
4) Report:
- OutReport includes counts: nodes spawned, links made, warnings/errors from result

If BPGen already has a “Hello” test graph builder:
- Do NOT replace it; just add this as a new example that explicitly uses SpawnerKey.

--------------------------------------------------------------------
3) Add a “Discovery-first BPGen workflow” doc (ADD-ONLY)
New doc:
- Plugins/SOTS_BlueprintGen/Docs/BPGen_DiscoveryFirst_Workflow.md

Contents (keep it direct and copy-paste friendly):
A) The loop:
1) DiscoverNodesWithDescriptors(SearchText)
2) Choose descriptor(s) -> spawner_key(s)
3) Build GraphSpec nodes with spawner_key
4) ApplyGraphSpecToFunction
5) Connect pins via schema (default)
B) SpawnerKey rules (copy from SPINE_A/B)
C) Recommended practice:
- Always store both SpawnerKey and FunctionPath in specs (FunctionPath = good fallback/debug)
- Prefer bIncludePins=false unless you’re building an authoring tool
D) Failure modes:
- Key not found -> fallback to legacy NodeType path (if spec includes FunctionPath)
- Schema rejects link -> warning; verify pin types

--------------------------------------------------------------------
4) Add worklog + anchors (required)
- Docs/Worklogs/BPGen_SPINE_D_DiscoveryFirst_Loop_<timestamp>.md
Include:
- Translator added + where
- Example harness added + how it works
- Doc added + path

Optional:
- Docs/Anchor/Anchor_BPGen_SPINE_D_DiscoveryFirst.md with [CONTEXT_ANCHOR]

--------------------------------------------------------------------
5) Cleanup (required)
- Delete:
  - Plugins/SOTS_BlueprintGen/Binaries/
  - Plugins/SOTS_BlueprintGen/Intermediate/

Done criteria:
- There is a minimal descriptor->spec translator helper
- There is at least one end-to-end example that uses SpawnerKey to create a node
- There is a doc explaining the discovery-first workflow
- Worklog added; cleanup done
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_D]
- Added “discovery-first” BPGen workflow doc + minimal descriptor->GraphSpec translator.
- Added an end-to-end example harness that discovers PrintString, builds a GraphSpec using SpawnerKey, applies it, and reports results.
- Keeps all legacy JSON/spec paths intact; this is additive scaffolding to make BPGen practical at scale.
*/

what else is needed to finish this ? what about the mcp server and the example prompts ... how do I incorporate its whole work flow
Thought for 3m 0s

To “finish” BPGen in the same end-to-end way VibeUE works, think in 3 layers:

UE plugin primitives (BPGen) — you’re building this now (SPINE_A–D)

Remote control surface — something outside the editor can call (socket/HTTP/commandlet)

AI-facing workflow (MCP tools + prompt pack) — the “how you drive it” layer

Right now SPINE_A–D mostly completes layer 1. What’s missing is layers 2–3.

What else is needed to finish BPGen
1) A real “entrypoint” that can be driven repeatedly

You need one of these:

Option A (interactive, VibeUE-style): a UE-side TCP JSON bridge (Unreal listens; Python connects, sends commands, gets JSON back).

Option B (batch, simplest): a commandlet / -ExecutePythonScript job runner that reads DevTools/Inbox/BPGenJobs/*.json and applies specs.

If you want the “assistant can iteratively build graphs” experience, Option A is the match.

2) Idempotency & identity

VibeUE leans hard on node_id and “update existing vs create new”.

To match that workflow, BPGen should support:

node_id required/encouraged in specs

create_or_update semantics:

if node_id exists → find node → move/configure/connect

else → create → assign id → return id

deterministic list/describe so the AI can verify state

3) A verification toolbox (so the AI can self-correct)

Minimum set that makes the workflow stable:

list_nodes(graph_scope, function_name)

describe_node(node_id) (pins + types + defaults)

compile_blueprint() + save_asset()

refresh_node() / refresh_all_nodes() (helps after property/var changes)

(VibeUE exposes all of that through MCP tools. Without it, the AI can’t “check its work”.)

MCP server + example prompts: how to incorporate the whole workflow
How VibeUE is doing it (the pattern to copy)

A Python FastMCP server (Content/Python/vibe_ue_server.py) registers “tools” like:

manage_blueprint

manage_blueprint_function

manage_blueprint_node (includes discover → create → connect loop)

Each tool sends one JSON command over TCP to Unreal, receives a JSON response, disconnects.

Important detail they call out: Unreal closes connections after each command (so the client reconnects every time).

How you map that to SOTS

You already have the UE-side capability growing in BPGen. Now add:

Layer 2: SOTS_BPGen_Bridge (UE plugin, tiny)

A small plugin/module that:

opens a local TCP port (like 55557)

accepts JSON like:

{"tool":"bpgen","action":"discover_nodes", ...}

{"tool":"bpgen","action":"apply_graph_spec", ...}

{"tool":"bpgen","action":"list_nodes", ...}

routes those to your BPGen C++ functions

returns a single JSON response and closes

Keep BPGen “pure” if you want: BPGen = editing APIs, Bridge = networking.

Layer 3: DevTools/python/sots_bpgen_mcp_server.py

A FastMCP server (same “multi-action tool” style as VibeUE) that exposes one primary tool:

manage_bpgen(action=..., blueprint=..., graph_scope=..., function_name=..., payload=...)

Actions:

discover_nodes (SPINE_A output)

apply_graph_spec (SPINE_B/C path)

list_nodes

describe_node

compile

save

refresh_node / refresh_all

Now your AI workflow becomes identical to VibeUE’s:

discover → create/apply → connect → configure → compile → verify

What to do with the “example prompts” + workflow docs

VibeUE’s Content/Python/resources/topics/blueprint-workflow.md is basically a playbook for agents.

For SOTS you incorporate it by:

copying that structure into your repo as:

DevTools/prompts/BPGen/topics/overview.md

DevTools/prompts/BPGen/topics/blueprint-workflow.md

DevTools/prompts/BPGen/topics/node-tools.md

updating tool names + fields to your MCP tool (manage_bpgen) and your schema (GraphSpec, spawner_key, node_id, etc.)

adding 2–3 “golden path” examples your project will reuse constantly:

“Create function + PrintString”

“Add variable + Set + Branch”

“Bind to component / get world location”

That gives Buddy (and future agents) a standard operating procedure that prevents the “wrong order” failures.

If you want the shortest path to “working end-to-end”

Do these next (in this order):

BPGen_SPINE_E: node_id + list/describe + compile/save entrypoints

BPGen_SPINE_F: UE TCP JSON bridge (or commandlet runner)

BPGen_SPINE_G: MCP server + SOTS prompt pack mirroring VibeUE’s topics

Send2SOTS
[CONTEXT_ANCHOR][BPGen_FINISH_LINE]
- SPINE_A–D = core UE-side primitives (discover→spawner_key spawn→schema connect→doc+example).
- “Finish BPGen” needs: (1) remote entrypoint (TCP bridge or batch job runner), (2) idempotent node_id/update semantics,
  (3) verification tools (list/describe/compile/save/refresh), (4) MCP server tool surface + prompt playbook.
- Best match to VibeUE workflow: separate SOTS_BPGen_Bridge (UE TCP JSON) + DevTools FastMCP server (manage_bpgen multi-action).


If you want, I can write the BPGen_SPINE_E / F / G prompt packs in the same style as A–D so you can hand them straight to Buddy.

BPGen_SPINE_E
Send2SOTS
/*
BPGen_SPINE_E — Idempotent Graph Editing + Verification Surface (list/describe/compile/save/refresh)
Goal: Add the missing “workflow stability” layer so BPGen can be driven iteratively (by MCP/bridge or batch jobs):
      - node_id-based idempotency (create-or-update)
      - list nodes / describe node (pins, types, defaults, links)
      - compile blueprint + save asset
      - refresh/reconstruct nodes (fix up after var/type changes)
This is the core “verification toolbox” VibeUE relies on so an agent can check & correct work.
Constraints (SOTS laws):
  - ADD-ONLY changes (do NOT remove/alter existing apply behavior; add new optional paths + new helpers)
  - No build/run
  - Cleanup: delete plugin Binaries/ + Intermediate after edits
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen
pass: BPGen_SPINE_E
stage: CODE_REVIEW (code-only)
focus: Idempotency + inspect/verify actions needed for MCP workflow.

--------------------------------------------------------------------
0) Repo scan (do this first)
- Find current result/diagnostics structs returned by BPGen:
  - Search: "Result" "Report" "Errors" "Warnings" "ApplyGraphSpec" "Compile"
- Find how BPGen identifies nodes today (if at all):
  - Search: "NodeId" "Guid" "FindNode" "FBlueprintEditorUtils"
- Find pin-type serialization helpers (if any) used in SPINE_A pin descriptors.

--------------------------------------------------------------------
1) Add stable node identity support (ADD-ONLY)
A) Extend GraphNodeSpec with optional persistent identity fields
File: Public/SOTS_BPGenTypes.h (in FSOTS_BPGenGraphNode or equivalent)
Add:
- FString NodeId;              // JSON: "node_id" (caller-supplied stable id)
- bool bCreateOrUpdate = true; // JSON: "create_or_update" (default true)
- bool bAllowCreate = true;    // JSON: "allow_create" (default true)
- bool bAllowUpdate = true;    // JSON: "allow_update" (default true)

Rules:
- If NodeId empty -> legacy behavior (always create new)
- If NodeId set:
  - If node exists:
    - if !bAllowUpdate -> return warning/error (choose warning + skip)
    - else update (position, defaults, title, etc.)
  - If node missing:
    - if !bAllowCreate -> warning + skip
    - else create new and stamp NodeId

B) Stamp NodeId onto the created UEdGraphNode (Editor-only metadata)
Preferred approach (add-only; doesn’t require engine changes):
- Use Node->NodeComment or Node->GetMetaData? (avoid clobbering user comments)
- Better: store a tiny tag string in Node->NodeComment ONLY if you have a dedicated “BPGen reserved region”
  Example: append a line like:
    "[SOTS_BPGEN_NODE_ID]=<id>"
  and preserve existing comments above it.
- Alternative (cleaner): use UEdGraphNode::Tags (if available in UE5.7) or UObject MetaData on the node.
  (Verify UE5.7 APIs; pick the least invasive.)

Add helpers:
- static bool ExtractBPGenNodeId(const UEdGraphNode* Node, FString& OutNodeId);
- static void SetBPGenNodeId(UEdGraphNode* Node, const FString& NodeId);

IMPORTANT:
- This is the foundation for “find node by id”.

--------------------------------------------------------------------
2) Find existing node by NodeId (ADD-ONLY)
Add to builder (or a helper file):
- static UEdGraphNode* FindNodeByBPGenNodeId(UEdGraph* Graph, const FString& NodeId);

Implementation:
- Iterate Graph->Nodes:
  - if ExtractBPGenNodeId(Node) == NodeId -> return Node
Return nullptr if not found.

Performance:
- Optional: build a map NodeId->Node* once per apply pass.

--------------------------------------------------------------------
3) Update ApplyGraphSpecToFunction to support create-or-update (ADD-ONLY)
Where nodes are created:
- If NodeSpec.NodeId not empty AND NodeSpec.bCreateOrUpdate:
  - Try FindNodeByBPGenNodeId
  - If found:
    - Treat as “created node” and run your existing configuration steps:
      - move node to NodePos if provided
      - set pin defaults from spec
      - set titles/options you already support
    - Do NOT recreate it
  - If not found:
    - Create via SpawnerKey path (SPINE_B) if available else legacy NodeType
    - Stamp NodeId on newly created node

Diagnostics:
- Result should include arrays:
  - CreatedNodeIds, UpdatedNodeIds, SkippedNodeIds
  (Add to your existing result struct add-only.)

--------------------------------------------------------------------
4) Add “list nodes in function graph” (BlueprintCallable) (ADD-ONLY)
New/extend a library:
- Public/SOTS_BPGenInspector.h
- Private/SOTS_BPGenInspector.cpp

USTRUCT: FSOTS_BPGenNodeSummary
Fields:
- NodeId (FString)                 // extracted, empty if not present
- NodeGuid (FGuid as FString)      // optional
- NodeClass (FString)
- Title (FString)
- PosX/PosY (int32)
- Pins (TArray<FSOTS_BPGenDiscoveredPinDescriptor>) // optional if bIncludePins
- RawNodeName (FString)            // optional debugging

UFUNCTION(BlueprintCallable, Category="SOTS|BPGen|Inspect")
static bool ListFunctionGraphNodes(
  const FString& BlueprintAssetPath,
  const FString& FunctionName,
  bool bIncludePins,
  TArray<FSOTS_BPGenNodeSummary>& OutNodes,
  FString& OutError
);

Implementation:
- Load BP
- Find function graph:
  - Use FBlueprintEditorUtils::GetAllGraphs / FindObject / FindFunctionGraph patterns
- Iterate nodes; build summaries; include NodeId if present.

--------------------------------------------------------------------
5) Add “describe node” (pins + defaults + links) (ADD-ONLY)
USTRUCT: FSOTS_BPGenNodeDescription
Fields:
- Summary (FSOTS_BPGenNodeSummary)
- Links (array of pin-to-pin links):
  - Each link: FromPinName, ToNodeId(or NodeGuid), ToPinName
- Defaults map (optional): PinName -> DefaultValue string (only for input pins)

UFUNCTION(BlueprintCallable)
static bool DescribeNodeById(
  const FString& BlueprintAssetPath,
  const FString& FunctionName,
  const FString& NodeId,
  FSOTS_BPGenNodeDescription& OutDesc,
  FString& OutError
);

Implementation:
- Find node by NodeId (using helper)
- Collect pins + LinkedTo info
- When target node has NodeId, prefer it in output; else fallback to node name/guid.

This gives the agent a “truth view” to verify the graph.

--------------------------------------------------------------------
6) Add compile + save + refresh actions (ADD-ONLY)
A) Compile blueprint
UFUNCTION(BlueprintCallable)
static bool CompileBlueprintAsset(
  const FString& BlueprintAssetPath,
  FString& OutError,
  TArray<FString>& OutWarnings
);

Implementation:
- Load BP
- FKismetEditorUtilities::CompileBlueprint(BP) (editor-only)
- Gather compile log if available (best effort)

B) Save asset
UFUNCTION(BlueprintCallable)
static bool SaveBlueprintAsset(
  const FString& BlueprintAssetPath,
  FString& OutError
);

Implementation:
- Load BP
- MarkPackageDirty (if needed)
- Use UPackage::SavePackage or editor asset tools:
  - Prefer: UEditorLoadingAndSavingUtils::SavePackages if available
  - Keep it simple and editor-only
(If saving is too environment-dependent, expose it but return a “not supported in this context” error.)

C) Refresh / reconstruct nodes
UFUNCTION(BlueprintCallable)
static bool RefreshAllNodesInFunction(
  const FString& BlueprintAssetPath,
  const FString& FunctionName,
  FString& OutError
);

Implementation:
- Iterate nodes:
  - Node->ReconstructNode()
- Then mark blueprint as structurally modified:
  - FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(BP)

This is important after variable type changes.

--------------------------------------------------------------------
7) Result struct upgrades (ADD-ONLY)
If ApplyGraphSpec returns a result struct, extend it:
- TArray<FString> CreatedNodeIds
- TArray<FString> UpdatedNodeIds
- TArray<FString> SkippedNodeIds
- TArray<FString> InspectNotes (optional)

Also ensure link pass emits warnings/errors clearly (works well with SPINE_C).

--------------------------------------------------------------------
8) Worklog + minimal doc (required)
Add:
- Docs/Worklogs/BPGen_SPINE_E_IdempotentInspectCompileSave_<timestamp>.md
Include:
- How NodeId is stored on nodes (exact encoding format)
- Which new inspector APIs exist
- Compile/save/refresh notes + any limitations
- Reminder: these are prerequisites for MCP/bridge loop

Optional:
- Docs/Anchor/Anchor_BPGen_SPINE_E_VerificationSurface.md with [CONTEXT_ANCHOR]

--------------------------------------------------------------------
9) Cleanup (required)
- Delete:
  - Plugins/SOTS_BlueprintGen/Binaries/
  - Plugins/SOTS_BlueprintGen/Intermediate/

Done criteria:
- NodeId create-or-update works without breaking legacy “create new” behavior
- You can list nodes in a function graph and see NodeIds
- You can describe a node (pins + links)
- You can compile blueprint + (optionally) save + refresh nodes
- Worklog added; cleanup done
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_E]
- Added NodeId-based create-or-update semantics (idempotent graph edits).
- Added inspection APIs: list nodes + describe node (pins/defaults/links).
- Added workflow support APIs: compile blueprint, save asset, refresh/reconstruct nodes.
- This verification surface enables MCP-style iterative generation and self-correction loops.
*/

BPGen_SPINE_F
Thought for 21s
Send2SOTS
[STATUS 2025-12-19] DONE via SOTS_BPGen_Bridge routing: ping/discover/apply/list/describe/compile/save/refresh wired to BPGen APIs.
/*
BPGen_SPINE_F — Local TCP JSON Bridge (Unreal “command server” for BPGen)
Goal: Add the “remote entrypoint” layer so external tooling (DevTools / MCP server) can drive BPGen in an
      iterative loop: discover → apply → inspect → compile → save → refresh.
This mirrors the VibeUE pattern: one JSON command per connection; Unreal replies with JSON and closes.
Constraints (SOTS laws):
  - ADD-ONLY changes (do NOT change existing BPGen behavior; only add a new bridge layer)
  - No build/run
  - Cleanup: delete plugin Binaries/ + Intermediate after edits (for whichever plugin you touch/create)
  - Plugins must remain decoupled (no project-level module dependencies)
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen (or new plugin SOTS_BPGen_Bridge — recommended)
pass: BPGen_SPINE_F
stage: CODE_REVIEW (code-only)
focus: TCP JSON server + request routing to BPGen APIs + docs.

====================================================================
A) RECOMMENDED STRUCTURE (clean separation)
Create a NEW plugin: Plugins/SOTS_BPGen_Bridge/
- Type: Editor
- Module: SOTS_BPGen_Bridge (Editor module)
- Depends on: SOTS_BlueprintGen (for the BPGen APIs), plus engine networking/json modules

Rationale:
- Keeps SOTS_BlueprintGen “pure” (graph editing + discovery)
- Bridge becomes a thin transport adapter (easy to disable, easy to swap to HTTP later)

If you strongly prefer not to add a new plugin, you may implement inside SOTS_BlueprintGen as an Editor subsystem.
But the cleanest parity with suite ownership patterns is a separate bridge plugin.

====================================================================
B) NETWORKING/THREADING RULES (CRITICAL)
Blueprint graph edits + asset loads MUST run on the Game Thread.
So:
- Socket accept/read happens on a background thread
- Routing schedules a task onto Game Thread
- Background thread waits for completion (with timeout), then sends response, closes socket

Keep it simple & safe:
- Bind ONLY to 127.0.0.1 by default
- Fixed default port (e.g., 55557) but configurable via INI/plugin settings

====================================================================
C) REQUEST/RESPONSE CONTRACT (stable, MCP-friendly)

1) Request JSON (single object)
{
  "tool": "bpgen",
  "action": "discover_nodes" | "apply_graph_spec" | "list_nodes" | "describe_node" |
            "compile_blueprint" | "save_blueprint" | "refresh_nodes" | "ping" | "shutdown",
  "request_id": "uuid-or-any-string",
  "params": { ... action-specific ... }
}

2) Response JSON (single object)
{
  "ok": true|false,
  "request_id": "...",
  "action": "...",
  "result": { ... action-specific ... },
  "errors": [ "..." ],
  "warnings": [ "..." ],
  "server": { "plugin":"SOTS_BPGen_Bridge", "version":"0.1", "port":55557 }
}

3) Message framing (choose one and document it)
Recommended: NEWLINE-delimited JSON (NDJSON)
- Client sends exactly one JSON line ending with '\n'
- Server reads until '\n' (or max bytes), parses once, responds with one JSON line + '\n', closes

(Length-prefix is more robust but adds complexity; NDJSON is enough for local tooling.)

====================================================================
D) IMPLEMENTATION TASKS (step-by-step)

--------------------------------------------------------------------
1) Create plugin + module
- Plugins/SOTS_BPGen_Bridge/SOTS_BPGen_Bridge.uplugin
  - "Type": "Editor"
  - EnabledByDefault: false (optional) or true (your choice)
  - Modules: [{ Name:"SOTS_BPGen_Bridge", Type:"Editor", LoadingPhase:"Default" }]

- Source/SOTS_BPGen_Bridge/SOTS_BPGen_Bridge.Build.cs
  Add modules:
  - "Core", "CoreUObject", "Engine"
  - "Sockets", "Networking"
  - "Json", "JsonUtilities"
  - "UnrealEd" (Editor only helpers, if needed)
  - Dependency on "SOTS_BlueprintGen" (the plugin/module that exposes BPGen APIs)
  Use PrivateDependencyModuleNames for most of these.

--------------------------------------------------------------------
2) Add the server core
Files:
- Public/SOTS_BPGenBridgeServer.h
- Private/SOTS_BPGenBridgeServer.cpp
- Private/SOTS_BPGen_BridgeModule.cpp/.h

Server class responsibilities:
- Start(Address, Port)
- Stop()
- IsRunning()
- Background accept loop
- Per-connection: read single JSON line, parse, dispatch, write JSON response, close

Use UE APIs:
- ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)
- CreateSocket(NAME_Stream, ...)
- Bind/Listen
- Accept
- Recv loop (until '\n' or MaxBytes)
- Send response bytes

Avoid complex multi-client concurrency:
- Handle one connection at a time (sequential) for v0.1
- This is enough for MCP tool calls (which are sequential anyway)

Add simple timeouts:
- Read timeout (e.g., 2–5 seconds)
- Game-thread job timeout (e.g., 30 seconds)
- If timeout -> ok:false + error message

--------------------------------------------------------------------
3) Game-thread dispatch shim (CRITICAL)
In the server, after you parse the request:
- Create a “job” struct:
  - Action, RequestId, ParamsJson
- Use AsyncTask(ENamedThreads::GameThread, ...) to execute:
  - RouteAction(Action, Params) -> ResultJson / Errors / Warnings
- Use an FEvent to signal completion back to socket thread.
- Return response.

--------------------------------------------------------------------
4) Action routing (map to BPGen_SPINE_A–E)
Create a router function:
static void RouteBpgenAction(
  const FString& Action,
  const TSharedPtr<FJsonObject>& Params,
  /*out*/ bool& bOk,
  /*out*/ TSharedPtr<FJsonObject>& OutResult,
  /*out*/ TArray<FString>& OutErrors,
  /*out*/ TArray<FString>& OutWarnings
);

Actions (minimum set for “workflow complete”):
- ping:
  - result: { "pong": true, "time": "...", "version": "0.1" }
- discover_nodes:
  - params: { "blueprint_asset_path":"...", "search_text":"...", "max_results":200, "include_pins":false }
  - call BPGen discovery API from SPINE_A
- apply_graph_spec:
  - params: { "blueprint_asset_path":"...", "function_name":"...", "graph_spec":{...} }
  - call BPGen apply entrypoint (existing) which now supports SpawnerKey + schema linking + NodeId update
- list_nodes:
  - params: { "blueprint_asset_path":"...", "function_name":"...", "include_pins":false }
  - call inspector from SPINE_E
- describe_node:
  - params: { "blueprint_asset_path":"...", "function_name":"...", "node_id":"..." }
  - call inspector from SPINE_E
- compile_blueprint:
  - params: { "blueprint_asset_path":"..." }
  - call compile from SPINE_E
- save_blueprint:
  - params: { "blueprint_asset_path":"..." }
  - call save from SPINE_E
- refresh_nodes:
  - params: { "blueprint_asset_path":"...", "function_name":"..." }
  - call refresh from SPINE_E
- shutdown:
  - schedules Stop() and returns ok:true

NOTE:
- The bridge should NOT interpret/construct graph specs; it only forwards.

--------------------------------------------------------------------
5) Configuration (port/bind)
Add plugin settings:
- UDeveloperSettings (Editor) OR simple config vars:
  - bAutoStart (default false)
  - BindAddress (default "127.0.0.1")
  - Port (default 55557)
  - MaxRequestBytes (default ~1MB)
Expose a BlueprintCallable “Start/Stop Server” utility for manual control if desired.

--------------------------------------------------------------------
6) Minimal docs (required)
Add:
- Plugins/SOTS_BPGen_Bridge/Docs/BPGen_Bridge_Protocol.md
Include:
- NDJSON framing
- Request/response schema
- Supported actions + params
- Default address/port
- Threading note (game-thread dispatch)
- Example raw requests (copy/paste)

Add worklog:
- Plugins/SOTS_BPGen_Bridge/Docs/Worklogs/BPGen_SPINE_F_TCPBridge_<timestamp>.md

Optional anchor:
- Plugins/SOTS_BPGen_Bridge/Docs/Anchor/Anchor_BPGen_SPINE_F_TCPBridge.md
  with a short [CONTEXT_ANCHOR] block.

--------------------------------------------------------------------
7) Cleanup (required)
If you created SOTS_BPGen_Bridge:
- Delete Plugins/SOTS_BPGen_Bridge/Binaries/
- Delete Plugins/SOTS_BPGen_Bridge/Intermediate/

If you modified SOTS_BlueprintGen as well:
- Also delete Plugins/SOTS_BlueprintGen/Binaries/
- Also delete Plugins/SOTS_BlueprintGen/Intermediate/

====================================================================
E) DONE CRITERIA (what “SPINE_F complete” means)
- Unreal has a local-only TCP server that accepts one JSON command per connection and replies with JSON.
- Actions route into BPGen discovery/apply/inspect/compile/save/refresh without needing Blueprints created by hand.
- Protocol doc exists and matches implementation.
- Worklog added; artifacts cleaned.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_F]
- Added local-only TCP NDJSON bridge (one command per connection) to drive BPGen remotely.
- Bridge dispatches actions onto Game Thread and returns structured JSON results/errors.
- Supports the full iterative workflow surface: discover, apply, list/describe, compile, save, refresh.
*/

anything else needed for the full working worflow ?
Thought for 9s

Yeah — SPINE_A–F gets you the core engine-side loop, but a “full working workflow” (like VibeUE end-to-end) typically still needs a few workflow glue + hardening pieces.

Must-have to feel “complete”

BPGen_SPINE_G: MCP server + tool surface + prompt pack

manage_bpgen(action=...) tools that talk to the TCP bridge

a “topics” playbook (discovery-first loop, error recovery, verification checklist)

3–5 “golden path” example prompts that your agents reuse constantly

Ensure/Create primitives

ensure_function(blueprint, function_name, signature…)

ensure_variable(blueprint, var_name, type…)

optionally ensure_macro / ensure_event_dispatcher

Without these, the agent gets stuck whenever the target function/var doesn’t exist yet (VibeUE has those “manage blueprint / manage function” commands).

Asset + graph targeting rules

a consistent way to address which graph you’re editing:

Function graph vs EventGraph vs Macro graph vs Widget graph

plus “create if missing” behavior (or clear error messages)

Strongly recommended (stability + “self-correction”)

Locking / single-writer guard

prevent two commands from editing the same BP at once

simple global mutex is fine for v0.1

Deterministic pin addressing

pin-name mismatches are the #1 failure mode

add “pin aliases” or fallback pin resolution rules (by direction + type + index) when exact name fails

Structured error codes

not just strings — return codes like:

ERR_NODE_NOT_FOUND, ERR_PIN_NOT_FOUND, ERR_SCHEMA_REJECTED, ERR_SPAWNER_MISSING

your MCP prompts can branch on codes and auto-retry with discovery/describe

“Plan → apply → verify” contract

every apply returns:

created/updated node_ids

link results (ok/warn/error per link)

compile status (optional)

the MCP layer should always follow with list/describe verification on important steps

Nice-to-haves (quality of life)

Auto-layout / formatting

simple horizontal spacing rules, optional “auto-arrange after apply”

Transactions / undo

wrap each request in an editor transaction so you can revert if needed

Batch mode

a “job folder runner” that reads JSON jobs (good fallback if TCP bridge is off)

The “done-done” checklist

If you can do this loop reliably, you’re basically there:

discover_nodes("Print String") → choose spawner_key

ensure_function("MyFunc")

apply_graph_spec with node_id + spawner_key

list_nodes / describe_node verify pins/links

compile_blueprint

save_blueprint

If any step fails, the MCP playbook should prescribe the recovery:

rediscover → respawn by key

describe pins → relink via schema

refresh nodes → recompile

Send2SOTS
[CONTEXT_ANCHOR][BPGen_WORKFLOW_REMAINS]
- To complete the VibeUE-style workflow beyond SPINE_F, you mainly need SPINE_G (MCP server + prompt playbook),
  plus “ensure/create” primitives (functions/variables/graphs), and a stability layer (locks, error codes, pin addressing rules).
- With discover→ensure→apply→inspect→compile→save running repeatably (and recoverably), BPGen is “full workflow complete”.


If this feels important enough to lock in, it probably belongs as a short entry in SOTS_Suite_ExtendedMemory_LAWs.txt under BPGen workflow completion criteria.

BPGen_SPINE_G
Send2SOTS
/*
BPGen_SPINE_G — MCP Server + Prompt Pack (full VibeUE-style workflow driver)
Goal: Add the “AI-facing” layer that talks to your local UE TCP bridge (SPINE_F) and provides:
  - MCP tools: manage_bpgen (multi-action) + a few ergonomic helpers
  - Prompt playbook/topics: discovery-first loop + recovery patterns
  - Golden-path example prompts: 3–5 reusable recipes
SOTS laws:
  - ADD-ONLY (DevTools changes must not remove existing features/options; avoid file-size drops via add-only edits + backups)
  - No build/run
  - If you touch plugin(s): delete Binaries/ + Intermediate/
*/

[SOTS_BUDDY_PASS]
plugin: DevTools (python) + prompt pack assets
pass: BPGen_SPINE_G
stage: CODE_REVIEW (tooling + docs, no UE build/run)
focus: FastMCP server that calls UE BPGen bridge (NDJSON TCP), plus prompt resources.

==============================================================================
1) Files to ADD (preferred; don’t disturb existing DevTools)
A) MCP server (new)
- DevTools/python/sots_bpgen_mcp_server.py

B) Bridge client helper (new, reusable)
- DevTools/python/sots_bpgen_bridge_client.py

C) Prompt pack (new folder)
- DevTools/prompts/BPGen/README.md
- DevTools/prompts/BPGen/topics/overview.md
- DevTools/prompts/BPGen/topics/blueprint-workflow.md
- DevTools/prompts/BPGen/topics/recovery-and-verification.md
- DevTools/prompts/BPGen/examples/01_print_string_function.md
- DevTools/prompts/BPGen/examples/02_ensure_var_set_branch.md
- DevTools/prompts/BPGen/examples/03_widget_bind_text.md  (optional if you want UMG early)
- DevTools/prompts/BPGen/examples/04_refactor_existing_graph_by_id.md

Optional (nice):
- Plugins/SOTS_BPGen_Bridge/Docs/BPGen_MCP_Usage.md (only if you already created that plugin)

==============================================================================
2) UE Bridge Contract (must match SPINE_F)
Assume UE bridge listens on:
- host: 127.0.0.1
- port: 55557
- framing: NDJSON (one JSON line per connection, UE replies one JSON line, then closes)

Request JSON:
{
  "tool": "bpgen",
  "action": "<action>",
  "request_id": "<string>",
  "params": { ... }
}

Response JSON:
{
  "ok": true|false,
  "request_id": "...",
  "action": "...",
  "result": { ... },
  "errors": [ ... ],
  "warnings": [ ... ],
  "server": { ... }
}

Supported actions (minimum “full workflow”):
- ping
- discover_nodes
- ensure_function          (if not in UE yet, implement as a BPGen action in SPINE_E or stub as “not supported”)
- ensure_variable          (same note)
- apply_graph_spec
- list_nodes
- describe_node
- compile_blueprint
- save_blueprint
- refresh_nodes

If ensure_* isn’t implemented UE-side yet:
- MCP server should expose “ensure_*” tools but return a clean error code: ERR_UNSUPPORTED_ACTION
- Prompt pack should instruct the agent to create function/var via existing BPGen APIs or a separate pass.

==============================================================================
3) DevTools/python/sots_bpgen_bridge_client.py (ADD-ONLY helper)
Implement a tiny client function that:
- opens TCP socket
- sends json.dumps(req) + "\n"
- reads until "\n" (or socket close)
- json.loads(resp)
- returns dict

Required features:
- timeouts: connect 1–2s, recv 10–30s
- max bytes guard (ex: 2MB)
- friendly error objects:
  - return {"ok":False,"errors":["..."],"warnings":[],"result":{},"action":action,"request_id":rid}

Also include:
- def bpgen_call(action: str, params: dict, host="127.0.0.1", port=55557) -> dict
- def bpgen_ping(...) convenience

==============================================================================
4) DevTools/python/sots_bpgen_mcp_server.py (FastMCP server)
Use the same pattern as VibeUE:
- one MCP “tool” that multiplexes actions (simple + stable)
- plus a couple sugar tools that call manage_bpgen internally

Implementation outline:

A) Imports
Try FastMCP first; keep a fallback message if missing:
- from mcp.server.fastmcp import FastMCP   (or the correct package you already use)
If import fails:
- print a clear install hint and exit non-zero (do NOT silently succeed)

B) Server init
- mcp = FastMCP("SOTS_BPGen")
- read env vars:
  - SOTS_BPGEN_HOST (default 127.0.0.1)
  - SOTS_BPGEN_PORT (default 55557)
  - SOTS_BPGEN_TIMEOUT (default 30)

C) Primary tool: manage_bpgen
@ mcp.tool()
def manage_bpgen(action: str, params: dict = None) -> dict:
- validates action
- calls bridge_client.bpgen_call(action, params or {})
- returns raw response dict (ok/result/errors/warnings)

D) Ergonomic tools (thin wrappers)
@ mcp.tool()
def bpgen_discover(blueprint_asset_path: str, search_text: str, max_results: int = 200, include_pins: bool = False) -> dict
- calls manage_bpgen("discover_nodes", {...})

@ mcp.tool()
def bpgen_apply(blueprint_asset_path: str, function_name: str, graph_spec: dict) -> dict
- calls manage_bpgen("apply_graph_spec", {...})

@ mcp.tool()
def bpgen_list(blueprint_asset_path: str, function_name: str, include_pins: bool = False) -> dict
- calls manage_bpgen("list_nodes", {...})

@ mcp.tool()
def bpgen_describe(blueprint_asset_path: str, function_name: str, node_id: str) -> dict
- calls manage_bpgen("describe_node", {...})

@ mcp.tool()
def bpgen_compile(blueprint_asset_path: str) -> dict
@ mcp.tool()
def bpgen_save(blueprint_asset_path: str) -> dict
@ mcp.tool()
def bpgen_refresh(blueprint_asset_path: str, function_name: str) -> dict

E) Error codes (important for prompt playbook)
When bridge returns ok:false, MCP should preserve errors.
Optionally normalize by adding:
- error_codes: ["ERR_SCHEMA_REJECTED", ...] if the UE response includes it
If UE doesn’t emit codes yet, keep it as strings for now.

F) Run
if __name__ == "__main__":
- mcp.run()

==============================================================================
5) Prompt pack content (what agents follow)

A) DevTools/prompts/BPGen/topics/overview.md
Include:
- The workflow loop: Discover → Spec → Apply → Inspect → Compile → Save
- The required rule: “ALWAYS verify with list/describe after apply”
- The identity rule: “Use node_id for every important node; never rely on auto GUID”
- The key rule: “Prefer spawner_key; also store function_path as fallback/debug”

B) DevTools/prompts/BPGen/topics/blueprint-workflow.md
Include:
1) Start:
- bpgen_ping
2) Discover:
- bpgen_discover("…BP", "Print String")
3) Build spec:
- nodes: {node_id, spawner_key, pos, defaults}
- links: exec + data pins (use_schema true)
4) Apply:
- bpgen_apply
5) Verify:
- bpgen_list + bpgen_describe per node_id
6) Compile + Save:
- bpgen_compile + bpgen_save
7) Recovery:
- if pin missing → bpgen_describe → adjust pin names
- if schema reject → fix types or insert conversion nodes
- if stale node after var changes → bpgen_refresh → recompile

C) DevTools/prompts/BPGen/topics/recovery-and-verification.md
Provide “if/then” recipes:
- ERR_NODE_NOT_FOUND → list_nodes → confirm node_id stamping → re-apply with allow_create true
- ERR_SPAWNER_MISSING → rediscover → update spawner_key → re-apply
- ERR_PIN_NOT_FOUND → describe_node → pick correct pin name → relink
- compile warnings → refresh_nodes → recompile

==============================================================================
6) Golden-path examples (copy/paste prompts)
Keep them short, action-oriented, and reusable.

Example 01 — PrintString in a function
- discover PrintString
- apply graph_spec with node_id "print_1" and exec link from entry to print
- set InString default to "Hello from BPGen"
- verify describe_node("print_1")
- compile + save

Example 02 — Ensure var + Set + Branch
(If ensure_variable not supported yet, instruct “create variable manually first” or defer)
- variable set node by spawner_key (or legacy var path)
- add Branch node + comparison node
- connect schema-first
- verify pins + types
- compile + save

Example 03 — Widget bind text (optional)
- target: Widget blueprint, function graph or binding graph
- show how to address non-function graphs (if supported). If not supported yet, mark as “future: BPGen_SPINE_H UMG graphs”.

Example 04 — Refactor existing graph by node_id
- list_nodes
- choose node_id(s)
- move nodes
- reconnect links
- verify

==============================================================================
7) Worklog (required)
Add:
- DevTools/Docs/Worklogs/BPGen_SPINE_G_MCP_Server_<timestamp>.md
Include:
- How to run MCP server
- Which tools exist + their params
- Bridge host/port defaults
- Example command sequence (ping → discover → apply → list → describe → compile → save)

==============================================================================
8) Add-only DevTools safety (VERY IMPORTANT)
- Do NOT edit/remove existing DevTools scripts/options.
- If you must add entrypoints to an existing DevTools launcher/menu, do it add-only:
  - add new command entries, do not delete old ones
  - preserve CLI flags
  - make a .bak copy of touched files as a safety net

==============================================================================
DONE CRITERIA (full workflow feels real when…)
- MCP server can ping UE bridge successfully.
- You can run the golden-path example 01 end-to-end with verification:
  discover → apply (spawner_key + node_id) → describe → compile → save
- Prompt playbook exists and teaches the “always verify + recover” habits.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_G]
- Added MCP server (FastMCP) that exposes manage_bpgen + ergonomic wrappers, calling the UE NDJSON TCP bridge.
- Added BPGen prompt pack: discovery-first workflow, verification/recovery recipes, and golden-path examples.
- This completes the full VibeUE-style iterative workflow layer on top of SPINE_A–F.
*/

SPINE_H needed ?
Thought for 11s

If your definition of “full working workflow” is VibeUE-level parity (edit any BP surface reliably, not just function graphs), then yeah — SPINE_H is worth doing.

If your goal is narrower — generate/patch function graphs only (most gameplay logic) — then A–G is already a complete loop: discover → apply → inspect → compile → save, driven via MCP + bridge.

When SPINE_H is needed

You need it if you want any of these:

Graph targeting beyond functions

EventGraph, Construction Script, Macro graphs, AnimBP graphs, Widget binding graphs

“Ensure/create” primitives in-engine

ensure_function (create if missing + signature)

ensure_variable (create if missing + type)

ensure_event_dispatcher, ensure_interface_implementation, etc.

UMG authoring

create widgets in the widget tree, set properties, create bindings, wire to functions

Agent-grade robustness

deterministic pin addressing (aliases / fallback matching)

error codes (not just strings)

per-request editor transaction + undo safety

A clean SPINE_H scope

BPGen_SPINE_H — Graph Targets + Ensure Primitives + UMG (optional split)
STATUS 2025-12-19: Core targets/ensure/hardening DONE (UMG deferred to SPINE_H2 follow-up).

GraphScope routing: target_graph = {Function|EventGraph|Macro|Construction|WidgetBinding} (+ create if missing)

Ensure primitives: create/update function + variable + dispatcher (idempotent)

UMG (either in H or as SPINE_H2): widget tree create/config + binding wiring

Hardening: pin aliasing + structured error codes + transaction wrapper

If you want the fastest “ship the workflow” path: do SPINE_H without UMG first, then add SPINE_H2_UMG once the core is rock solid.

BPGen_SPINE_H, we are going for full 1:1 parity
Send2SOTS
/*
BPGen_SPINE_H — Full 1:1 Parity Workflow Layer (Graph Targets + Ensure Primitives + UMG + Hardening)
Goal: Achieve VibeUE-level parity: BPGen can author/modify ALL major Blueprint surfaces reliably via the
      same iterative loop (discover → apply → inspect → compile → save), driven over the TCP bridge + MCP.
This pass expands BPGen beyond “function graphs only” into:
  - Graph targeting: EventGraph, Construction Script, Macro graphs, Widget graphs/bindings, AnimBP graphs (where feasible)
  - Ensure primitives: functions/vars/dispatchers/interfaces (idempotent)
  - UMG authoring: widget tree create/config + binding creation + graph wiring
  - Hardening: structured error codes, transactions, locks, deterministic pin addressing
SOTS laws:
  - ADD-ONLY changes (no removals)
  - No build/run
  - Cleanup: delete touched plugin(s) Binaries/ + Intermediate/
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen (primary) + (optional) SOTS_BPGen_Bridge (routing additions)
pass: BPGen_SPINE_H
stage: CODE_REVIEW (code-only)
focus: Full surface parity.

==============================================================================
H0) Pre-scan (required)
- Confirm existing apply/inspect/compile/save APIs from SPINE_E.
- Identify where “function graph” is currently resolved.
- Identify existing BPGen GraphSpec root struct:
  - It likely assumes a function context. We will ADD-ONLY support broader targets.

==============================================================================
H1) Universal Graph Targeting (ADD-ONLY)

1) Extend GraphSpec root with a Target block
File: Public/SOTS_BPGenTypes.h
Add USTRUCT:
- FSOTS_BPGenGraphTarget
  - FString BlueprintAssetPath;   // JSON: "blueprint_asset_path"
  - FString TargetType;           // JSON: "target_type"
      // allowed: "Function", "EventGraph", "ConstructionScript", "Macro", "WidgetGraph", "WidgetBinding", "AnimGraph", "StateMachine"
  - FString Name;                 // JSON: "name"
      // FunctionName, MacroName, WidgetGraphName, BindingName, etc.
  - FString SubName;              // JSON: "sub_name"
      // e.g., for AnimBP: StateMachineName, StateName
  - bool bCreateIfMissing = true; // JSON: "create_if_missing"

Then in your main GraphSpec:
- FSOTS_BPGenGraphTarget Target; // JSON: "target": {...}

Back-compat:
- If Target not provided:
  - treat as TargetType="Function" with Name = existing FunctionName parameter

2) Implement resolver helpers (ADD-ONLY)
New file suggestion:
- Public/SOTS_BPGenGraphResolver.h
- Private/SOTS_BPGenGraphResolver.cpp

APIs:
- static bool ResolveTargetGraph(
    UBlueprint* BP,
    const FSOTS_BPGenGraphTarget& Target,
    /*out*/ UEdGraph*& OutGraph,
    /*out*/ FString& OutError,
    /*out*/ FString& OutErrorCode
  );

Implement cases:

A) Function
- Find existing function graph by name; if missing and bCreateIfMissing:
  - Create a new function graph with default signature (void, no params) OR
  - Prefer using EnsureFunction primitive (H2) for correct signature creation.

B) EventGraph
- Locate BP’s Ubergraph page (EventGraph). If missing and bCreateIfMissing:
  - Create one (UE has helpers; use FBlueprintEditorUtils utilities).

C) ConstructionScript
- Resolve BP->UberGraphPages / construction script graph (varies by type). Create if missing.

D) Macro
- Resolve macro graphs by name; create if missing (FBlueprintEditorUtils::CreateNewGraph + MarkBlueprint...).

E) WidgetGraph / WidgetBinding (UMG)
- For UWidgetBlueprint:
  - Resolve designer graph or binding graph; binding graphs usually map to generated function graphs.
  - IMPORTANT: keep this robust: binding may be represented as a function named like "GetText_0" etc.
  - We will implement UMG primitives in H3/H4 to avoid guessing.

F) AnimGraph / StateMachine / State
- For UAnimBlueprint:
  - AnimGraph and state machine graphs are specialized.
  - If parity demands it, implement “best-effort”: resolve graphs by name from BP->Ubergraph pages / function graphs.
  - If UE’s AnimBP graph creation APIs are too specialized, you may implement “edit existing only” for v0.1 parity,
    and return ERR_UNSUPPORTED_CREATE for missing targets.

Key rule:
- Always return structured error codes (H6) not just strings.

==============================================================================
H2) Ensure Primitives (ADD-ONLY, idempotent)

Add a new BlueprintCallable library:
- Public/SOTS_BPGenEnsure.h
- Private/SOTS_BPGenEnsure.cpp

A) EnsureFunction
UFUNCTION(BlueprintCallable)
static bool EnsureFunction(
  const FString& BlueprintAssetPath,
  const FString& FunctionName,
  const FSOTS_BPGenFunctionSignature& Signature,  // ADD this struct
  bool bCreateIfMissing,
  bool bUpdateIfExists,
  FString& OutError,
  FString& OutErrorCode
);

Add struct:
- FSOTS_BPGenFunctionSignature
  - FString ReturnPinType (category/subcategory/subobject/container)
  - TArray<FSOTS_BPGenParamSpec> Inputs
  - TArray<FSOTS_BPGenParamSpec> Outputs (optional; usually none except return)
  - bool bPure (optional)
  - bool bConst (optional)
  - FString Access (Public/Protected/Private)
Notes:
- If exists: verify signature; if mismatch and bUpdateIfExists:
  - attempt to update signature (may require graph reconstruction)
  - if cannot update safely: return ERR_SIGNATURE_MISMATCH and leave unchanged.

B) EnsureVariable
UFUNCTION(BlueprintCallable)
static bool EnsureVariable(
  const FString& BlueprintAssetPath,
  const FString& VarName,
  const FSOTS_BPGenPinTypeSpec& Type,
  const FString& DefaultValue,
  bool bInstanceEditable,
  bool bExposeOnSpawn,
  bool bCreateIfMissing,
  bool bUpdateIfExists,
  FString& OutError,
  FString& OutErrorCode
);

C) EnsureEventDispatcher (optional but parity-friendly)
- EnsureDispatcher(BlueprintAssetPath, Name, Signature, ...)

D) EnsureInterfaceImplemented (optional)
- EnsureInterface(BlueprintAssetPath, InterfaceClassPath, ...)

Use FBlueprintEditorUtils for variable/function creation where possible.

==============================================================================
H3) UMG Authoring — Widget Tree + Properties (ADD-ONLY)

This is the big parity chunk. Split into two sub-surfaces:

1) Widget Tree edits
Add API:
- EnsureWidget(
    WidgetBlueprintAssetPath,
    WidgetName,
    WidgetClassPath,      // e.g., "/Script/UMG.TextBlock"
    ParentName (optional),
    SlotName (optional),
    bCreateIfMissing,
    ...
  )

- SetWidgetProperty(
    WidgetBlueprintAssetPath,
    WidgetName,
    PropertyPath,         // e.g., "Text", "ColorAndOpacity"
    ValueJsonOrString,
    ...
  )

Implementation hints:
- Must operate on UWidgetBlueprint + WidgetTree:
  - Create widget via WidgetTree->ConstructWidget(UClass*, FName)
  - Add child to panel via AddChild (type-specific panels)
- Expose careful errors: ERR_WIDGET_NOT_FOUND, ERR_PARENT_NOT_PANEL, ERR_PROPERTY_NOT_FOUND

2) Binding creation (UMG parity)
Add API:
- EnsureBinding(
    WidgetBlueprintAssetPath,
    WidgetName,
    PropertyName,         // e.g., "Text"
    BindingFunctionName,  // stable desired name (idempotent)
    bCreateIfMissing,
    ...
  )

Then binding graph generation uses the same BPGen GraphSpec system:
- TargetType="Function" Name=BindingFunctionName
- Apply nodes/links to return the bound value.

IMPORTANT:
- Prefer deterministic BindingFunctionName so NodeId idempotency works reliably.

==============================================================================
H4) Non-function Graph Apply (EventGraph/Macro/Construction/UMG binding graphs)
Upgrade Apply entrypoint(s) to accept a GraphTarget rather than FunctionName-only.

Add an overload (ADD-ONLY):
- ApplyGraphSpecToTarget(const FSOTS_BPGenGraphSpec& Spec, ...)

Implementation:
- Resolve BP
- Resolve target graph via H1 resolver
- Apply nodes/links exactly as before
- For EventGraph:
  - Handle event nodes (BeginPlay, Tick, CustomEvents)
  - You may need “event spawner keys”:
    - Add discovery support for events (e.g., "Event BeginPlay") in SPINE_A discovery if missing
  - Add EnsureCustomEvent primitive (optional): EnsureEventNode(EventName)

Macro/Construction:
- Similar application pipeline

UMG Binding:
- Treat as function graph (most bindings compile to functions)

==============================================================================
H5) Hardening (required for 1:1 parity feel)

1) Editor transaction wrapper (per request)
- Wrap Apply/Ensure/UMG edits in FScopedTransaction ("SOTS BPGen: <action>")
- This provides undo safety and reduces “partial apply” pain

2) Single-writer lock
- Add a global mutex in BPGen (static FCriticalSection)
- Ensure only one operation edits assets at a time (bridge requests are sequential, but be safe)

3) Deterministic pin addressing
Extend your pin resolution (ADD-ONLY):
- Primary: exact pin name
- Secondary: case-insensitive match
- Tertiary: alias map (common exec pins: "then"/"execute"/"exec")
- Quaternary: direction + category match + index (only if explicitly allowed by LinkSpec flag)
Add LinkSpec flags:
- bool bAllowHeuristicPinMatch = false; // must be opt-in

4) Structured error codes everywhere
Introduce canonical codes (strings are fine):
- ERR_UNSUPPORTED_TARGET
- ERR_TARGET_NOT_FOUND
- ERR_CREATE_NOT_ALLOWED
- ERR_SIGNATURE_MISMATCH
- ERR_NODE_NOT_FOUND
- ERR_PIN_NOT_FOUND
- ERR_SCHEMA_REJECTED
- ERR_SPAWNER_MISSING
- ERR_WIDGET_NOT_FOUND
- ERR_PROPERTY_NOT_FOUND
Return codes in:
- Apply result
- Ensure APIs
- Inspector APIs

==============================================================================
H6) Bridge/MCP routing additions (ADD-ONLY)
If SPINE_F bridge exists:
- Add new actions (route to new BPGen APIs):
  - ensure_function
  - ensure_variable
  - ensure_widget
  - set_widget_property
  - ensure_binding
  - apply_graph_spec_to_target (or extend apply_graph_spec to accept "target" block)

If SPINE_G MCP server exists:
- Add wrapper tools:
  - bpgen_ensure_function, bpgen_ensure_variable
  - bpgen_ensure_widget, bpgen_set_widget_property, bpgen_ensure_binding
- Add new prompt examples for UMG authoring and EventGraph patching.

==============================================================================
H7) Docs + Worklogs (required)
Add:
- Plugins/SOTS_BlueprintGen/Docs/BPGen_Targets_And_Ensure.md
- Plugins/SOTS_BlueprintGen/Docs/Worklogs/BPGen_SPINE_H_ParityTargetsEnsureUMG_<timestamp>.md

Include:
- TargetType enumeration + behaviors
- Ensure primitives signatures + idempotency rules
- UMG widget creation + binding strategy
- Error code table

Add an anchor:
- Plugins/SOTS_BlueprintGen/Docs/Anchor/Anchor_BPGen_SPINE_H_Parity.md
with a short [CONTEXT_ANCHOR] summary.

==============================================================================
H8) Cleanup (required)
- Delete Binaries/ + Intermediate for any plugin touched:
  - Plugins/SOTS_BlueprintGen/Binaries, Intermediate
  - Plugins/SOTS_BPGen_Bridge/Binaries, Intermediate (if touched)

==============================================================================
DONE CRITERIA (what “1:1 parity workflow” means)
- You can target and edit:
  - Function graphs (already)
  - EventGraph (create/patch custom events + connect)
  - Macro graphs (create/patch)
  - Construction script (patch)
  - UMG widget tree (create widget + set property)
  - UMG binding (ensure binding function + generate binding graph)
- You can ensure functions/variables idempotently (create or update).
- Every operation returns structured error codes + supports inspect/verify.
- MCP playbook can do: discover → ensure → apply → verify → compile → save across these targets.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_H]
- Expanded BPGen to full parity: universal graph targeting, ensure primitives (function/var/dispatcher/interface),
  UMG widget tree authoring + deterministic bindings, and hardening (transactions, single-writer lock,
  structured error codes, deterministic pin addressing).
- Bridge/MCP surfaces extended add-only to expose these actions for the iterative workflow.
*/

BPGen_SPINE_I
[STATUS 2025-12-19] DONE: protocol+features stable, dry_run guardrails, auth/rate/size checks, replay tooling/docs, delete/replace MCP wrappers.

Thought for 15s
Send2SOTS
/*
BPGen_SPINE_I — Parity Harness + Replay Runner + Protocol Versioning (the “ship-ready workflow” layer)
Goal: After SPINE_H (full surface parity), SPINE_I makes the workflow *repeatable, testable, and debuggable*:
  - Versioned protocol + feature flags (bridge/MCP stay stable over time)
  - Golden “replay” harness that can run a scripted sequence (NDJSON requests) and emit a report + diffs
  - Deterministic outputs (stable ordering) so regression checks are meaningful
  - Add-only safety + stronger diagnostics for failures in the field
SOTS laws:
  - ADD-ONLY changes (no deletions; DevTools must not lose options/features)
  - No build/run
  - Cleanup: delete touched plugin Binaries/ + Intermediate
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen + SOTS_BPGen_Bridge + DevTools (python) + BPGen prompt pack
pass: BPGen_SPINE_I
stage: CODE_REVIEW (code-only + tooling/docs)
focus: Regression harness + protocol stability + replay/diff.

==============================================================================
I0) Pre-scan (required)
- Confirm SPINE_F bridge exists (NDJSON TCP) and SPINE_G MCP server exists.
- Confirm SPINE_H error codes + graph targets + ensure primitives exist.
- Identify where bridge builds the response JSON and where inspector outputs are constructed.

==============================================================================
I1) Protocol Versioning + Feature Flags (ADD-ONLY)
Where: SOTS_BPGen_Bridge response JSON builder

Add:
- server.protocol_version (string): "1.0"
- server.features (object of booleans), ex:
  - "targets": true
  - "ensure_function": true
  - "ensure_variable": true
  - "umg": true
  - "describe_node_links": true
  - "error_codes": true

Add request-side optional:
- params.client_protocol_version (string)
If mismatch (major), respond ok:false with:
- error_code: "ERR_PROTOCOL_MISMATCH"
- errors: ["Client protocol 0.9 incompatible with server 1.0"]

Doc:
- Plugins/SOTS_BPGen_Bridge/Docs/BPGen_Bridge_Protocol.md update add-only section “ProtocolVersion & Features”.

==============================================================================
I2) Deterministic JSON Output (critical for diff-based tests)
Where: BPGen inspector + bridge JSON serialization

Make outputs stable:
- Sort node lists by:
  1) NodeId (non-empty first, lexicographic)
  2) then NodeClass
  3) then (PosY, PosX)
- Sort pin lists by:
  1) Direction (Input before Output)
  2) then PinName
- Sort link lists by:
  1) FromNodeId, FromPinName, ToNodeId, ToPinName

If you emit maps/dicts:
- Use arrays of {key,value} in stable order (avoid unordered JSON dict variance)

Result: golden files don’t flap.

==============================================================================
I3) Add “Replay Runner” (the big workflow completeness piece)
You want a way to run a whole session deterministically without an agent.

ADD a DevTools python script (add-only, new file):
- DevTools/python/bpgen_replay_runner.py

Inputs:
- --host 127.0.0.1 --port 55557
- --replay DevTools/replays/<name>.jsonl   (NDJSON: one request per line)
- --out DevTools/reports/<name>_report.json
- --diff DevTools/reports/<name>_diff.txt (optional)
- --expect DevTools/replays/<name>_expected.json (optional)

Behavior:
- For each line/request:
  - send to bridge
  - store response (including ok/errors/warnings)
  - print progress (non-silent)
- Emit:
  - JSON report with all requests+responses
  - Summary counts: ok/fail per action, error_codes histogram
- If --expect provided:
  - diff key fields using deterministic ordering
  - write a human-readable diff file
- MUST print clear debug output AND write at least one report file (per your Python law).

Also add a small helper module (if not already from SPINE_G):
- DevTools/python/sots_bpgen_bridge_client.py (reuse; do not remove old options)

==============================================================================
I4) Golden Replay Packs (ADD-ONLY content)
Add folder:
- DevTools/replays/BPGen/

Include 6 replays that cover “1:1 parity” surfaces:

01_function_print_string.jsonl
- ping
- discover_nodes("Print String")
- ensure_function(MyFunc, signature)
- apply_graph_spec (node_id + spawner_key)
- list_nodes
- describe_node(print_1)
- compile_blueprint
- save_blueprint

02_eventgraph_custom_event.jsonl
- ensure_custom_event (or apply: create custom event node + link)
- apply graph: event → sequence/branch → call function
- verify + compile + save

03_macro_create_and_use.jsonl
- ensure_macro
- apply macro graph
- apply function/event graph calling macro (if supported)
- verify + compile + save

04_construction_script_patch.jsonl
- target construction script
- add nodes / set defaults
- verify + compile + save

05_umg_widget_tree_and_binding.jsonl
- ensure_widget(TextBlock “Label”)
- set_widget_property(Label.Text = default)
- ensure_binding(Label.Text -> GetLabelText)
- apply binding function graph (return string)
- verify widget + binding function nodes
- compile + save

06_refactor_by_node_id.jsonl
- list nodes
- move nodes by node_id
- reconnect links
- verify describe + compile + save

For each replay, add an optional expected-output snapshot:
- DevTools/replays/BPGen/<name>_expected.json
(Only include key stable fields; don’t snapshot noisy timestamps.)

==============================================================================
I5) “Delete / Replace” primitives (parity polish, ADD-ONLY)
These make refactors possible without manual cleanup:

Add BPGen actions + APIs:
- delete_node_by_id (target + node_id)
- delete_link (from node_id+pin, to node_id+pin)
- replace_node (node_id preserved; new spawner_key; relink by pin-name map)

Expose through bridge + MCP wrappers:
- bpgen_delete_node, bpgen_delete_link, bpgen_replace_node

This is essential for real-world iterative edits (agents will otherwise accumulate junk nodes).

==============================================================================
I6) Transactions + Safety Backstops (ADD-ONLY)
- Ensure every bridge action that mutates assets wraps:
  - FScopedTransaction
  - Try/finally style cleanup + structural modified marks
- Add per-request “dry_run” option (where feasible):
  - returns what would change without mutating
  - even if limited, it’s a huge safety lever

Add bridge guardrails:
- MaxRequestBytes (already likely exists) + explicit ERR_REQUEST_TOO_LARGE
- Rate limit (simple): reject if >N requests/second (local only, but helps runaway loops)
- Optional shared secret token (config):
  - if set, require params.auth_token match, else ERR_UNAUTHORIZED

==============================================================================
I7) Docs + Worklogs (required)
Add:
- DevTools/prompts/BPGen/topics/replay-and-regression.md
  - how to run replay runner
  - how to add a new golden replay
  - how to interpret diffs
  - “when a replay fails, do: describe_node → refresh → recompile → re-run”

Add worklog:
- DevTools/Docs/Worklogs/BPGen_SPINE_I_ReplayRegressionProtocol_<timestamp>.md
Include:
- protocol version/features additions
- deterministic ordering rules
- replay runner CLI examples
- list of golden replays added

Optional anchor:
- DevTools/Docs/Anchor/Anchor_BPGen_SPINE_I_ReplayRegression.md ([CONTEXT_ANCHOR])

==============================================================================
I8) Cleanup (required)
Delete Binaries/ + Intermediate for any touched plugins:
- Plugins/SOTS_BlueprintGen/Binaries + Intermediate
- Plugins/SOTS_BPGen_Bridge/Binaries + Intermediate

==============================================================================
DONE CRITERIA
- Bridge returns protocol_version + features and can enforce protocol mismatch cleanly.
- Inspector/apply outputs are deterministic (stable sort).
- Replay runner can execute a full scripted session and emits a report + (optional) diff.
- Golden replay pack covers function/event/macro/construction/UMG/refactor surfaces.
- Delete/replace primitives exist so iterative editing doesn’t accumulate garbage.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_I]
- Added protocol versioning + feature flags, deterministic output ordering, and a replay/regression harness (jsonl replays + reports + diffs).
- Added delete/replace primitives and safety backstops (transactions, size/rate/auth guards) to make the workflow “ship-ready”.
*/

BPGen_SPINE_J
[STATUS 2025-12-19] DONE: AutoFix steps + conversion insertion + recipe actions (print/branch/set/bind) implemented.
Send2SOTS
/*
BPGen_SPINE_J — “Authoring Intelligence” Layer (Auto-Fix, Type Coercion, and High-Level Recipes)
Goal: With SPINE_I you can regress/test the workflow. SPINE_J makes it *smart and ergonomic*:
  - Auto-fix common failures (pin not found, schema rejects, missing conversions)
  - Type coercion + auto-insert conversion nodes
  - High-level recipe actions that expand into low-level GraphSpec edits (optional, additive)
  - Better heuristics that are opt-in and always explain what changed
This is the layer that makes BPGen feel like a “Blueprint assistant” instead of a raw graph editor.
SOTS laws:
  - ADD-ONLY
  - No build/run
  - Cleanup touched plugin(s) Binaries/Intermediate
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen + SOTS_BPGen_Bridge + DevTools prompts (optional)
pass: BPGen_SPINE_J
stage: CODE_REVIEW (code-only + docs)
focus: Auto-recovery + coercion + recipe expansions.

==============================================================================
J0) Pre-scan (required)
- Confirm SPINE_C schema linking exists and returns warnings/errors per link.
- Confirm SPINE_E inspector exists (describe_node returns pin types/defaults/links).
- Confirm SPINE_H provides structured error codes and deterministic pin matching (opt-in).

==============================================================================
J1) Add an “Explainable AutoFix” mode to Apply (ADD-ONLY)
Extend Apply params/spec:
- bool bAutoFix = false;              // JSON: "auto_fix"
- int32 AutoFixMaxSteps = 5;          // JSON: "auto_fix_max_steps"
- bool bAutoFixInsertConversions = false; // JSON: "auto_fix_insert_conversions" (separate toggle)

Apply result add-only fields:
- TArray<FSOTS_BPGenAutoFixStep> AutoFixSteps;
Where FSOTS_BPGenAutoFixStep includes:
- StepIndex
- Code ("FIX_PIN_ALIAS", "FIX_SWAP_CONNECTION", "FIX_INSERT_CONVERSION", ...)
- Description (human-readable)
- AffectedNodeIds (array)
- AffectedPins (array)
- Before/After snippets (optional small strings)

Rule:
- AutoFix never runs unless bAutoFix true.
- AutoFix must stop if it cannot confidently improve and must surface the original error.

==============================================================================
J2) Pin Alias + Intent Matching (opt-in)
When ERR_PIN_NOT_FOUND:
- If bAutoFix:
  - Use aliases table (exec pins: Execute/Then/Out, input pins: InString/String, etc.)
  - If exactly one confident match exists, rewrite link target pin name and retry link.
Record a FIX_PIN_ALIAS step.

Also support direction-based swap fix:
- If schema rejects due to reversed pins:
  - Try swapping (FromPin <-> ToPin) once.
Record FIX_SWAP_CONNECTION.

==============================================================================
J3) Type Coercion + Conversion Node Insertion (opt-in)
This is the big one for “schema rejected”.

When schema rejects a data pin connection AND bAutoFixInsertConversions:
- Inspect FromPin and ToPin types (category/subcategory/subobject/container)
- Consult a conversion table (initial v0.1):
  - Bool <-> Int (use SelectInt? or conversion nodes)
  - Int -> Float (Conv_IntToFloat)
  - Float -> Int (Conv_FloatToInt)
  - Name <-> String (Conv_NameToString / Conv_StringToName)
  - Text <-> String (Conv_StringToText / Conv_TextToString)
  - Object -> Interface (cast to interface / does implement interface patterns) (optional)
- Discover conversion node spawner_key via SPINE_A discovery (best) OR hardcode canonical UFunction paths for KismetStringLibrary/KismetMathLibrary conversions (acceptable if stable).
- Auto-insert conversion node with deterministic node_id:
  - node_id = "<fromNodeId>__to__<toNodeId>__conv__<Type>"
- Rewire:
  - From -> Conv.In
  - Conv.Out -> To
- Record FIX_INSERT_CONVERSION with details.

Safety:
- Only insert conversion when:
  - Exactly one known conversion exists for the type pair
  - Both pins are non-container or containers match
  - Not Exec pins
- If uncertain: don’t modify; report ERR_SCHEMA_REJECTED with a “suggested conversion” message.

==============================================================================
J4) Auto-Add Missing “Entry/Return” glue (optional)
If the target is a Function graph and the spec links Exec from a node that assumes an entry pin exists:
- Ensure the function entry node exists (usually UE provides it)
- Ensure return node exists if the function has return value/output pins
This can be a FIX_ENSURE_RETURN step.

(Only do this if you have stable node ids for entry/return, like "fn_entry" and "fn_return".)

==============================================================================
J5) High-Level Recipe Actions (optional but powerful, ADD-ONLY)
Add bridge actions that expand into low-level ops (still returning the expanded GraphSpec for transparency):
- action: "recipe_print_string"
  params: { blueprint_asset_path, target:{...}, message, node_id_prefix }
  -> internally:
     discover PrintString spawner_key
     build graph spec
     apply
- action: "recipe_branch_on_bool"
- action: "recipe_set_variable"
- action: "recipe_widget_bind_text"

IMPORTANT:
- Recipes are optional sugar. Keep the raw actions intact.
- Return:
  - result.expanded_graph_spec
  - result.apply_result
So the system remains debuggable.

==============================================================================
J6) Diagnostics upgrade (ADD-ONLY)
- When schema rejects, include:
  - from pin type summary
  - to pin type summary
  - reason if schema provides it
- Add ERR_SCHEMA_REJECTED_TYPE_MISMATCH (more specific)
- Add warnings when heuristics were used:
  - "Heuristic pin match applied: <old> -> <new>"

==============================================================================
J7) MCP prompt pack updates (ADD-ONLY)
Add a topic:
- DevTools/prompts/BPGen/topics/autofix-and-conversions.md
Include:
- When to enable auto_fix
- How to interpret AutoFixSteps
- How to disable heuristics for strict deterministic ops

Add example:
- examples/05_autofix_schema_reject_insert_conv.md
  - Attempt to link Int to Float without conversion
  - Enable auto_fix_insert_conversions
  - Verify conversion node inserted

==============================================================================
J8) Worklog + cleanup (required)
Worklog:
- Plugins/SOTS_BlueprintGen/Docs/Worklogs/BPGen_SPINE_J_AutoFixConversionsRecipes_<timestamp>.md
Include:
- AutoFix toggles
- Conversion table v0.1
- Recipe list + transparency contract

Cleanup:
- Delete Binaries/Intermediate for touched plugins:
  - SOTS_BlueprintGen
  - SOTS_BPGen_Bridge (if adding recipe actions)

==============================================================================
DONE CRITERIA
- Apply can optionally run AutoFix and returns explainable steps.
- Schema rejects on common type mismatches can be resolved via deterministic conversion node insertion (opt-in).
- Agents can use recipes for common tasks, but raw graph editing remains primary and transparent.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_J]
- Added optional “AutoFix” layer: pin aliasing, swap-fix, and safe conversion node insertion for common type mismatches.
- Added (optional) transparent recipe actions that expand into GraphSpecs, keeping debugging and determinism intact.
*/

BPGen_SPINE_K
[STATUS 2025-12-19] DONE: Batch/session bridge actions, cache priming/limits, timing/logs, DevTools batch/jobs runner, docs/worklogs.
Thought for 14s
Send2SOTS
/*
BPGen_SPINE_K — Production Orchestration Layer (Batch/Session, Headless Runner, and Performance)
Goal: After H (full parity), I (replay/regression), and J (autofix/recipes), SPINE_K makes BPGen “production-grade”:
  1) Batch/session execution so multi-step edits are atomic, faster, and easier to reason about
  2) Headless job runner (commandlet / inbox runner) as a reliable fallback to TCP/MCP
  3) Performance controls: cache priming, spawner cache persistence, optional pin-harvest limits
  4) Observability: structured logs + per-step timing + summary reports (non-silent tooling)
SOTS laws:
  - ADD-ONLY changes only (no removals)
  - No build/run
  - Cleanup: delete touched plugin(s) Binaries/Intermediate
  - Python scripts must print clear debug output and/or write a log/report file
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BPGen_Bridge + SOTS_BlueprintGen + DevTools (python)
pass: BPGen_SPINE_K
stage: CODE_REVIEW (code-only + tooling/docs)
focus: Batch/session + headless runner + perf + telemetry.

==============================================================================
K1) Bridge: Batch Action (ADD-ONLY)
Add a new bridge action:
- action: "batch"

Request:
{
  "tool":"bpgen",
  "action":"batch",
  "request_id":"...",
  "params":{
    "batch_id":"optional-string",
    "atomic": true,
    "stop_on_error": true,
    "commands":[
      {"action":"discover_nodes","params":{...}},
      {"action":"ensure_function","params":{...}},
      {"action":"apply_graph_spec","params":{...}},
      {"action":"compile_blueprint","params":{...}},
      {"action":"save_blueprint","params":{...}}
    ]
  }
}

Response:
{
  "ok": true|false,
  "result":{
    "batch_id":"...",
    "atomic": true,
    "steps":[
      {"index":0,"action":"discover_nodes","ok":true,"result":{...},"errors":[],"warnings":[],"ms":12},
      ...
    ],
    "ms_total": 187,
    "summary":{
      "ok_steps": 4,
      "failed_steps": 1,
      "error_codes": {"ERR_PIN_NOT_FOUND":1}
    }
  }
}

Rules:
- If atomic=true:
  - Wrap the entire batch in ONE FScopedTransaction and ONE single-writer lock.
  - If any step fails and stop_on_error=true:
    - abort remaining steps
    - still return partial step results
  - NOTE: true rollback is not guaranteed without explicit undo calls, but transaction provides best-effort safety.
- If atomic=false:
  - Each step runs independently (still sequential, still locked) and may commit partial changes.

==============================================================================
K2) Bridge: Session Support (optional but very useful, ADD-ONLY)
Add actions:
- "begin_session" -> returns session_id
- "end_session"
- "session_batch" (same as batch but associates with session_id)

Why:
- Lets you keep caches (spawner cache / discovery indexes) warm per session.
- Lets MCP execute many tool calls without re-priming every time.

Minimum:
- Maintain an in-memory map session_id -> cache scope:
  - last blueprint asset path
  - primed spawner cache set
  - last known feature flags

Safety:
- Sessions expire after N minutes idle (configurable).
- Still local-only + auth token.

==============================================================================
K3) Performance: Cache Priming + Limits (ADD-ONLY)
In BPGen (or bridge forwarding to BPGen):
Add actions/APIs:
- "prime_cache"
  params:
    - blueprint_asset_path (optional)
    - scope: "global" | "blueprint"
    - include_nodes: true/false
    - include_pins: false by default
    - max_items (default 5000)
- "clear_cache"
- "set_limits"
  - max_request_bytes (bridge)
  - max_discovery_results
  - max_pin_harvest_nodes
  - max_autofix_steps

Also ensure discovery pin harvesting remains opt-in and guarded by limits (avoid accidental expensive pin-spawn loops).

==============================================================================
K4) Observability: Timings + Structured Logs (ADD-ONLY)
A) Bridge response adds:
- server.request_ms
- server.dispatch_ms
- server.serialize_ms

B) Add structured log output (dev-only by default):
- Log category: LogSOTS_BPGenBridge (Editor)
- For each request:
  - request_id, action, ok, error_codes count, ms_total
- For batch:
  - per-step ms + summary

C) Add “dump last N requests” (optional)
- action: "get_recent_requests"
  returns a ring buffer of summaries (no huge payloads)

==============================================================================
K5) Headless Runner (fallback path) (ADD-ONLY)
Add a commandlet OR an editor utility runner that reads a job folder.

Option A (best): Editor Commandlet plugin (new or inside SOTS_BlueprintGen Editor module)
- Commandlet: SOTS_BPGenJobRunner
- CLI:
  - UEEditor-Cmd.exe <Project> -run=SOTS_BPGenJobRunner -JobsDir="...\DevTools\Inbox\BPGenJobs" -ReportDir="...\DevTools\Reports\BPGen"

Job file format (json):
{
  "job_id":"...",
  "created_utc":"...",
  "commands":[ ...same as batch.commands... ],
  "atomic": true,
  "stop_on_error": true
}

Behavior:
- Processes each *.json in JobsDir
- Writes:
  - <job_id>_report.json
  - <job_id>_log.txt
- Moves completed jobs to JobsDir/Done or JobsDir/Failed (add-only folder creation)

Option B (acceptable): Python-driven “jobs to TCP bridge”
- DevTools/python/bpgen_jobs_runner.py
  - reads JobsDir
  - sends "batch" to bridge
  - writes report files
  - prints progress (non-silent)

(Option A gives you true “no TCP server needed” headless workflow, closest to CI.)

==============================================================================
K6) DevTools: Batch + Jobs Utilities (ADD-ONLY)
Add scripts:
- DevTools/python/bpgen_batch_submit.py
  - submits a batch to the bridge
  - writes report JSON
  - prints summary
- DevTools/python/bpgen_jobs_runner.py
  - watches JobsDir (poll interval)
  - executes jobs
  - writes reports/logs
  - never silent

Keep add-only; do not modify existing DevTools commands except to ADD new menu entries if you have a launcher.

==============================================================================
K7) Docs + Worklogs (required)
Add/update docs:
- Plugins/SOTS_BPGen_Bridge/Docs/BPGen_Bridge_Protocol.md (ADD-ONLY sections)
  - "batch" action
  - session actions (if implemented)
  - timing fields

- DevTools/prompts/BPGen/topics/batch-and-sessions.md
  - When to use batch vs single calls
  - Atomic semantics + what it guarantees
  - Recommended “batch macro” for golden workflows

Worklogs:
- Plugins/SOTS_BPGen_Bridge/Docs/Worklogs/BPGen_SPINE_K_BatchSessionHeadlessPerf_<timestamp>.md
- DevTools/Docs/Worklogs/BPGen_SPINE_K_DevToolsJobs_<timestamp>.md

==============================================================================
K8) Cleanup (required)
Delete Binaries/Intermediate for touched plugins:
- Plugins/SOTS_BPGen_Bridge/Binaries + Intermediate
- Plugins/SOTS_BlueprintGen/Binaries + Intermediate
(and commandlet plugin if newly created)

==============================================================================
DONE CRITERIA
- Bridge supports "batch" with per-step results + timing, and can run atomic (single transaction/lock).
- Optional sessions keep caches warm and improve throughput.
- There is a headless runner path (commandlet preferred) that processes job files and emits reports/logs.
- DevTools scripts exist to submit batches and run job folders, always producing visible output + artifacts.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_K]
- Added batch/session orchestration, headless job runner fallback, performance cache priming/limits, and structured telemetry.
- This makes BPGen operationally “production-ready” for large iterative edits and CI-style replay runs.
*/

BPGen_SPINE_L
[STATUS 2025-12-19] DONE: Safety/guardrails (safe mode + dangerous_ok), allow/deny lists, audit logs, server_info/health/emergency_stop, DevTools safety topic + replay flags.
Send2SOTS
/*
BPGen_SPINE_L — Security, Safety, and Governance (Local-only hardening + guardrails + audit trail)
Goal: As BPGen becomes powerful (UMG edits, ensure primitives, delete/replace, batch, headless jobs),
SPINE_L adds the guardrails that keep your workflow safe, controllable, and auditable:
  - Local-only enforcement + optional auth token + allowlists
  - “Dangerous ops” gating (delete/replace, batch atomic) with explicit opt-in
  - Audit trail: per-request log + per-asset change summary + reproducible artifacts
  - Safe-mode toggles and emergency stop
SOTS laws:
  - ADD-ONLY changes only
  - No build/run
  - Cleanup: delete touched plugin Binaries/Intermediate
  - DevTools scripts must print and/or write reports (non-silent)
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BPGen_Bridge + SOTS_BlueprintGen + DevTools
pass: BPGen_SPINE_L
stage: CODE_REVIEW (code-only + tooling/docs)
focus: guardrails + audit.

==============================================================================
L1) Local-only enforcement (Bridge) (ADD-ONLY)
Even if config changes, enforce:
- BindAddress MUST default to 127.0.0.1
- If user attempts 0.0.0.0 or non-loopback:
  - refuse start unless explicitly overridden by a “danger” setting:
    - bAllowNonLoopbackBind (default false)
Return:
- ok:false, error_code: ERR_NON_LOOPBACK_BIND_DISALLOWED

Also add:
- action: "server_info" returning:
  - bind address, port, protocol_version, features, uptime, safe_mode flags

==============================================================================
L2) Optional auth token (Bridge + DevTools) (ADD-ONLY)
Bridge config:
- AuthToken (string, default empty)
If set:
- Every request MUST include params.auth_token
- If missing/mismatch:
  - ok:false, error_code: ERR_UNAUTHORIZED

DevTools:
- sots_bpgen_bridge_client.py reads env var:
  - SOTS_BPGEN_AUTH_TOKEN
and injects it automatically.

Docs:
- add section to protocol doc.

==============================================================================
L3) Operation allowlists / deny-lists (Bridge) (ADD-ONLY)
Add config arrays:
- AllowedActions (empty => allow all)
- DeniedActions (always enforced; overrides allowed)

Defaults:
- DeniedActions empty
- AllowedActions empty (no restriction)

This lets you disable “delete_*” or “batch” when needed.

==============================================================================
L4) Dangerous op gating (Bridge + BPGen) (ADD-ONLY)
Define “dangerous actions”:
- delete_node_by_id
- delete_link
- replace_node
- batch (if atomic)
- save_blueprint (optional—some teams treat save as dangerous)

Add request flag:
- params.dangerous_ok = true
If action is dangerous and flag not true:
- ok:false, error_code: ERR_DANGEROUS_OP_REQUIRES_OPT_IN
- errors: ["Set params.dangerous_ok=true to proceed"]

Also add “Safe Mode”:
- config: bSafeMode (default false)
If bSafeMode:
- deny all dangerous actions even with dangerous_ok
- return ERR_SAFE_MODE_ACTIVE

Add action:
- set_safe_mode { enabled: true/false } (requires auth token if set)

==============================================================================
L5) Audit trail (Bridge) (ADD-ONLY)
For every request, write:
- Plugins/SOTS_BPGen_Bridge/Saved/BPGenAudit/YYYYMMDD/<request_id>_<action>.json
Include:
- full request (minus auth token)
- full response
- timestamps (utc)
- duration ms
- list of assets touched (see L6)
This is your “flight recorder”.

Also keep a ring buffer in memory (already in K4 optional), but disk audit is the real value.

==============================================================================
L6) Asset change summary (BPGen) (ADD-ONLY)
On apply/ensure/umg operations, compute a lightweight “change summary”:
- blueprint_asset_path
- target graph
- created_node_ids / updated_node_ids / deleted_node_ids
- created_vars / updated_vars
- created_functions / updated_functions
- widget changes: created_widgets / property_sets / bindings_created
Return this in response.result.change_summary.

Bridge stores this into the audit JSON as “change_summary”.

==============================================================================
L7) Rate limiting & request size enforcement (Bridge) (ADD-ONLY)
- MaxRequestBytes (already likely present): enforce with ERR_REQUEST_TOO_LARGE
- Simple rate limiter:
  - MaxRequestsPerMinute (default 0 => off)
  - if exceeded: ERR_RATE_LIMITED

Add:
- action: "health" returning current counters.

==============================================================================
L8) Emergency Stop (Bridge) (ADD-ONLY)
Add:
- action: "emergency_stop"
Behavior:
- Immediately stops accepting new connections
- Cancels any pending game-thread dispatch (best effort)
- Sets bSafeMode=true
Response:
- ok:true, result:{ "stopped":true, "safe_mode":true }

Requires:
- auth token if set

==============================================================================
L9) DevTools + Prompt Pack updates (ADD-ONLY)
Add topic:
- DevTools/prompts/BPGen/topics/safety-and-audit.md
Include:
- How to set auth token
- How to enable safe mode
- How to run dangerous ops properly (dangerous_ok)
- Where audit logs live and how to attach them to bug reports

Update replay runner (SPINE_I):
- include an option: --dangerous-ok (default false)
- include --auth-token env read
- write its own report plus reference audit log paths if present

==============================================================================
L10) Docs + Worklogs (required)
- Plugins/SOTS_BPGen_Bridge/Docs/BPGen_Bridge_Safety.md
- Plugins/SOTS_BPGen_Bridge/Docs/Worklogs/BPGen_SPINE_L_SafetyAudit_<timestamp>.md
- DevTools/Docs/Worklogs/BPGen_SPINE_L_DevToolsSafety_<timestamp>.md

Include:
- Local-only policy
- Auth + safe mode + dangerous ops
- Audit log structure and retention notes

==============================================================================
L11) Cleanup (required)
Delete Binaries/Intermediate for touched plugins:
- Plugins/SOTS_BPGen_Bridge/Binaries + Intermediate
- Plugins/SOTS_BlueprintGen/Binaries + Intermediate

==============================================================================
DONE CRITERIA
- Bridge cannot accidentally expose BPGen on non-loopback without explicit opt-in.
- Optional auth token is supported end-to-end (DevTools auto-injects).
- Dangerous actions require explicit opt-in and can be disabled by safe mode.
- Audit logs are written per request with change summaries.
- Emergency stop exists for runaway sessions.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_L]
- Added security/safety governance: loopback enforcement, optional auth, allow/deny action lists,
  dangerous-op gating + safe mode, per-request audit logs, rate limiting, and emergency stop.
- This turns BPGen into a powerful but controlled authoring system suitable for long-term use.
*/

BPGen_SPINE_M
[STATUS 2025-12-19] DONE: Spec versioning/schema, canonicalize/migrate + repair_mode, migration maps, spec tools + docs.
  Send2SOTS
/*
BPGen_SPINE_M — “Paritizer” Suite: Cross-Version Resilience + Migration + Canonicalization
Goal: Full 1:1 parity across the long life of SOTS means surviving:
  - UE version bumps (5.7 -> 5.8+)
  - node/pin renames between engine versions
  - blueprint refactors (variables renamed, functions moved, widget renamed)
SPINE_M adds a compatibility layer that keeps BPGen specs working over time:
  - Canonicalization of specs (normalize, fill defaults, stable ordering)
  - Migration maps (pin aliases, node class changes, function path changes)
  - “Spec upgrade” tool (v1 -> v2) with reports
  - Robust diff/repair when targets drift (rename detection and remap)
SOTS laws:
  - ADD-ONLY
  - No build/run
  - Cleanup touched plugins Binaries/Intermediate
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen + DevTools + (optional) SOTS_BPGen_Bridge
pass: BPGen_SPINE_M
stage: CODE_REVIEW (code-only + tooling/docs)
focus: spec stability + migrations + canonicalization.

==============================================================================
M1) Spec Versioning (ADD-ONLY)
Add to GraphSpec root:
- int32 SpecVersion = 1;         // JSON: "spec_version"
- FString SpecSchema = "SOTS_BPGen_GraphSpec";  // JSON: "spec_schema"

Bridge exposes:
- action: "get_spec_schema" returning:
  - current spec_version
  - supported_versions
  - notes

When Apply receives an older spec:
- run canonicalize + migrate (best effort) before apply
- return:
  - result.spec_migrated: true/false
  - result.migration_notes: [...]

==============================================================================
M2) Canonicalizer (ADD-ONLY)
Add a BPGen utility:
- CanonicalizeGraphSpec(in/out Spec, options)

Canonicalization rules:
- Ensure every node has:
  - node_id (if missing and allowed, auto-generate deterministic id based on spawner_key + position index)
  - prefer_spawner_key default true
- Ensure every link has:
  - use_schema default true
  - break flags default false
- Normalize target block:
  - target_type names normalized (case/aliases)
- Sort nodes/links deterministically (same as SPINE_I ordering)

Expose via:
- BPGen C++ API
- Bridge action: "canonicalize_spec"
- MCP wrapper: bpgen_canonicalize_spec

Return both:
- canonical_spec
- diff notes (what changed)

==============================================================================
M3) Migration Maps (Engine + Project) (ADD-ONLY)
Add data-driven alias tables (do NOT hardcode only in C++):

A) Pin alias map
- Config/ (plugin) INI or JSON file:
  - Plugins/SOTS_BlueprintGen/Content/BPGenMigrations/pin_aliases.json
Example entries:
  { "node_class":"K2Node_CallFunction", "function_path":"/Script/Engine.KismetSystemLibrary:PrintString",
    "pin_aliases": { "InString":["String","Text","InText"], "Then":["then","Out"] } }

B) Node class migration map
- node_class_aliases.json
Example:
  { "old":"K2Node_SomethingOld", "new":"K2Node_SomethingNew" }

C) Function path migration map
- function_path_aliases.json
Example:
  { "old":"/Script/OldModule.OldLib:Conv_Foo", "new":"/Script/NewModule.NewLib:Conv_Foo" }

Load maps at editor startup or first use.

==============================================================================
M4) Rename/Drift Repair (ADD-ONLY)
When Apply fails due to missing targets:
- ERR_NODE_NOT_FOUND (by node_id) shouldn’t happen if node_id stamping works, but refactors can delete nodes.
Provide optional repair mode:
- params.repair_mode = "none"|"soft"|"aggressive" (default none)

Soft repair:
- If node_id missing, try to find a node matching:
  - spawner_key, node_class, and approximate position
- If found: re-stamp node_id and continue, recording a repair step.

Aggressive repair:
- If spawner_key missing, rediscover by function_path/node_class and attempt to remap.
- Use migration maps for function_path changes.

Always record:
- repair_steps in result (similar to SPINE_J AutoFixSteps)

==============================================================================
M5) Spec Upgrade Tooling (DevTools) (ADD-ONLY)
Add python tool:
- DevTools/python/bpgen_spec_upgrade.py

It:
- reads a spec JSON file
- calls bridge "canonicalize_spec" (and migrate) OR runs local canonicalizer if you expose it
- writes:
  - <name>_upgraded.json
  - <name>_upgrade_report.json
- prints summary

Also add:
- DevTools/python/bpgen_spec_lint.py
  - checks required fields
  - warns about risky patterns (missing node_id, heuristic pin matching enabled, etc.)

==============================================================================
M6) Docs + Worklogs (required)
Docs:
- Plugins/SOTS_BlueprintGen/Docs/BPGen_SpecVersioning_And_Migrations.md
Include:
- spec_version meaning
- migration map file locations and formats
- repair_mode behaviors
- examples of alias entries

Worklog:
- Plugins/SOTS_BlueprintGen/Docs/Worklogs/BPGen_SPINE_M_CanonicalizeMigrateRepair_<timestamp>.md
DevTools worklog:
- DevTools/Docs/Worklogs/BPGen_SPINE_M_SpecTools_<timestamp>.md

==============================================================================
M7) Cleanup (required)
Delete Binaries/Intermediate for touched plugins:
- SOTS_BlueprintGen
- SOTS_BPGen_Bridge (if you add canonicalize_spec routing)

==============================================================================
DONE CRITERIA
- GraphSpec has explicit versioning and can be canonicalized deterministically.
- Migration maps exist (data-driven) for pin/node/function-path drift.
- Apply supports optional repair modes and records repair steps.
- DevTools can upgrade/lint specs and produce reports.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_M]
- Added spec versioning + canonicalization, data-driven migration maps, drift repair modes, and DevTools spec upgrade/lint tooling.
- This keeps BPGen “1:1 parity” resilient across engine updates and project refactors.
*/

BPGen_SPINE_N
Send2SOTS
/*
BPGen_SPINE_N — Suite Integration + “One True Entry” (SOTS-wide adoption + contracts + packaging)
Goal: Now that BPGen is a full parity authoring system (H..M), SPINE_N integrates it into the broader SOTS suite
as a first-class, contract-driven capability:
  - A single canonical entry surface for all SOTS tools/agents (“One True Entry”)
  - Standard suite contracts: logging, tags, docs, anchors, shipping/test gating
  - Integration points with existing SOTS toolchain: Send2SOTS/DevTools inbox, worklog patterns, replay runner
  - Packaging and opt-in enablement (Editor-only by default; Shipping-safe)
SOTS laws:
  - ADD-ONLY
  - No build/run
  - Plugins remain decoupled (no project-level dependencies)
  - Cleanup touched plugins Binaries/Intermediate
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen + SOTS_BPGen_Bridge + DevTools + Docs/Contracts
pass: BPGen_SPINE_N
stage: CODE_REVIEW (code-only + docs)
focus: suite standardization + contracts + packaging.

==============================================================================
N1) “One True Entry” Contract (ADD-ONLY)
Create a contract doc (suite-wide):
- Plugins/SOTS_BlueprintGen/Docs/Contracts/SOTS_BPGen_IntegrationContract.md

It defines:
- Canonical tool/action names (bridge + MCP)
- GraphSpec schema/version
- Required idempotency rules:
  - every important node must have node_id
  - destructive ops must be gated
- Required verification sequence:
  - apply -> list/describe -> compile -> save (if saving allowed)
- Error code table (canonical)
- Deterministic ordering rules

This becomes the source of truth for ALL agent prompts.

==============================================================================
N2) Canonical Entry APIs (C++ + BP) (ADD-ONLY)
Add a single BlueprintFunctionLibrary entrypoint:
- USOTS_BPGenAPI (or similar)
with functions:
- ExecuteAction(Action, ParamsJsonString, OutResponseJsonString)
- ExecuteBatch(BatchJsonString, OutResponseJsonString)

Rationale:
- Even if you have direct C++ calls, this gives a stable “one surface” used by:
  - bridge
  - editor UI widgets
  - commandlets
  - future automation

Bridge then becomes a transport wrapper calling USOTS_BPGenAPI only.
(Keep existing internal APIs; this is additive, not a rewrite.)

==============================================================================
N3) DevTools Inbox Integration (ADD-ONLY)
Standardize a job folder for BPGen:
- DevTools/Inbox/BPGenJobs/
- DevTools/Reports/BPGen/

Add a “job schema” doc:
- DevTools/docs/BPGenJobSchema.md

DevTools scripts (add-only):
- bpgen_submit_job.py
  - writes a job json into Inbox
  - optionally calls bridge batch immediately
- bpgen_collect_reports.py
  - aggregates reports into a single summary CSV/JSON

Make sure scripts emit reports and print progress.

==============================================================================
N4) Send2SOTS / Prompt Pack standardization (ADD-ONLY)
Add a dedicated prompt pack index:
- DevTools/prompts/BPGen/INDEX.md
Lists:
- Topics
- Examples
- “Recommended sequences” (recipes)

Update your “buddy instructions” (if you maintain a copilot/buddy law file) ADD-ONLY:
- “For Blueprint authoring tasks, use BPGen MCP tools; do not hand-edit BPs unless necessary.”
(But keep optional escape hatch.)

==============================================================================
N5) Shipping/Test safety gating (ADD-ONLY)
Ensure all BPGen authoring functionality is Editor-only:
- SOTS_BlueprintGen should be Editor module or Editor-only codepaths guarded:
  - #if WITH_EDITOR
  - Build.cs: "UnrealEd" only in Editor builds
- SOTS_BPGen_Bridge must be Editor-only.
- Ensure no runtime module references editor-only headers.

Add doc:
- Plugins/SOTS_BlueprintGen/Docs/ShippingSafety.md
- Plugins/SOTS_BPGen_Bridge/Docs/ShippingSafety.md

Include:
- Build.cs module lists
- compile guards used
- default disabled in non-editor configs

==============================================================================
N6) Unified Logging + Categories (ADD-ONLY)
Define log categories:
- LogSOTS_BPGen (BPGen core)
- LogSOTS_BPGenBridge (bridge)

Ensure:
- logs are dev-only or controlled via cvars
- no spam by default

==============================================================================
N7) Versioned Bundle + Release Notes (ADD-ONLY)
Create:
- Plugins/SOTS_BlueprintGen/Docs/ReleaseNotes_BPGen.md
- Plugins/SOTS_BPGen_Bridge/Docs/ReleaseNotes_BPGenBridge.md
Include:
- protocol/spec version
- feature flags
- breaking changes policy (ideally none; use migrations)

Also create:
- Plugins/SOTS_BlueprintGen/Docs/Anchor/Anchor_BPGen_SPINE_N_SuiteIntegration.md
with [CONTEXT_ANCHOR] snapshot.

==============================================================================
N8) Cleanup (required)
Delete Binaries/Intermediate for touched plugins:
- SOTS_BlueprintGen
- SOTS_BPGen_Bridge

==============================================================================
DONE CRITERIA
- There is a single canonical integration contract + canonical entry API surface.
- DevTools job inbox/reports are standardized and documented.
- Editor-only safety is verified and documented.
- Logging/categories, release notes, and suite-style docs/anchors exist.
- BPGen is now a “first-class SOTS suite capability” that agents can use consistently.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_N]
- Integrated BPGen as a suite-standard capability: one canonical entry surface, integration contract, inbox job schema,
  editor-only shipping safety, unified logging, and versioned docs/release notes.
- Establishes the long-term maintainable “One True Entry” for all BP authoring automation in SOTS.
*/

BPGen_SPINE_O
Send2SOTS
/*
BPGen_SPINE_O — BPGen Control Center (Editor UX + Live Ops Dashboard + Visual Debug)
Goal: Complete 1:1 parity not just in capability, but in *day-to-day usability*:
  - An in-editor “BPGen Control Center” panel to run/monitor jobs, view audits, and inspect graphs
  - Live bridge status + session console + last requests/errors
  - Visual debug overlays: highlight created/updated nodes, failed links, conversion insertions, etc.
  - A “golden workflow” UI: Discover → Build Spec → Apply → Verify → Compile/Save (with one-click)
SOTS laws:
  - ADD-ONLY changes (no removals)
  - No build/run
  - Cleanup: delete touched plugin(s) Binaries/Intermediate
  - Editor-only: shipping/test safe
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen + SOTS_BPGen_Bridge + (optional) SOTS_UI (editor-only widget) + DevTools
pass: BPGen_SPINE_O
stage: CODE_REVIEW (code-only + editor tooling + docs)
focus: Editor UX + visual debugging + live monitoring.

==============================================================================
O1) Add an Editor UI Panel (“BPGen Control Center”) (ADD-ONLY)
Preferred: Editor-only plugin/module (can live inside SOTS_BlueprintGen Editor module, or new plugin SOTS_BPGen_Editor)

Deliverables:
- A dockable tab: "SOTS BPGen"
- Sections:
  A) Server
    - Start/Stop bridge (shows host/port/protocol/features)
    - Safe mode toggle (if SPINE_L)
    - Sessions: begin/end, current session id
  B) Jobs
    - Submit a JSON job file (pick file)
    - Run Inbox jobs folder (DevTools/Inbox/BPGenJobs)
    - Show last N job reports + open report file
  C) Workflow
    - Blueprint asset picker
    - Target selector (Function/EventGraph/Macro/Construction/WidgetBinding…)
    - Search box: Discover nodes (shows descriptors/spawner_key)
    - “Generate Spec” (from selected descriptors) -> preview JSON
    - Apply + Verify + Compile + Save buttons
  D) Inspector
    - List nodes (by node_id)
    - Select node -> Describe (pins/types/defaults/links)
    - Copy node summary JSON to clipboard
  E) Audit
    - Browse audit logs folder (per request)
    - Quick filters: action, ok/fail, error_code

Implementation hints:
- Use Slate (SDockTab) or Editor Utility Widget (EUW) if you prefer faster iteration.
- If EUW: expose BP-callable entrypoints in BPGen/Bridge to fetch data and run actions.

==============================================================================
O2) Visual Debug Overlays (ADD-ONLY)
Goal: when BPGen edits a graph, you can *see* what happened instantly.

Add a “debug annotate” option to apply/batch:
- params.debug_annotate = true

Behavior (Editor-only):
- For created nodes: tint/comment marker, e.g. append to node comment:
  "[BPGEN] CREATED node_id=..."
- For updated nodes: "[BPGEN] UPDATED ..."
- For autofix/inserted conversions (SPINE_J): "[BPGEN] FIX: INSERT_CONVERSION ..."

Optional nicer version:
- Use node “bubble” colors or custom K2 node annotation if supported.

Also add a “Clear BPGen annotations” action:
- action: "clear_annotations"
  params: { blueprint_asset_path, target:{...}, scope:"target|blueprint" }

This keeps graphs from accumulating debug clutter.

==============================================================================
O3) Click-to-Jump: NodeId navigation (ADD-ONLY)
Add an action:
- focus_node
  params: { blueprint_asset_path, target:{...}, node_id }
Behavior:
- Opens the blueprint editor (if possible)
- Focuses/zooms to the node (best effort)
If focusing APIs are too editor-internal, at least return node position so the UI can show it.

==============================================================================
O4) “Spec Builder” convenience (ADD-ONLY)
Inside BPGen (or in the Editor panel), add a small helper that builds a GraphSpec from selected descriptors:
- Choose descriptor(s) -> produce node specs with:
  - node_id prefix + deterministic suffix
  - spawner_key + function_path for fallback
  - default positions (grid)
- Optional: auto-wire exec chain in selection order

This is NOT replacing authored specs; it’s a convenience for rapid prototyping.

==============================================================================
O5) Live Monitoring + Recent Requests (ADD-ONLY)
If SPINE_K/L exist:
- Bridge action: get_recent_requests (ring buffer)
- Bridge action: server_info / health
Editor panel shows:
- last 20 requests (action, ok, ms, error_code)
- click opens the audit JSON on disk
- quick “copy last error” button

==============================================================================
O6) “Golden Workflow Buttons” (ADD-ONLY)
Add UI buttons that run known-safe flows via batch:
- PrintString Function (example 01)
- Ensure var + Set + Branch (example 02)
- UMG text binding flow (example 05)
Each button:
- runs a batch command set
- displays step-by-step results and timings
- offers “open affected blueprint” and “focus node” shortcuts

This makes BPGen approachable for daily use and demos.

==============================================================================
O7) Docs + Worklogs (required)
Add:
- Docs/BPGen_ControlCenter.md (where to find tab, what it does)
- Docs/Worklogs/BPGen_SPINE_O_ControlCenterVisualDebug_<timestamp>.md
Include:
- panel layout
- supported actions
- debug annotate scheme
- how to clear annotations
- how to view audit logs

Add anchor:
- Docs/Anchor/Anchor_BPGen_SPINE_O_ControlCenter.md with [CONTEXT_ANCHOR]

==============================================================================
O8) Shipping/Test Safety (required)
- Everything in SPINE_O must be Editor-only:
  - either Editor module/plugin
  - #if WITH_EDITOR guards
- No runtime dependencies on editor-only headers in runtime modules.

==============================================================================
O9) Cleanup (required)
Delete Binaries/Intermediate for touched plugins:
- SOTS_BlueprintGen
- SOTS_BPGen_Bridge
- (and any new editor plugin you add)

==============================================================================
DONE CRITERIA
- You have a dockable BPGen Control Center in-editor that can run the end-to-end workflow without external tools.
- You can visually see what BPGen changed (created/updated/fixed nodes) and clear annotations.
- You can inspect nodes by node_id, jump/focus to them, and browse audit logs from the UI.
- This completes the “1:1 parity” system with a usable operator experience.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_O]
- Added an Editor BPGen Control Center: run/monitor bridge + jobs + workflow wizard + inspector + audit browser.
- Added visual debugging (annotations/highlights), node_id focus/jump, and golden workflow buttons for daily use and demos.
*/

BPGen_SPINE_P
Send2SOTS
/*
BPGen_SPINE_P — “Fab/Marketplace-Grade” Packaging + Documentation + Templates (distribution-ready)
Goal: Make BPGen (and its bridge/tooling) cleanly publishable and reusable as a professional-grade product:
  - Clear module separation (runtime vs editor) and zero shipping leakage
  - Polished docs, templates, and example packs
  - Deterministic, versioned assets (protocol/spec versions, migration policy)
  - Optional sample project content that is redistributable
  - Turnkey setup instructions for end users (including MCP + DevTools)
SOTS laws:
  - ADD-ONLY changes
  - No build/run
  - Cleanup touched plugin(s) Binaries/Intermediate
  - If intended for FAB later: ensure no EpicExampleContent or non-redistributable content is included
*/

[SOTS_BUDDY_PASS]
plugin: SOTS_BlueprintGen + SOTS_BPGen_Bridge + DevTools prompt pack
pass: BPGen_SPINE_P
stage: CODE_REVIEW (packaging + docs)
focus: distribution readiness.

==============================================================================
P1) Module hygiene + shipping gating (ADD-ONLY)
Ensure:
- SOTS_BlueprintGen has:
  - Runtime module (optional, minimal) OR purely Editor module if all functionality is editor-only
- Any editor-only includes live behind:
  - #if WITH_EDITOR
- Build.cs uses:
  - "UnrealEd" only in Editor module targets
- Bridge is Editor-only plugin/module.

Add docs:
- Docs/Packaging/ModuleBoundaries.md
- Docs/ShippingSafety.md (if not already from SPINE_N)

==============================================================================
P2) Public API polish + stable naming (ADD-ONLY)
- Freeze action names, error codes, and result fields:
  - protocol_version
  - spec_version
  - features flags
- Add “deprecation policy” doc:
  - never remove fields; only add
  - keep old action aliases for N versions
  - migrations maps in Content/BPGenMigrations

Docs:
- Docs/API/BPGen_ActionReference.md
- Docs/API/BPGen_ErrorCodes.md
- Docs/API/BPGen_ResultSchemas.md

==============================================================================
P3) Templates (turnkey “starter kits”) (ADD-ONLY)
Add reusable template files:
- Templates/GraphSpecs/
  - function_print_string.json
  - eventgraph_custom_event.json
  - umg_binding_text.json
  - macro_basic.json
- Templates/Jobs/
  - job_batch_print_string.json
  - job_umg_binding.json
- Templates/Replays/
  - replay_function_print_string.jsonl
  - replay_umg_binding.jsonl

Each template includes comments (or a README next to it) describing what fields to edit.

==============================================================================
P4) Example Packs (redistributable) (ADD-ONLY)
Create an Examples folder that does NOT include restricted content:
- Examples/Blueprints/
  - a small “BPGenDemoActor” blueprint (if allowed) OR a text-only guide for creating it
If you cannot ship actual uassets safely:
- Provide step-by-step creation instructions + GraphSpecs that operate on user-created assets.

Include:
- Examples/README.md
- Examples/ExpectedOutcomes.md (screenshots optional; if not, describe results)

==============================================================================
P5) End-user onboarding (MCP + bridge) (ADD-ONLY)
Add a single “Getting Started” doc that covers the full workflow:
- Docs/GettingStarted.md
Sections:
1) Enable plugins (BlueprintGen + Bridge)
2) Start the bridge (Control Center or auto-start)
3) Run MCP server (python)
4) Run Example 01 (discover→apply→verify→compile→save)
5) Troubleshooting (ports, auth token, safe mode, schema rejects)
6) Updating/migrations (spec_version, canonicalize, upgrade tool)

Also add:
- Docs/FAQ.md

==============================================================================
P6) Licensing + attribution + third-party notices (ADD-ONLY)
If you borrowed patterns from VibeUE:
- Do NOT copy code unless license permits.
- Add:
  - Docs/ThirdPartyNotices.md
  - Docs/Attribution.md
Include:
- tooling dependencies (FastMCP, python libs)
- any inspiration references (non-code)

==============================================================================
P7) Distribution toggles (ADD-ONLY)
Add a plugin setting:
- bEnableRemoteBridge (default false)
- bEnableMCPDocs (docs only; harmless)
- bEnableAuditLogs (default true in Editor, optional)
- SafeMode default for new installs (maybe true until user opts in)

This helps marketplace users feel safe enabling a “remote authoring” plugin.

==============================================================================
P8) Validation checklist (doc-only, ADD-ONLY)
Create:
- Docs/ReleaseChecklist.md
Include:
- Shipping build compiles (no editor symbols)
- No restricted content
- Default port local-only
- Auth token option documented
- Safe mode documented
- Templates run end-to-end
- Replay runner passes
- Deterministic output verified

==============================================================================
P9) Cleanup (required)
Delete Binaries/Intermediate for touched plugins:
- SOTS_BlueprintGen
- SOTS_BPGen_Bridge
- (any editor UI plugin)

==============================================================================
DONE CRITERIA
- BPGen is packaged with clean module boundaries and shipping safety.
- Docs + templates + examples make it turnkey for new users.
- API and protocol are stable and versioned with a clear deprecation/migration policy.
- No non-redistributable content is included; third-party notices are present.
*/

/*
[CONTEXT_ANCHOR][BPGen_SPINE_P]
- Packaged BPGen/Bridge/tooling to marketplace-grade quality: stable API, templates/examples, onboarding docs,
  shipping safety, licensing/attribution, and release checklists.
*/
