# SOTS_MMSS Resume Policy

- `RequestMusicByTag` and `RequestMusicByMissionAndTag` (`Plugins/SOTS_MMSS/Source/SOTS_MMSS/Private/SOTS_MMSSSubsystem.cpp#L105-L133`) update `CurrentTrackId`, `CurrentTrackIdName`, and `CurrentMusicRoleTag` before calling `InternalRequestTrack`. The subsystem thus keeps the requested tag even when no mission is active, and `SetCurrentMissionId` simply flips the mission context without wiping the track fields.
- `InternalRequestTrack` validates the mission-specific entry when `MissionId` is populated; when `MissionId == NAME_None` it now first tries to resolve the requested `TrackId` inside `Library->DefaultMusicSet` before falling back to the first entry (lines `#L235-L262`). The runtime audio component still only ever plays one track, but mission-less playback keeps the intent in `CurrentTrackIdName`/`CurrentMusicRoleTag` (which flow into the snapshot via `BuildProfileData` at `#L143-L149`), even if the actual asset falls back to the default entry list.
- Profile serialization (`BuildProfileData` / `ApplyProfileData`, `#L143-L159`) captures `CurrentMusicRoleTag`, `CurrentTrackIdName`, and the `PlaybackPositionSeconds` stored in `LastPlaybackTimeSeconds`, so reloading a profile re-issues the desired tag even without a mission id.

## "Close enough" timer resume
- `LastPlaybackTimeSeconds` is only seeded explicitly from `RequestRoleTrack(... StartTime)` and when a snapshot is applied (`#L134-L158`). The audio component is never queried for its current playback time, so the stored value reflects the last resume request rather than an exact sample of the prior play head (see `Plugins/121625_OVERVIEW.txt:579-586` for the same observation).
- `HandleLoadedSound` now checks a resume flag (`bWasPlayingBeforeWorldChange`) plus the stored `LastPlaybackTimeSeconds` and attempts to restart the new track at that time before falling back to the standard fade-in. The flag is set whenever `RequestRoleTrack` or `ApplyProfileData` supplies a non-zero restart time, so the subsystem still treats resume as a "close enough" placeholder (no exact frame sampling) but will honor the stored intent whenever a matching track is requested.
- Treat this surface as tolerant: anything that needs a more faithful resume must capture the playback position (and set the resume flag) before tearing down the audio component and then replay using the saved position, but the current implementation only stores/upgrades the time during manual or snapshot-driven requests.

## Multi-layer plan
- The subsystem currently tracks a single `FGameplayTag`, single persistent `UAudioComponent`, and does not expose any per-layer state, so only one music track can be active at any time. Multi-layer behavior (e.g., stacking role-based layers or transitioning between layers without killing the base track) is still planned and not yet implemented in code. Documenting this gap here keeps the policy intact until the multi-layer design lands.
