# SOTS SkillTree Registration and Unlock Policy

## Purpose
Capture the locked expectations for the skill tree backend: when data becomes live, how the global point pool is negotiated, why every node carries both an identifier and a gameplay tag, and how downstream FX/UI/Stats find out about unlocks.

## 1. Startup / safehouse / mission registration window
- `USOTS_SkillTreeSubsystem` registers itself with `USOTS_ProfileSubsystem` during `Initialize`, which is invoked by the game instance at startup so the profile provider exists before any mission logic runs ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp#L23-L48)).
- Per-player `USOTS_SkillTreeComponent` instances call `InitializeSkillTree` from `BeginPlay`, so each tree definition is registered the first time the safehouse/mission actor spawns rather than ad hoc during gameplay; this explains why tree setup works on load, on safehouse entry, and at mission start without repeated registrations ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeComponent.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeComponent.cpp#L12-L46); [Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeComponent.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeComponent.cpp#L18-L82)).
- `RegisterSkillTree` is the single authoritative hook that caches a definition by `TreeId` and seeds the runtime state; everything else (unlock requests, point adjustments) routes through the subsystem once this registration has happened ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp#L51-L83)).

## 2. Global skill points pool
- `FSOTS_SkillTreeRuntimeState` lives per `TreeId` inside the subsystem and carries `AvailablePoints`, which represents the shared pool that powers all skill-node decisions ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeTypes.h](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeTypes.h#L191-L232)).
- `USOTS_SkillTreeSubsystem::AddSkillPoints` mutates that single pool (clamped at zero) and immediately fires `OnSkillTreeStateChanged` so any UI or stats consumer sees the new balance without duplicating local bookkeeping ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp#L379-L402); [Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeSubsystem.h](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeSubsystem.h#L31-L131)).

## 3. Hybrid unlock identity (tag + id)
- Every `USOTS_SkillTreeDefinition` carries a `TreeId`, and each `FSOTS_SkillNodeDefinition` exposes a unique `NodeId` plus a `SkillTag`/`GrantedTags` blob, which allows both code-driven queries (`TreeId` + `NodeId`) and tag-driven gating (GAS, MissionDirector, etc.) to remain in sync ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeDefinition.h](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeDefinition.h#L12-L38); [Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeTypes.h](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeTypes.h#L90-L167)).
- The subsystem mirrors granted tags into the global tag manager inside `UnlockNode`, so the same `SkillTag` that identifies the node can be used by FX/UI/Stats downstream without having to crack the runtime state directly ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp#L101-L145)).

## 4. Unlock broadcast surfaces
- `USOTS_SkillTreeSubsystem::UnlockNode` is the canonical unlock path; it zaps points, logs the change, applies granted tags, and broadcasts `OnSkillTreeStateChanged` so any consumer can react to the new `FSOTS_SkillTreeRuntimeState` snapshot ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp#L128-L175); [Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeSubsystem.h](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeSubsystem.h#L31-L131)).
- A new `OnSkillNodeUnlocked` delegate fires immediately after every unlock so FX, UI, and Stats can subscribe to the precise `(TreeId, NodeId)` pair without polling for state diffs ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeSubsystem.h](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeSubsystem.h#L31-L131); [Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeSubsystem.cpp#L155-L179)).
- Per-component events (`OnNodeStatusChanged`, `OnSkillPointsChanged`) broadcast to local UI contexts before the subsystem sync occurs, so mission/safehouse widgets can show unlock animations immediately while the subsystem relays the global update ([Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeComponent.h](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Public/SOTS_SkillTreeComponent.h#L24-L80); [Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeComponent.cpp](Plugins/SOTS_SkillTree/Source/SOTS_SkillTree/Private/SOTS_SkillTreeComponent.cpp#L90-L160)).

## 5. Policy summary
1. Registration happens once per actor BeginPlay (safehouse/mission) and never during mid-gameplay loops, preventing duplicate trees and ensuring the subsystem owns the canonical state.
2. All point bookkeeping lives in `FSOTS_SkillTreeRuntimeState`, and `AddSkillPoints` is the exclusive mutator for that pool.
3. Each unlock carries a dual identity (`NodeId` for runtime checks, `SkillTag`/`GrantedTags` for tag-driven flows), keeping content and code aligned.
4. Unlock listeners should bind to `OnSkillNodeUnlocked` or `OnSkillTreeStateChanged`; per-component delegates are for localized UI updates.
5. FX/UI/Stats hooks must never bypass `UnlockNode`/`AddSkillPoints`, because those functions are the only ones that log, tag, and broadcast the state changes that downstream systems rely on.
